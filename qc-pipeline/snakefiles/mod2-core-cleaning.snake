rule_stem = 'maf_removal_markers'
rule maf_removal_markers:   #Minor allele frequencies removal
    input:
        bedset = rules.remove_markers_aa_theta_dev.output.bedset
    output:
        bedset=expand(str(tmpMod2/rule_stem)
                          + '{ext}', ext=['.bed','.bim','.fam']),
        callrates = expand(str(tmpMod2/rule_stem)
                          + '{ext}', ext=['.lmiss','.imiss']),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/rule_stem).with_suffix(".png"),
                      category="Module 2 Core samples and infere pedigree",
                      caption=(resultPath/rule_stem).with_suffix(".rst"))

    params:
        treshold = config['maf_thr']

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, "Initial cleaning: Low minor allele frequencies removal(--maf)\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--maf", str(params.treshold),
                "--out", outTrunk,      # previously named superclean_maf
                "--make-bed" ], check=True)
        dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",cols = [0,1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

        # call rates for maf will be maf_removal_markers.output.bedset imiss and lmiss
        # these will be reused later
        subprocess.run([plinklocal,
                "--bfile", outTrunk,
                "--missing",
                "--out", outTrunk ], check=True)

        mqc.plot_point_and_line(dropouts, outTrunk+".lmiss", output.plot,
                                column="F_MISS",ylabel="1 - missingness")


rule_stem = 'tmp_missing_genotype_samples'
rule missing_genotype_samples:
    input:
        bedset = rules.maf_removal_markers.output.bedset
    output:
        bedset=expand(str(tmpMod2/rule_stem)
                          + '{ext}', ext=['.bed','.bim','.fam']),  # earlier called superclean_maf_mind
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    params:
        treshold = config['mind_thr']

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, "Missing genotype {item_type} (--mind)\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        # First extract temporary samples based on earlier filtered markers (maf_removal_markers)
        # Later these will be used to extract samples permanently (rule clean_samples:)
        mqc.missing_genotype_rate(rule,
                        inTrunk, outTrunk, sample=True, treshold=params.treshold,
                        result_file=output.results)


rule_stem = "perm_after_mind"
rule clean_samples:
    input:
        # This is for permanent removal - as it was wayback before sevaral removals
        perm_bedset = rules.maf_removal_markers.input.bedset,
        # This is based on earlier temporary filters
        bedset = rules.missing_genotype_samples.output.bedset,
        # While this is callrates we computed at the --maf stage
        callrates = rules.maf_removal_markers.output.callrates
    output:
        perm_bedset=expand(str(tmpMod2/'missing_genotype_samples')
                          + '{ext}', ext=['.bed','.bim','.fam']),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/rule_stem).with_suffix(".png"),
                      category="Module 2 Core samples and infere pedigree",
                      caption=(resultPath/rule_stem).with_suffix(".rst"))

    run:
        oldPermTrunk =  mqc.plinkBase(input.perm_bedset[0])   # what we had
        callRateTrunk = mqc.plinkBase(input.callrates[0])

        inTrunk =  mqc.plinkBase(input.bedset[0])             # what we temporary filtered
        permTrunk =  mqc.plinkBase(output.perm_bedset[0])     # what we are making

        # PERMANENT removal of very-missing individuals from FULL dataset
        subprocess.run([plinklocal,
                "--bfile",oldPermTrunk,
                "--keep",inTrunk + ".fam", # keeping those samples that just passed the --mind threshold
                "--out", permTrunk,        # earlier called full_mind
                "--make-bed" ], check=True)
        dropouts = mqc.checkUpdates(oldPermTrunk+".fam", permTrunk+".fam",cols = [0,1],
                                    sanityCheck = "removal", fullList = True)

        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

        # call rates for samples were previously computed, we now know how many actually got cut
        mqc.plot_point_and_line(dropouts, callRateTrunk+".imiss", output.plot,
                                column="F_MISS",ylabel="1 - missingness")


rule_stem = 'tmp_missing_genotype_markers' # used for outputfilenames
rule missing_genotype_markers:
    input:
        # This is based on earlier temporary filters - the same that we used to remember samples permanently
        bedset = rules.missing_genotype_samples.output.bedset
    output:
        bedset=expand(str(tmpMod2/rule_stem)
                          + '{ext}', ext=['.bed','.bim','.fam']),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/rule_stem).with_suffix(".png"),
                      category="Module 2 Core samples and infere pedigree",
                      caption=(resultPath/rule_stem).with_suffix(".rst"))
    params:
        treshold = config['geno_thr']
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, "Missing genotype {item_type} (--geno)\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        dropouts = mqc.missing_genotype_rate(rule,
                        inTrunk, outTrunk, sample=False, treshold=params.treshold,
                        result_file=output.results,
                        plot_file=output.plot)


rule_stem = 'tmp_exclude_non-autosomal+unplaced_markers' # used for outputfilenames
rule exclude_unplaced_and_non_autosomal_markers:
    input:
        # This is based on earlier temporary filters - the same that we used to remember samples permanently
        bedset = rules.missing_genotype_markers.output.bedset
    output:
        bedset = expand(str(tmpMod2/rule_stem)+'{ext}', ext=['.bed','.bim','.fam']),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, "Excluded unplaced and non-autosomal {item_type} (--autosome)\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--autosome",                     # identifies markers
                "--out", outTrunk,                # called superclean_autosomal
                "--make-bed" ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",cols = [0,1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule

        mqc.saveYamlResults(output.results, dropouts)

rule_stem = 'tmp_hwe_filtered_markers' # used for outputfilenames
rule hardy_weinberg_filtered_markers:
    input:
        # This is based on earlier temporary filters - the same that we used to remember samples permanently
        bedset = rules.exclude_unplaced_and_non_autosomal_markers.output.bedset
    output:
        bedset=expand(str(tmpMod2/rule_stem) + '{ext}', ext=['.bed','.bim','.fam']),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    params:
        treshold = config['hwe_thr']
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, "Missing Hardy-Weinberg filtering {item_type} (--hwe)\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.bedset[0])

        mqc.low_hwe_rate(rule, inTrunk, outTrunk, treshold=params.treshold,
                     hwe_switches = ["--hardy"],
                     result_file = output.results, plot_file=output.plot)

rule_stem = 'tmp_excluded_strand_amb_markers' # used for outputfilenames
rule exclude_strand_ambigious_markers:
    input:
        # This is based on earlier temporary filters
        bedset = rules.hardy_weinberg_filtered_markers.output.bedset
    output:
        bedset=expand(str(tmpMod2/rule_stem) + '{ext}', ext=['.bed','.bim','.fam']),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, "Excluding ambigious {item_type} (GC/CG/AT/TA\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        mqc.exclude_strand_ambigious_markers(inTrunk, outTrunk, plinklocal)
        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",cols = [0,1], sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

rule_stem = 'tmp_high_ld_excluded_markers' # used for outputfilenames
rule exclude_high_ld_markers:
    input:
        # This is based on earlier temporary filters
        bedset = rules.exclude_strand_ambigious_markers.output.bedset,
        high_ld_regions_hg19 = config["high_ld_regions_hg19"]
    output:
        bedset=expand(str(tmpMod2/rule_stem) + '{ext}', ext=['.bed','.bim','.fam']),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])


        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--exclude", "range", input.high_ld_regions_hg19,    # identifies markers
                "--out", outTrunk,                                   # called superclean_no_ag_ct_ld before
                "--make-bed"  ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",cols = [0,1], sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

rule_stem = 'tmp_prune_markers' # used for outputfilenames
rule prune_markers:
    input:
        # This is based on earlier temporary filters
        bedset = rules.exclude_high_ld_markers.output.bedset,
    output:
        bedset=expand(str(tmpMod2/rule_stem) + '{ext}', ext=['.bed','.bim','.fam']),
        exclude_list = (tmpMod2/rule_stem).with_suffix(".prune.in"),  # called prune_markers_tmp.prune.in before. Will be used both in a temporary pass, but also during final core-set generation
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    params:
        prune_cmd = config["prune_cmd"].split()    # As plink will want a list

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run([plinklocal,
                "--bfile", inTrunk,
                "--make-founders",
                "--out", outTrunk]    # no bed-file prodused, just .prune.in (exclude_list)
                + params.prune_cmd , check=True)  # note that we here add a list to another list ...


        subprocess.run([plinklocal,
                "--bfile", inTrunk,
                "--extract", output.exclude_list,
                "--out", outTrunk,                  # called superclean_pruned before
                "--make-bed" ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",cols = [0,1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)


rule_stem = 'ped_incons_prep' # used for outputfilenames
rule pedigree_inconsistence_prep:
    input:
        in_geno = rules.missing_genotype_markers.output.bedset,
        in_all= rules.clean_samples.output.perm_bedset,
        clean_snps = rules.prune_markers.output.exclude_list
    output:
        bedset=expand(str(tmpMod2/rule_stem) + '{ext}', ext=['.bed','.bim','.fam']),
        genome = (tmpMod2/rule_stem).with_suffix(".genome"),
        inferpedx = tmpMod2/"inferpedx.sexcheck",
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inGenoTrunk =  mqc.plinkBase(input.in_geno[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

  	# plink will recommend sex assignments based on X het and Y calls
        subprocess.run([plinklocal,
                "--bfile", inGenoTrunk,
                "--check-sex", "ycount",
                "--out", mqc.plinkBase(output.inferpedx)  ], check=True) # local stem: don't want to overwrite logfiles

        # get PIHAT estimates
        subprocess.run([plinklocal,
                "--bfile", inGenoTrunk,
                "--extract", input.clean_snps,
                "--genome", "--min", "0.10",                 # not parametrized for now
                "--out", outTrunk,                           # called inferped_pruned before
                "--make-bed" ], check=True)

        dropouts = mqc.checkUpdates(inGenoTrunk+".bim", outTrunk+".bim",cols = [0,1],
                                    sanityCheck = "remove", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)


# This rule is still in shell-syntax as we have not decided what the final solution should be.
# We would like to automate the triad-patching
rule pedigree_fu_detector_solver:
    input:
        in_geno = rules.missing_genotype_markers.output.bedset,
        in_all = rules.clean_samples.output.perm_bedset,
        ped_pruned = rules.pedigree_inconsistence_prep.output.bedset,
        ped_pruned_pihat = rules.pedigree_inconsistence_prep.output.genome,
        ped_sexcheck = rules.pedigree_inconsistence_prep.output.inferpedx
    output:
        pheno_ok_flags = tmpMod2/'phenotypesOK.txt',  # A list of samples that have passed sanitycheck?
        # Under: INFERRED family info, SUPERCLEAN markers
  	inferped_pruned = expand(str(tmpMod2/'inferped_pruned') + '{ext}', ext=['.bed','.bim','.fam']) ,
        # Under  INFERRED family info, ALL markers
       	inferped_all = expand(str(tmpMod2/'inferped_all') + '{ext}', ext=['.bed','.bim','.fam']) ,
        Rfixed_fam = tmpMod2/"inferped_updated.fam",
    params:
        outdir = tmpMod2,
        resdir = resultPath,
	inferfam = config['infer_recfam'],
	inferbad = config['infer_badids']
    shell:
        """
        set -x
        # lets used trunks to mimic earlier behaviour by extracting truncts from input/output
        foo={input.in_geno[0]}
        inGenoTrunk=${{foo%\.*}}
        foo={input.in_all[0]}
        inAllTrunk=${{foo%\.*}}
        foo={input.ped_pruned[0]}
        pedPrunedTrunk=${{foo%\.*}}

        foo={output.inferped_pruned[0]}
        outPrunedTrunk=${{foo%\.*}}
        foo={output.inferped_all[0]}
        outAllTrunk=${{foo%\.*}}

        # There used to be a column extractor here, but it didn't work so gutorm removed it
        # the .genome file is not tab-separated). Remove this after test/confirm
 	# cut -f 2,4,8,10 input.ped_pruned_pihat > output.ped_pruned_pihat
        # We use the input.ped_pruned_pihat directlry in the R script later

	# # ERROR if fam files were different for PRUNED and ALL markers (can't update then)
       	diff $inAllTrunk.fam $pedPrunedTrunk.fam

	# R script for updating fam file
	# 1. input fam file
	# 2. pihat file
	# 3. PLINK's sexcheck results
	# 4. /media/local-disk2/helgeland/rotterdam1/inferred-pedigree/permanent_reconstruct-fam.txt
	# 5. /media/local-disk2/helgeland/rotterdam1/inferred-pedigree/permanent_bad-sample-IIDs.txt
	# 6. inferped_data.RData
	# 7. updated fam file  - The one we will later use
	# 8. flag file for individuals/samples
	Rscript {libdir}/inferped_FuckupDetectorAndSolver.R \
	    $pedPrunedTrunk.fam \
	    {input.ped_pruned_pihat} \
	    {input.ped_sexcheck} \
	    {params.inferbad} \
	    {params.inferfam} \
	    {params.resdir}/inferped_data.RData \
	    {output.Rfixed_fam} \
	    {output.pheno_ok_flags}

	# # produce bedset with ALL markers and INFERRED family info
       	cp $inAllTrunk.bed     $outAllTrunk.bed
       	cp $inAllTrunk.bim     $outAllTrunk.bim
	cp {output.Rfixed_fam} $outAllTrunk.fam

	# produce/modify bedset with PRUNED (pruned) markers by replacing earlier .fam file with fixed one
	# (inferped_pruned.bed and .bim were made by previous rule)
       	cp $pedPrunedTrunk.bed $outPrunedTrunk.bed
       	cp $pedPrunedTrunk.bim $outPrunedTrunk.bim
        cp {output.Rfixed_fam} $outPrunedTrunk.fam

        """

rule document_pedigree_fu_detector_solver:
    input:
        in_all = mqc.plinkBase(rules.pedigree_fu_detector_solver.input.in_all[0]) + ".fam",
        out_all = mqc.plinkBase(rules.pedigree_fu_detector_solver.output.inferped_all[0]) + ".fam",
        in_pruned = mqc.plinkBase(rules.pedigree_fu_detector_solver.input.ped_pruned[0]) + ".fam",
        out_pruned = mqc.plinkBase(rules.pedigree_fu_detector_solver.output.inferped_pruned[0]) + ".fam",
    output:
        results_all = report((resultPath/"pedigree_fu_detector_solver_all").with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"pedigree_fu_detector_solver_all").with_suffix(".rst")),
        results_pruned = report((resultPath/"pedigree_fu_detector_solver_pruned").with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"pedigree_fu_detector_solver_pruned").with_suffix(".rst")),
    run:
        mqc.log(runlog, rule_info[rule]["QC test"])

        dropouts = mqc.checkUpdates(input.in_all, input.out_all,cols = [0,1],
                                    sanityCheck = "update", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        mqc.saveYamlResults(output.results_all, dropouts)

        dropouts = mqc.checkUpdates(input.in_pruned, input.out_pruned,cols = [0,1],
                                    sanityCheck = "update", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule

        mqc.saveYamlResults(output.results_pruned, dropouts)

# Part of the earlier rule pcawhapmap:
rule_stem = "pedigree_fix_pruned"
rule pedigree_fix_pruned:
    input:
        bedset = rules.pedigree_fu_detector_solver.output.inferped_pruned,
    output:
        bedset = expand(str(tmpMod2/rule_stem) + '{ext}', ext=['.bed','.bim','.fam']),
        problems = (tmpMod2/rule_stem).with_suffix(".prblm"),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                    category="Module 2 Core samples and infere pedigree",
                    caption=(resultPath/rule_stem).with_suffix(".rst")),
    benchmark:
        (tmpMod2/rule_stem).with_suffix(".benchmark")

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        # During fu_detector, we left trace about problematic triads naming the families *prblm
        mqc.egrep('prblm', inTrunk+".fam", output.problems)  

        subprocess.run([plinklocal,
                "--bfile", inTrunk,
                "--remove", output.problems,
                "--out", outTrunk, "--make-bed"  ], check=True)  # used to be called no_inferped_problems
        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",cols = [0,1],
                                    sanityCheck = "remove", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

# Reduce 1000 genome markers to the one already pruned and sorted out for moba
rule_stem = 'common_markers_moba_ref'
rule common_markers_moba_ref:
    input:
        bedset_ref = expand(config["1000_genomes_stem"] +'{ext}', ext=['.bed','.bim','.fam']),
        bedset_moba = rules.pedigree_fix_pruned.output.bedset
    output:
        bedset_ref = expand(str(tmpMod2/"pca_ref") + '{ext}', ext=['.bed','.bim','.fam']),
        bedset_moba = expand(str(tmpMod2/"pca_moba") + '{ext}', ext=['.bed','.bim','.fam']),
        marker_list = (tmpMod2/rule_stem).with_suffix(".txt"),
        tri_alleles = report((tmpMod2/rule_stem).with_suffix(".missnp"),
                             category="Module 2 1000Genomes prep",
                             caption=(resultPath/"pca_ref").with_suffix(".rst")),
        results_ref = report((resultPath/"pca_ref").with_suffix(".yaml"),
                             category="Module 2 1000Genomes prep",
                             caption=(resultPath/"pca_ref").with_suffix(".rst")),
        results_moba = report((resultPath/"pca_moba").with_suffix(".yaml"),
                              category="Module 2 1000Genomes prep",
                              caption=(resultPath/"pca_moba").with_suffix(".rst")),
    benchmark:
        (tmpMod2/rule_stem).with_suffix(".benchmark")

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk_ref =  mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba =  mqc.plinkBase(input.bedset_moba[0])
        outTrunk_ref =  mqc.plinkBase(output.bedset_ref[0])
        outTrunk_moba =  mqc.plinkBase(output.bedset_moba[0])
        triallelesTrunk =  mqc.plinkBase(output.tri_alleles)

        # Common markers found in marker_list
        mqc.intersect_rsid(inTrunk_moba+".bim", inTrunk_ref+".bim",  output.marker_list)
        # Reduce both sets to the common markers
        subprocess.run([plinklocal,
                "--bfile", inTrunk_ref,
                "--extract", output.marker_list,
                "--out", outTrunk_ref,
                "--allow-extra-chr",  # such as PAR1 ...
                "--make-bed" ], check=True)
        subprocess.run([plinklocal,
                "--bfile", inTrunk_moba,
                "--extract", output.marker_list,
                "--out", outTrunk_moba,
                "--make-bed" ], check=True)
        # alas these two are not identical enough -
        # discover tri-allele  problems by dummy-merging
        # Note that we dont want to abort on plink-failure (as this will be)
        subprocess.run([plinklocal,
                "--bfile", outTrunk_ref,
                "--bmerge", outTrunk_moba,
                        "--out", triallelesTrunk ], check=False)
        # ... And then remove these markers from both sets
        # fyi: plink will append inputfiles  by ~ ... since input/output have same name
        subprocess.run([plinklocal,
                "--bfile", outTrunk_ref,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_ref,
                "--make-bed" ], check=True)

        subprocess.run([plinklocal,
                "--bfile", outTrunk_moba,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_moba,
                "--make-bed" ], check=True)

        # Document the reduction for ref (1000 genomes)
        dropouts = mqc.checkUpdates(inTrunk_ref+".bim", outTrunk_ref+".bim",cols = [0,1],
                                    sanityCheck = "removal", fullList = False)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Excluded markers"] = f"Common markers in {output.marker_list}, trialleles removed in {output.tri_alleles}"
        mqc.saveYamlResults(output.results_ref, dropouts)

        # Document the reduction for moba
        dropouts = mqc.checkUpdates(inTrunk_moba+".bim", outTrunk_moba+".bim",cols = [0,1],
                                    sanityCheck = "removal", fullList = False)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Excluded markers"] = f"Common markers in {output.marker_list}, trialleles removed in {output.tri_alleles}"
        mqc.saveYamlResults(output.results_moba, dropouts)

# 7.1.2020 projecting moba data on this did not work. For now we merge the data.
# rule_stem = "pca_1kgp"
# rule pca_1kgp:
#     input:
#         bedset = rules.common_markers_moba_ref.output.bedset_ref,
#     output:
#         ref_pcs=tmpMod2/rule_stem/'pcs_1kgp',
#         ref_eigenvec=tmpMod2/rule_stem/'eigenvec_1kgp',
#         ref_loadings=tmpMod2/rule_stem/'loadings_1kgp',
#         ref_eigenval=tmpMod2/rule_stem/'eigenval_1kgp',
#         ref_var_explained=tmpMod2/rule_stem/'var_explained_1kgp',
#         ref_meansd=tmpMod2/rule_stem/'meansd_1kgp',
#     run:
#         item_type = rule_info[rule]["rule type"]
#         mqc.log(runlog, rule_info[rule]["QC test"])
#         inTrunk =  mqc.plinkBase(input.bedset[0])

#         subprocess.run([flashpca,
#                         "--bfile", inTrunk,
#                         "--outpc", output.ref_pcs,
#                         "--outmeansd", output.ref_meansd,
#                         "--outload", output.ref_loadings,
#                         "--outvec",  output.ref_eigenvec,
#                         "--outval", output.ref_eigenval,
#                         "--outpve", output.ref_var_explained ])

# This projection does not work (7.1.2020). Must look at this laters
# instead we run one single pca on a merged file, see pca_both below
# rule_stem = "pca_moba"
# rule pca_moba:
#     input:
#         bedset = rules.common_markers_moba_ref.output.bedset_moba,
#         ref_meansd = rules.pca_1kgp.output.ref_meansd,    # projected onto pca from ...
#         ref_loadings = rules.pca_1kgp.output.ref_loadings,# ... 1000 genomes pca
#     output:
#         moba_projection=tmpMod2/rule_stem/'projection_moba',
# # plot?        ref_meansd=tresultPath/rule_stem).with_suffix(".yaml"),
# #                         category="Module 2 1000Genomes prep",
# #                         caption=(resultPath/rule_stem).with_suffix(".rst"))

#     run:
#         item_type = rule_info[rule]["rule type"]
#         mqc.log(runlog, rule_info[rule]["QC test"])
#         inTrunk =  mqc.plinkBase(input.bedset[0])

#         # --project moba data onto 1000 genomes loading
#         subprocess.run([flashpca,
#                         "--bfile", inTrunk,
#                         "--project",
#                         "--inmeansd", input.ref_meansd,
#                         "--outproj", output.moba_projection,
#                         "--inload", input.ref_loadings,
#                         check=True])

# plots a projection, does not work well 7.1.2020 Delete or fix later, see plot_pca_both below
# Note that on https://github.com/gabraham/flashpca/blob/master/README.md it says to use
# plink --reference-allele , but that is a plink2 command
# rule_stem = "plot_pca"
# rule plot_pca:
#     input:
#         pop_map = config["1000_genomes_pop"],       # maps samples to population-groups
#         ref_pcs = rules.pca_1kgp.output.ref_pcs,
#         moba_pcs = rules.pca_moba.output.moba_projection,

#     output:
#         plot = report((resultPath/rule_stem).with_suffix(".png"),
#                       category="Module 2 1000Genomes prep")

#     run:
#         # To remove when this goes to mobaQcTools
#         import pandas as pd
#         import plotnine as p9
#         import matplotlib
#         matplotlib.use('Agg')

#         pc = pd.read_csv(input.ref_pcs, usecols=['IID','PC1','PC2'],delim_whitespace=True)
#         moba = pd.read_csv(input.moba_pcs, usecols=['IID','PC1','PC2'],delim_whitespace=True)
#         # All data. We here later assume that moba ID and 1000 genomes ID are different
#         all = pd.concat([pc,moba],ignore_index=True)

#         # Populations for colouring -
#         # see https://www.internationalgenome.org/faq/which-populations-are-part-your-study/ for details
#         pop = pd.read_csv(input.pop_map,usecols=['#IID','SuperPop','Population'],delim_whitespace=True)
#         # Simulate population for Moba
#         popmoba = pd.read_csv(input.moba_pcs,usecols=['IID'],delim_whitespace=True)
#         popmoba.columns = ["#IID"]  # rename to match earlier pop
#         popmoba['SuperPop'] = '->MoBa'
#         popmoba['Population'] = '->MoBa'
#         all_pop = pd.concat([pop,popmoba],ignore_index=True)
#         merged = pd.merge(left=all, right=all_pop, left_on='IID', right_on='#IID')
#         print(merged)


#         # Set up colours
#         # colours = {'EUR': 'red',
#         #            'EAS': 'darkblue',
#         #            'AMR': 'violet',
#         #            'SAS': 'orange',
#         #            'AFR': 'yellow',
#         #            'Moba':'black'}
#         popc = "SuperPop"
#         p = p9.ggplot(data=merged, mapping=p9.aes(x='PC1',y='PC2',color=popc, shape=popc))
#         looks = p9.aes(color=popc, shape=popc)
#         p +=  p9.geom_point()
#         p += p9.scale_colour_brewer(type="qual", palette="Set1")  # better for colourblind
#         p9.ggsave(plot=p, filename=output.plot, dpi=600)

rule_stem = "pca_both"
rule pca_both:
    input:
        bedset_ref = rules.common_markers_moba_ref.output.bedset_ref,
        bedset_moba = rules.common_markers_moba_ref.output.bedset_moba,
    output:
        bedset = expand(str(tmpMod2/rule_stem) + '{ext}', ext=['.bed','.bim','.fam']),
        pcs=tmpMod2/(rule_stem+".pcs"),
    benchmark:
        (tmpMod2/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk_ref =  mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba =  mqc.plinkBase(input.bedset_moba[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run([plinklocal,
                        "--bfile", inTrunk_ref,
                        "--bmerge", inTrunk_moba,
                        "--out", outTrunk,
                        "--make-bed"    ], check=True)

        subprocess.run([flashpca,
                        "--bfile", outTrunk,
                        "--outpc", output.pcs,
                        ], check=True)




rule_stem = "plot_pca_both"
rule plot_pca_both:
    input:
        pop_map = config["1000_genomes_pop"],       # maps samples to population-groups
        pcs = rules.pca_both.output.pcs,            # principal components
        moba = mqc.plinkBase(rules.common_markers_moba_ref.output.bedset_moba[0]) + ".fam"

    output:
        plot = report((resultPath/rule_stem).with_suffix(".png"),
                      category="Module 2 Core samples and infere pedigree",
                      caption=(resultPath/rule_stem).with_suffix(".rst"))
    # force this url into the report
    params: "Legend on https://www.internationalgenome.org/faq/which-populations-are-part-your-study/"
    benchmark:
        (tmpMod2/rule_stem).with_suffix(".benchmark")
    run:
        # To remove when this goes to mobaQcTools
        pc = pd.read_csv(input.pcs, usecols=['IID','PC1','PC2'], delim_whitespace=True)
        # Populations for colouring -
        pop = pd.read_csv(input.pop_map,usecols=['#IID','SuperPop','Population'],delim_whitespace=True)
        # Simulate population for Moba, read 2-column in fam-file
        popmoba = pd.read_csv(input.moba,usecols=[1], header=None,
                              delim_whitespace=True)
        popmoba.columns = ["#IID"]  # rename to match earlier pop
        moba_legend = '->MoBa'
        popmoba['SuperPop'] = moba_legend
        popmoba['Population'] = moba_legend
        all_pop = pd.concat([pop,popmoba],ignore_index=True)
        merged = pd.merge(left=pc, right=all_pop, left_on='IID', right_on='#IID')
        # does not work for now:  mqc.find_moba_pca_outlier(merged[merged.Population=='->MoBa'].co
        # Explode Europe to Countries in Population
        merged.loc[merged['SuperPop'] == 'EUR', 'SuperPop'] = 'EUR_'+merged['Population']
        legend_info = params[0]
        # Set up colours   - not using this - did not get it right and dont want to spend time on it
        # colours = {'EUR': 'red',
        #            'EAS': 'darkblue',
        #            'AMR': 'violet',
        #            'SAS': 'orange',
        #            'AFR': 'yellow',
        #            'Moba':'black'}
        popc = "SuperPop"
        # Visualize what will be excluded
        print("SUPERDIRTY PCA EXCLUSION!!!! (visualization for now ...)")
        # rename moba-samples above cut-off
        merged.loc[
            (merged["PC1"]>rules.extract_pca_outliers.params.treshold) &
            (merged[popc]==moba_legend), popc]  +=  "(outlier)"
        p = p9.ggplot(data=merged, mapping=p9.aes(x='PC1',y='PC2',color=popc, shape=popc))
        p +=  p9.geom_point()
        p += p9.scale_colour_brewer(type="qual", palette="Set1")  # better for colourblind
        p9.ggsave(plot=p, filename=output.plot, dpi=600)
        # create the caption usually made by saveYamlResults
        with open(str(resultPath/rule)+".rst", 'w') as file:
            file.write(f'Rule {rule_info[rule]["Rule order"]} ({rule_info[rule]["rule action"]})\n')
            file.write(f"{legend_info}\n")

rule_stem = 'extracted_pca_outliers'
rule extract_pca_outliers:
    input:
        bedset = rules.common_markers_moba_ref.output.bedset_moba,
        pcs = rules.pca_both.output.pcs,            # principal components
        moba = rules.plot_pca_both.input.moba,      # moba samples
    output:
        bedset=expand(str(tmpMod2/rule_stem)
                          + '{ext}', ext=['.bed','.bim','.fam']),
        exclude_list = (tmpMod2/rule_stem).with_suffix(".txt"),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    params:
        treshold = -0.05752391   # Stupid and visual - for now
    benchmark:
        (tmpMod2/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        mqc.log(runlog, "PCA exlude {item_type} ({params.treshold})\n")

        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        pca_treshold = params.treshold
        pc = pd.read_csv(input.pcs, usecols=['IID','PC1','PC2'],delim_whitespace=True)
        # List (only) moba samples that pca-wise are too spread
        mobasamples = pd.read_csv(input.moba,usecols=[0,1], header=None,
                                  delim_whitespace=True)
        mobasamples.columns = ["FID","IID"]
        # keep just moba-samples
        moba_pca = pd.merge(left=pc, right=mobasamples, left_on='IID', right_on='IID')

        # This is a superdirty hack to exclude the same number of samples as
        # was excluded by the hapmap pca. Must be replace by a sensible function
        # Samples to exclude found put in output.excludelist
        print("SUPERDIRTY PCA EXCLUSION!!!!")
        moba_pca.loc[(moba_pca.PC1 > params.treshold)].to_csv(output.exclude_list,
                columns=['FID','IID'],index=False, header=False, sep = ' ')

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--remove", output.exclude_list,
                "--out", outTrunk,
                "--make-bed" ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",cols = [0,1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

rule_stem = "extracted_pca_samples_from_full_markerset"
rule extract_pca_samples_from_full_markerset:
    input:
        samples = rules.extract_pca_outliers.output.bedset,
        markers = rules.pedigree_fu_detector_solver.output.inferped_all,
    output:
        bedset=expand(str(tmpMod2/rule_stem)
                          + '{ext}', ext=['.bed','.bim','.fam']),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))

    benchmark:
        (tmpMod2/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        mqc.log(runlog, "PCA exlude {item_type} ({params.treshold})\n")

        inTrunk =  mqc.plinkBase(input.markers[0])
        outTrunk = mqc.plinkBase(output.bedset[0])
        sample_list = mqc.plinkBase(input.samples[0]) + ".fam"
        print (f"using {inTrunk} to make {outTrunk} using {sample_list}")
        subprocess.run([plinklocal,
                "--bfile", inTrunk,
                "--keep", sample_list,
                "--out", outTrunk,
                "--make-bed" ], check=True)
        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",cols = [0,1],
                                    sanityCheck = "removal", fullList = True)

        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)


rule_stem = "split"
rule split_founder_offspring:
    input:
        bedset = rules.extract_pca_samples_from_full_markerset.output.bedset
    output:  # bedsets earlier called starting_clean , will be picked up again later
             # note that start_clean is hardcoded here and in core_missingness
        bedset_founders =expand(str(tmpMod2/"founders"/"start_clean") + '{ext}', ext=['.bed','.bim','.fam']),
        bedset_offspring =expand(str(tmpMod2/"offspring"/"start_clean") + '{ext}', ext=['.bed','.bim','.fam']),
        results_founders = report(str(resultPath/rule_stem)+"_founders.yaml",
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+"_founders.rst"),
        results_offspring = report(str(resultPath/rule_stem)+"_offspring.yaml",
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+"_offspring.rst")
    benchmark:
        (tmpMod2/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset[0])
        foundersTrunk =  mqc.plinkBase(output.bedset_founders[0])
        offspringTrunk =  mqc.plinkBase(output.bedset_offspring[0])

        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--filter-founders",
                        "--out", foundersTrunk,
                        "--make-bed"  ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam", foundersTrunk+".fam",cols = [1], sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results_founders, dropouts)

        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--filter-nonfounders",
                        "--make-founders",
                        "--out", offspringTrunk,
                        "--make-bed"  ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam", offspringTrunk+".fam", cols=[1], sanityCheck="removal", fullList=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results_offspring, dropouts)

rule_stem = "ibd_prep"
rule ibd_prep:  # code is more or less copied to core_ibd_prep
    threads: 2
    input:
        bedset = tmpMod2/"{role}/start_clean.bed",
        clean_snps = rules.prune_markers.output.exclude_list
    output:
        genome = (tmpMod2/"{role}"/rule_stem).with_suffix(".genome"),
        ibd_reduced_genome = tmpMod2/"{role}"/"ibd_reduced.genome",   #input for R laters, 3 columns of genome file
        preplot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),

    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.genome)

        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--extract", input.clean_snps,
                        "--genome",
                        "--out", outTrunk ], check=True)
        # create a plot for this - corresponds to the old draw-pihat-plots.R
        p = mqc.dotplot(output.genome,prec=3, x='Z0',y='Z1', c='RT')
        p9.ggsave(plot=p, filename=output.preplot, dpi=600)
        df = pd.read_csv(output.genome, delim_whitespace=True,
            usecols=["IID1", "IID2", "PI_HAT"] )
        df.to_csv(output.ibd_reduced_genome, index=False, sep=" ")
        mqc.make_rule_caption(rule, resultPath)

rule_stem = "ibd_exclusion"
rule ibd_exclusion:  # code is more or less copied to core_ibd_exclusion
    threads: 2
    input:
        bed = rules.ibd_prep.input.bedset,
        ibd_reduced_genome = rules.ibd_prep.output.ibd_reduced_genome
    output:
        exclusion = (tmpMod2/"{role}"/rule_stem).with_suffix(".txt"),
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
    params:
        pihat_thr = str(config["ibd_pihat_thr"]),
        hard_thr = str(config["ibd_hard_thr"])
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bed)  # bed is not a .fam file, we need it
        famFile = inTrunk + ".fam"
        outTrunk =  mqc.plinkBase(output.bedset)
        plotdir = os.path.dirname(output.plot)

        # for now, the below is not ported and lives it's own life
        subprocess.run(["Rscript",
                    f"{libdir}/accumPIHAT.R",
                    input.ibd_reduced_genome,
                    famFile,
                    output.exclusion,
                    plotdir,
                    params.pihat_thr,
                    params.hard_thr,
                    rule], check=True)   # a little dirty, but the R rutine wants a filename that it will add .png, .pdf .txt2
        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--remove", output.exclusion,
                        "--make-bed",
                        "--out", outTrunk ], check=True)
        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",cols = [1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'ibd_prune'
rule ibd_prune: # code is more or less copied to core_ibd_prune
    threads: 2
    input:
        bedset = rules.ibd_exclusion.output.bedset,
        genome = rules.ibd_prep.output.genome
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
        # in addition to the removal list, a removal.samples.txt is produced, sporting only the sample-list
        removal= (tmpMod2/"{role}"/rule_stem).with_suffix(".txt"),
        removal_samples = (tmpMod2/"{role}"/rule_stem).with_suffix(".samples.txt"),
    params:
        treshold = config['ibd_straight_thr']
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)
        # identify samples forremoval due to high PI_HAT
        (removed,total) = mqc.extract_list(input.genome,
                output.removal_samples, output.removal,
                colName="PI_HAT", sep=None, condition=">", treshold=params.treshold,
                key_cols=[0,1], doc_cols=[0,1] )

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--remove", output.removal_samples,
                "--out", outTrunk ,
                "--make-bed"], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",cols = [0,1], sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'geno_rates_mind3' # last iteration - keep <= 9 or fix code below
rule geno_rates_mind3:         # part of earlier markerclean
    # This rule is poorly documented in the html-report, should have made 6 result files
    threads: 2
    input:
        bedset = rules.ibd_prune.output.bedset,
    output:
        # Result for every iteration, below is only the last
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
        plots = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
    params:
        #3 cycles of mind/geno removal
        geno1 = config["geno_rate.geno1"],
        mind1 = config["geno_rate.mind1"],
        geno2 = config["geno_rate.geno2"],
        mind2 = config["geno_rate.mind2"],
        geno3 = config["geno_rate.geno3"],
        mind3 = config["geno_rate.mind3"]
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        out_dir = Path(output.bedset).parent    # Directory according to output.bedset
        res_dir = Path(output.results).parent   # and corresponding for results
        lastTrunk = inTrunk
        ruleTrunk = "geno_rates"  # will be appended by the stages
        # Iterate 3 times, greating a chain of geno1->mind1->geno2->mind2 etc files
        # We might have just as well off with cut'n paste here - the code is somewhat
        # hard to read -
        for i in [1,2,3]:      # last number must max must match rule all:
            mqc.log(runlog, f'{rule_info[rule]["QC test"]}: Iteration {i}')
            print(f'{rule_info[rule]["QC test"]}: Iteration {i}')
            file_name= ruleTrunk + "_geno" + str(i)
            outTrunk =  str(out_dir/file_name)
            res_file =  str(res_dir/file_name)+".yaml"
            plot_file =  str(res_dir/file_name)+".png"
            # Plink for both marker and samples, slightly different names for the params
            mqc.missing_genotype_rate(rule, lastTrunk, outTrunk, sample=False,
                                 treshold=getattr(params,f"geno{i}"),
                                      result_file=res_file,
                                      plot_file=plot_file)

            lastTrunk = outTrunk
            file_name= ruleTrunk + "_mind" + str(i)
            outTrunk =  str(out_dir/file_name)
            res_file =  str(res_dir/file_name)+".yaml"
            plot_file =  str(res_dir/file_name)+".png"
            mqc.missing_genotype_rate(rule, lastTrunk, outTrunk, sample=True,
                        treshold=getattr(params,f"mind{i}"),
                        result_file=res_file,
                        plot_file=plot_file)

            lastTrunk = outTrunk
        # create a common caption
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'hwe_autos_geno' # called clean_marker previously
rule hwe_autos_geno:        # part of earlier markerclean
    threads: 2
    input:
        bedset = rules.geno_rates_mind3.output.bedset,
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),  # called clean_autosomes before
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
    params:
        #2 cycles hwe/maf + a geno
        hwe1 = config["hwe1"],
        maf1 = config["maf1"],
        sd_het1 = config["sd_het1"],
        hwe2 = config["hwe2"],
        maf2 = config["maf2"],
        sd_het2 = config["sd_het2"],
        geno_rare = config["geno_rare"]
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        out_dir = Path(output.bedset).parent    # Directory according to output.bedset
        res_dir = Path(output.results).parent   # and corresponding for results
        lastTrunk = inTrunk
        # Iterate 2 times, greating a chain of geno1->mind1->geno2->mind2 etc files
        # We might have just as well off with cut'n paste here - the code is somewhat
        # hard to read -
        autosomal = "common"
        for i in [1,2]:    # common_het logic not suited for more than 2 iterations
            file_name= rule + "_hwe" + str(i)
            outTrunk =  str(out_dir/file_name)
            res_file =  str(res_dir/file_name)+".yaml"
            plot_file =  str(res_dir/file_name)+".png"
            # Filters and plot
            mqc.low_hwe_rate(rule, lastTrunk, outTrunk,
                            treshold=getattr(params,f"hwe{i}"),
                            hwe_switches = ["--autosome", "--hardy", "midp"],
                            result_file=res_file,
                            plot_file=plot_file)


            lastTrunk = outTrunk
            file_name= rule + "_het" + str(i)
            outTrunk =  str(out_dir/file_name)
            res_file =  str(res_dir/file_name)+".yaml"
            plot_file =  str(res_dir/file_name)+".png"
            mqc.excess_het(rule, autosomal, lastTrunk, outTrunk,
                            treshold=getattr(params,f"maf{i}"),
                            sd=getattr(params,f"sd_het{i}"),
                            result_file=res_file,
                            plot_file=plot_file)
            # dirty, but with only two iterations this works ...
            autosomal = "rare"
            lastTrunk = outTrunk

        # a last round of marker removal
        outTrunk =  mqc.plinkBase(output.bedset)
        mqc.missing_genotype_rate(rule, lastTrunk, outTrunk, sample=False,
                        treshold=params.geno_rare,
                        result_file=output.results,
                        plot_file=output.plot)
        # and set a common caption
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'sex_check'
rule sex_check:
    threads: 2
    input:
        bedset = rules.hwe_autos_geno.output.bedset,
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),  # called removed_failing_sexcheck
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        # in addition to the removal list, a removal.samples.txt is produced, sporting only the sample-list
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),

    params:
        female_treshold = config['sex_check_female'],
        male_treshold = config['sex_check_male']
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        mqc.sex_check(rule, input.bedset, output.bedset, f_treshold=0.2, m_treshold=0.8,
                      result_file=output.results, plot_file=output.plot)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'female_xmarkers'
rule female_xmarkers:
    threads: 2
    input:
        bedset = rules.sex_check.output.bedset,
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        exclude_markers = report((tmpMod2/"{role}"/rule_stem).with_suffix(".exclude"),
                         category="Module 2 Core samples and infere pedigree",
                                 caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
    params:
        treshold = config['xmarkers_clean'],
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
 	# note 1: all samples are now marked as FOUNDERS (no need for "--nonfounders" flag)
 	# note 2: all samples have missing phenotype (no need for "include-nonctrl" flag)

        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        mqc.low_hwe_rate(rule, inTrunk, outTrunk,
                         treshold=params.treshold,
                         hwe_switches = ["--filter-females", "--chr", "23",
                                         "--hardy", "midp"],
                         result_file=output.results, plot_file=output.plot)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'par_regions'
rule par_regions:
    threads: 2
    input:
        bedset = rules.female_xmarkers.output.bedset,  # not same pipe as rot2, but ok since different chr
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        exclude_markers = report((tmpMod2/"{role}"/rule_stem).with_suffix(".exclude"),
                         category="Module 2 Core samples and infere pedigree",
                                 caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
    params:
        treshold = config['xmarkers_clean'],
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
 	# note 1: all samples are now marked as FOUNDERS (no need for "--nonfounders" flag)
 	# note 2: all samples have missing phenotype (no need for "include-nonctrl" flag)

        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        mqc.low_hwe_rate(rule, inTrunk, outTrunk,
                         treshold=params.treshold,
                         hwe_switches = ["--chr", "25",
                                         "--hardy", "midp"],
                         result_file=output.results, plot_file=output.plot)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'clean_male_x'
rule clean_male_x:
    threads: 2
    input:
        bedset = rules.par_regions.output.bedset,
        bim = (tmpMod2/"{role}"/"sex_check").with_suffix(".bim"),
        hh = (tmpMod2/"{role}"/"sex_check").with_suffix(".hh")
    output:
        exclude_markers = report((tmpMod2/"{role}"/rule_stem).with_suffix(".exclude"),
                                 category="Module 2 Core samples and infere pedigree",
                                 caption=(resultPath/rule_stem).with_suffix(".rst")),
        chr23 =  (tmpMod2/"{role}"/"sex_check").with_suffix(".bim23") # chr23 version of input.bim

    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        # outTrunk =  mqc.plinkBase(output.bedset)
        mqc.egrep('^23', input.bim, output.chr23)  # a file with only chr23 rsid in second column
        # the .hh file as multiples, so we pass it as param 1
        mqc.intersect_rsid(input.hh, output.chr23, output.exclude_markers, small_col=2, big_col=1)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'sex_clean'
rule sex_clean:
    threads: 2
    input:
        bedset = rules.hwe_autos_geno.output.bedset, # clean_autosomes earlier
        excl_failed_hwe_female_x = rules.female_xmarkers.output.exclude_markers,
        excl_failed_hwe_par_regions = rules.par_regions.output.exclude_markers,
        excl_male_x_markers = rules.clean_male_x.output.exclude_markers,
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"), # clean_markers earlier
        bedsetbim = (tmpMod2/"{role}"/rule_stem).with_suffix(".bim"), # clean_markers earlier
        exclude_markers = report((tmpMod2/"{role}"/rule_stem).with_suffix(".exclude"),
                        category="Module 2 Core samples and infere pedigree",
                        caption=(resultPath/rule_stem).with_suffix(".rst")),
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        # Make a list of all earlier fails
        subprocess.call(f'cat {input.excl_failed_hwe_female_x}'
                        f' {input.excl_failed_hwe_par_regions}'
                        f' {input.excl_male_x_markers} > {output.exclude_markers}', shell=True)

        # and remove them
        subprocess.run([plinklocal,
                        "--bfile",inTrunk,
                        "--exclude", output.exclude_markers,
                        "--out", outTrunk,
                        "--make-bed"  ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim", cols = [0,1],
                                sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'common_founders_offspring_markers'
rule common_founders_offspring_markers:
    threads: 2
    input:
        markers = expand(str(tmpMod2/'{role}')+'/sex_clean.bim', role=ROLES) # Final markerlists
    output:
        markers = (tmpMod2/rule_stem).with_suffix(".txt"),  # called shared_markers.txt before
        results = report((resultPath/rule_stem).with_suffix(".rst"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        mqc.intersect_rsid(input.markers[1], input.markers[0], output.markers, small_col=1, big_col=1)
        in1 = mqc.line_count(input.markers[0])
        in2 = mqc.line_count(input.markers[1])
        common = mqc.line_count(output.markers)

        with open(output.results, 'w') as file:
            file.write(f'Rule {rule_info[rule]["Rule order"]} ({item_type})\n\n')
            file.write(f'- Markers in {in1}/{in2}\n')
            file.write(f'- Common markers {common}\n')

rule_stem = 'core_missingness'
rule core_missingness:
    threads: 2
    input:
        bedset = (tmpMod2/"{role}"/"start_clean").with_suffix(".bed"), # from split_founder_offspring
        common_markers = rules.common_founders_offspring_markers.output.markers
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                      caption=(resultPath/rule_stem).with_suffix(".rst")),
    params:
        mind = config['core_mind'],
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        subprocess.run([plinklocal,
                        "--bfile",inTrunk,
                        "--extract", input.common_markers,
                        "--out", outTrunk,
                        "--make-bed"  ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim", cols = [0,1],
                                sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule + " (common markers)"
        mqc.saveYamlResults(output.results+".common", dropouts)

        mqc.missing_genotype_rate(rule, inTrunk, outTrunk, sample=True,
                        treshold=params.mind,
                        result_file=output.results,
                        plot_file=output.plot)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'core_het'
rule core_het:
    threads: 2
    input:
        bedset = rules.core_missingness.output.bedset
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),  #called core-lmm, 'related core'
        results_rare = report((resultPath/"{role}"/rule_stem).with_suffix(".rare.yaml"),
                              category="Module 2 Core samples and infere pedigree",
                              caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot_rare = report((resultPath/"{role}"/rule_stem).with_suffix(".rare.png"),
                           category="Module 2 Core samples and infere pedigree",
                           caption=(resultPath/rule_stem).with_suffix(".rst")),
        # These commin are for common autosome, a tmp result
        results_common = report((resultPath/"{role}"/rule_stem).with_suffix(".common.yaml"),
                                category="Module 2 Core samples and infere pedigree",
                                caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot_common = report((resultPath/"{role}"/rule_stem).with_suffix(".common.png"),
                             category="Module 2 Core samples and infere pedigree",
                             caption=(resultPath/rule_stem).with_suffix(".rst")),
    params:
        mind = config['core_mind'],
        maf = config['core_maf'],
        sd = config['core_sd_het'],
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        tmpTrunk = inTrunk + ".common"
        outTrunk =  mqc.plinkBase(output.bedset)
        # Filter common sample heterozygosity
        mqc.excess_het(rule, "common", inTrunk, tmpTrunk,
                       treshold=params.maf,
                       sd=params.sd,
                       result_file=output.results_common,
                       plot_file=output.plot_common)
        # ... and use results as start for rare sample heterozygosity
        mqc.excess_het(rule, "rare", tmpTrunk, outTrunk,
                       treshold=params.maf,
                       sd=params.sd,
                       result_file=output.results_rare,
                       plot_file=output.plot_rare)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = "core_ibd_prep"
rule core_ibd_prep:  # code is more or less copied from ibd_prep
    threads: 2
    input:
        bedset = rules.core_het.output.bedset,
        prunedsnps = rules.prune_markers.output.exclude_list,
    output:
        genome = (tmpMod2/"{role}"/rule_stem).with_suffix(".genome"),
        verify_ibd_reduced_genome = tmpMod2/"{role}"/"verify_ibd_reduced.genome",   #input for R laters, 3 columns of genome file
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                           category="Module 2 Core samples and infere pedigree",
                           caption=(resultPath/rule_stem).with_suffix(".rst")),
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.genome)

        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--extract", input.prunedsnps,
                        "--genome",
                        "--out", outTrunk ], check=True)
        # create a plot for this - corresponds to the old draw-pihat-plots.R
        p = mqc.dotplot(output.genome,prec=3, x='Z0',y='Z1', c='RT')
        p9.ggsave(plot=p, filename=output.plot, dpi=600)
        df = pd.read_csv(output.genome, delim_whitespace=True,
            usecols=["IID1", "IID2", "PI_HAT"] )
        df.to_csv(output.verify_ibd_reduced_genome, index=False, sep=" ")
        mqc.make_rule_caption(rule, resultPath)

rule_stem = "core_ibd_exclusion"
rule core_ibd_exclusion:  # code is more or less copied to core_ibd_exclusion
    threads: 2
    input:
        bed = rules.core_ibd_prep.input.bedset,
        ibd_reduced_genome = rules.core_ibd_prep.output.verify_ibd_reduced_genome
    output:
        exclusion = (tmpMod2/"{role}"/rule_stem).with_suffix(".txt"),
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=str(resultPath/rule_stem)+".rst"),
    params:
        pihat_thr = str(config["ibd_pihat_thr"]),
        hard_thr = str(config["ibd_hard_thr"])
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bed)  # bed is not a .fam file, we need it
        famFile = inTrunk + ".fam"
        outTrunk =  mqc.plinkBase(output.bedset)
        plotdir = os.path.dirname(output.plot)

        # for now, the below is not ported and lives it's own life
        subprocess.run(["Rscript",
                    f"{libdir}/accumPIHAT.R",
                    input.ibd_reduced_genome,
                    famFile,
                    output.exclusion,
                    plotdir,
                    params.pihat_thr,
                    params.hard_thr,
                    rule], check=True)   # a little dirty, but the R rutine wants a filename that it will add .png, .pdf .txt2
        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--remove", output.exclusion,
                        "--make-bed",
                        "--out", outTrunk ], check=True)
        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",cols = [1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'core_ibd_prune'
rule core_ibd_prune: # code is more or less copied from ibd_prune
    threads: 2
    input:
        bedset = rules.core_ibd_exclusion.output.bedset,
        genome = rules.core_ibd_prep.output.genome
    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),  #called core_supreme earlier
        results = report((resultPath/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        # in addition to the removal list, a removal.samples.txt is produced, sporting only the sample-list
        removal= (tmpMod2/"{role}"/rule_stem).with_suffix(".txt"),
        removal_samples = (tmpMod2/"{role}"/rule_stem).with_suffix(".samples.txt"),
    params:
        treshold = config['ibd_straight_thr']
    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)
        # identify samples forremoval due to high PI_HAT
        (removed,total) = mqc.extract_list(input.genome,
                output.removal_samples, output.removal,
                colName="PI_HAT", sep=None, condition=">", treshold=params.treshold,
                key_cols=[0,1], doc_cols=[0,1] )

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--remove", output.removal_samples,
                "--out", outTrunk ,
                "--make-bed"], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",cols = [0,1], sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = "core_pca"
rule core_pca:
    threads: 2
    input:
        bedset = rules.core_ibd_prune.output.bedset,
        prunedsnps = rules.prune_markers.output.exclude_list, # markers for pca on, found way back

    output:
        bedset = (tmpMod2/"{role}"/rule_stem).with_suffix(".bed"),  #called pcadir/pruned before
        pcs = (tmpMod2/"{role}"/rule_stem).with_suffix(".pcs"),
        plot = report((resultPath/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),



    benchmark:
        (tmpMod2/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--extract", input.prunedsnps,
                        "--out", outTrunk,
                        "--make-bed"    ], check=True)

        subprocess.run([flashpca,
                        "--bfile", outTrunk,
                        "--outpc", output.pcs,
                        ], check=True)
        # Skipping the "PLINK covariate files with PCs only" until I see the need
        pc = pd.read_csv(output.pcs, usecols=['IID','PC1','PC2'],delim_whitespace=True)
        p = p9.ggplot(data=pc, mapping=p9.aes(x='PC1',y='PC2'))
        p +=  p9.geom_point()
        p9.ggsave(plot=p, filename=output.plot, dpi=600)
        # create the caption usually made by saveYamlResults. It will be made twice (offspring/founders)
        mqc.make_rule_caption(rule, resultPath)
        # Skipping screeplot for now

