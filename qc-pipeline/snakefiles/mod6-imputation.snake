rule_stem = "mod6_split_into_chromosomes"
rule mod6_split_into_chromosomes:
    input:
        bedset = rules.mod5_output.output.bedset
    output:
        bedset = multiext(str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_split_into_chromosomes.chr{chr}"), ".bed", ".bim", ".fam")
    run:
        try:
            inTrunk = mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--chr", wildcards.chr,
                    "--make-bed",
                    "--out", outTrunk
                ]
            )
        except Exception as e:
            print(f"An exception occurred in rule {rule_stem}.")
            print(e)

rule_stem = "mod6_create_vcf"
rule mod6_create_vcf:
    input:
        bedset = rules.mod6_split_into_chromosomes.output.bedset
    output:
        vcf = str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_create_vcf.chr{chr}.vcf")
    run:
        try:
            inTrunk = mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.vcf)
            bim = input.bedset[1]
            cmd = f"{plink2local} --bfile {inTrunk} --recode vcf-iid --ref-allele {bim} 5 2 --out {outTrunk}"
            subprocess.run(cmd, shell = True)
        except Exception as e:
            print(f"An exception occurred in rule {rule_stem}.")
            print(e)

rule_stem = "mod6_sort"
rule mod6_sort:
    input:
        vcf = rules.mod6_create_vcf.output.vcf
    output:
        sorted_vcf = str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_sort.chr{chr}.sorted.vcf")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        "bcftools sort {input.vcf} -o {output.sorted_vcf}"

rule mod6_conform:
    input:
        sorted_vcf = rules.mod6_sort.output.sorted_vcf
    output:
        conformed_vcf = str(tmpMod6 / "{batch}" /  "{number_of_samples}_samples" / "mod6_conform.chr{chr}.conformed.vcf.gz")
    threads: config["mod6conform_threads"]
    shell:
        """
        echo running mod6_conform for chr {wildcards.chr}
        reffile=$(echo {hrc_ega}/EGA*/HRC.r1-1.EGA.GRCh37.chr{wildcards.chr}.haplotypes*.vcf.gz)
        output_full={output.conformed_vcf}
        outTrunk="${{output_full%.vcf.gz}}"
        java -Xmx{config[mod6conform_mem]} -jar {conform_gt} gt={input.sorted_vcf} ref=$reffile out=$outTrunk chrom={wildcards.chr} match=POS
        """

rule_stem = "mod6_impute"
rule mod6_impute:
    input:
        conformed_vcf = rules.mod6_conform.output.conformed_vcf
    output:
        imputed_vcf = str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_impute.chr{chr}.imputed.vcf.gz")
    conda:
        "envs/bcf_tabix.yaml"
    threads: config["mod6impute_threads"]
    shell:
        """
        reffile=$(echo {hrc_ega}/EGA*/HRC.r1-1.EGA.GRCh37.chr{wildcards.chr}.haplotypes*.vcf.gz)
        mapfile={mapfiles}/plink.chr{wildcards.chr}.GRCh37.map
        output_full={output.imputed_vcf}
        outTrunk="${{output_full%.vcf.gz}}"
        java -Xmx{config[mem]} -jar {beagle} gt={input.conformed_vcf} ref=$reffile impute=true out=$outTrunk chrom={wildcards.chr} nthreads={config[beagle_threads]} seed=12345 map=$mapfile
        tabix -p vcf {output.imputed_vcf}
        bcftools query -f '%POS %REF %ALT %DR2 %AF\n' {output.imputed_vcf} -o ${{outTrunk}}.info
        """

chrs = chrs_debug
def get_vcf_chr_files_for_batch(wildcards):
    tmpMod6str = str(tmpMod6)
    return [f"{tmpMod6str}/{wildcards.batch}/{n_samples}_samples/mod6_impute.chr{chr}.imputed.vcf.gz" for chr in chrs]

rule mod6_merge_chrs:
    input:
        imputed_vcfs = get_vcf_chr_files_for_batch
    output:
        merged_vcf = str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_merge_chrs.vcf.gz")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        bcftools concat {input.imputed_vcfs} -o {output.merged_vcf}
        """
rule mod6_sort_and_index:
    input:
        merged_vcf = rules.mod6_merge_chrs.output.merged_vcf
    output:
        sorted_vcf = str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_sorted.vcf.gz")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        bcftools sort {input.merged_vcf} -o {output.sorted_vcf} --write-index
        """




# rule mod6_norm:
#     input:
#         imputed_vcf = rules.mod6_impute.output.imputed_vcf
#     output:
#         normalized_vcf = str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_norm.chr{chr}.imputed.vcf.gz")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         bcftools norm -m + {input.imputed_vcf} -o {output.normalized_vcf}
#         """

# rule mod6_convert_to_pgen:
#     input:
#         normalized_vcf = rules.mod6_norm.output.normalized_vcf
#     output:
#         pgenset = multiext(str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_output.chr{chr}"), ".pgen", ".pvar", ".psam")
#     shell:
#         """
#         output_full={output.pgenset[0]}
#         outTrunk="${{output_full%.pgen}}"
#         {plink2local} --vcf {input.normalized_vcf} --make-pgen --out $outTrunk
#         """

# chrs = chrs_debug
# def get_pgen_chr_files_for_batch(wildcards):
#     tmpMod6str = str(tmpMod6)
#     return [f"{tmpMod6str}/{wildcards.batch}/{n_samples}_samples/mod6_output.chr{chr}.pgen" for chr in chrs]
# rule mod6_output:
#     input:
#         pgens = get_pgen_chr_files_for_batch,
#         original_psam = rules.mod5_output.output.psam
#     output:
#         pgenset = multiext(str(tmpMod6 / "{batch}" / "{number_of_samples}_samples" / "mod6_output"), ".pgen", ".pvar", ".psam")
#     run:
#         out_trunk = mqc.plinkBase(output.pgenset[0])
#         # merge chromosomes:
#         mqc.merge_pgensets(input.pgens, out_trunk, plink2local)
#         # add source ID to .psam and restore family information:
#         psam_file = input.original_psam
#         df = pd.read_csv(psam_file, delim_whitespace=True, dtype={'SEX': 'str'})
#         df["SEX"] = df["SEX"].fillna(0)
#         df.insert(2, "SID", wildcards.batch)
#         df.to_csv(output.pgenset[2], sep='\t', index=False)

    