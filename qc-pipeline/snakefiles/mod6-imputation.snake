tmpMod5str = str(tmpMod5)
def get_all_mod5_output_fam_files(wildcards):
    return [f"{tmpMod5str}/{batch}/mod5_output.fam" for batch in batches]

def get_all_mod5_output_bim_files(wildcards):
    return [f"{tmpMod5str}/{batch}/mod5_output.bim" for batch in batches]

rule mod6_extend_count_tables:
    input:
        fam_files = get_all_mod5_output_fam_files,
        bim_files = get_all_mod5_output_bim_files,
        previous_samples_table = rules.mod5_extend_count_tables.output.samples_table,
        previous_variants_table = rules.mod5_extend_count_tables.output.variants_table,
        id_mapping = config["id_mapping"]
    output:
        samples_table = resultPath / "count_tables" / "mod6_samples",
        variants_table = resultPath / "count_tables" / "mod6_variants"
    params:
        mod = "mod6"
    conda:
        "envs/r_4.2.yaml"
    shell:
        """
        Rscript utils/extend_count_tables.R \
            {input.id_mapping} \
            {input.previous_samples_table} \
            {output.samples_table} \
            {params.mod} \
            {input.fam_files}
        Rscript utils/extend_count_tables.R \
            {input.id_mapping} \
            {input.previous_variants_table} \
            {output.variants_table} \
            {params.mod} \
            {input.bim_files}
        """

def get_input_bim_file(wildcards):
    if wildcards.batch[0:-2] in batches_to_split:
        b = wildcards.batch[0:-2]
    else:
        b = wildcards.batch
    return str(tmpMod5 / b / "mod5_output.bim")


rule mod6_generate_chromosome_file:
    input:
        bim = get_input_bim_file
    output:
        chromosome_file = str(tmpMod6/"{batch}"/"chromosomes.txt")
    run:
        mqc.extract_chromosomes(input.bim, output.chromosome_file)

    

rule_stem = "mod6_split_into_chromosomes"
rule mod6_split_into_chromosomes:
    input:
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
        bedset = rules.mod5_output.output.bedset
    output:
        bedset = multiext(str(tmpMod6 / "{batch}" / "mod6_split_into_chromosomes.chr{chr}"), ".bed", ".bim", ".fam")
    run:
        try:
            inTrunk = mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])
            if mqc.chromosome_in_file(input.chromosome_file, wildcards.chr):
                subprocess.run(
                    [
                        plink2local,
                        "--bfile", inTrunk,
                        "--chr", wildcards.chr,
                        "--make-bed",
                        "--out", outTrunk
                    ]
                )
            else:
                mqc.create_empty_files(output.bedset)
        except Exception as e:
            print(f"An exception occurred in rule {rule_stem}.")
            print(e)

rule_stem = "mod6_create_vcf"
rule mod6_create_vcf:
    input:
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
        bedset = rules.mod6_split_into_chromosomes.output.bedset
    output:
        vcf = str(tmpMod6 / "{batch}" / "mod6_create_vcf.chr{chr}.vcf")
    run:
        try:
            if mqc.chromosome_in_file(input.chromosome_file, wildcards.chr):
                inTrunk = mqc.plinkBase(input.bedset[0])
                outTrunk = mqc.plinkBase(output.vcf)
                bim = input.bedset[1]
                cmd = f"{plink2local} --bfile {inTrunk} --recode vcf-iid --ref-allele {bim} 5 2 --out {outTrunk}"
                subprocess.run(cmd, shell = True)
            else:
                mqc.create_empty_files([output.vcf])
        except Exception as e:
            print(f"An exception occurred in rule {rule_stem}.")
            print(e)

rule_stem = "mod6_sort"
rule mod6_sort:
    input:
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
        vcf = rules.mod6_create_vcf.output.vcf
    output:
        sorted_vcf = str(tmpMod6 / "{batch}" / "mod6_sort.chr{chr}.sorted.vcf")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        mapfile -t chromosomes < {input.chromosome_file}
        if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
            echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_sort"
            touch {output.sorted_vcf}
        else
            bcftools sort {input.vcf} -o {output.sorted_vcf}
        fi
        """

def get_reference_chr(wildcards):
    if wildcards.chr == "PAR1":
        return "X_PAR1"
    elif wildcards.chr == "PAR2":
        return "X_PAR2"
    elif wildcards.chr == "X":
        return "X_nonPAR"
    else:
        return wildcards.chr

def get_beagle_chr(wildcards):
    if wildcards.chr == "PAR1" or wildcards.chr == "PAR2":
        return "X"
    else:
        return wildcards.chr

rule mod6_conform:
    input:
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
        sorted_vcf = rules.mod6_sort.output.sorted_vcf
    output:
        conformed_vcf = str(tmpMod6 / "{batch}" / "mod6_conform.chr{chr}.conformed.vcf.gz")
    threads: config["mod6conform_threads"]
    params:
        ref_chr=get_reference_chr,
        beagle_chr=get_beagle_chr
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        echo running mod6_conform for chr {wildcards.chr}
        mapfile -t chromosomes < {input.chromosome_file}
        if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
            echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_conform"
            touch {output.conformed_vcf}
        elif [[ {wildcards.chr} == "X" ]]; then
            echo "Bypassing conform for non-PAR X chromosome"
            bgzip -c {input.sorted_vcf} > {output.conformed_vcf}
        else
            reffile=$(echo {hrc_ega}/EGA*/HRC.r1-1.EGA.GRCh37.chr{params.ref_chr}.haplotypes*.vcf.gz)
            output_full={output.conformed_vcf}
            outTrunk="${{output_full%.vcf.gz}}"
            java -Xmx{config[mod6conform_mem]} -jar {conform_gt} gt={input.sorted_vcf} ref=$reffile out=$outTrunk chrom={params.beagle_chr} match=POS
        fi
        """
rule mod6_index_conform:
    input:
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
        vcf = rules.mod6_conform.output.conformed_vcf
    output:
        index = str(tmpMod6 / "{batch}" / "mod6_conform.chr{chr}.conformed.vcf.gz.tbi")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        mapfile -t chromosomes < {input.chromosome_file}
        if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
            echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_index_conform"
            touch {output.index}
        else
            tabix -p vcf {input.vcf}
        fi
        """

# Reshuffle batches (work in progress...)

def get_fam_per_batch():
    return [f"{tmpMod2}/{batch}/m2_output.fam" for batch in batches]

rule mod6_batch_table:
    'Create a table listing the batch for each sample.'
    input:
        batch_fam = get_fam_per_batch()
    output:
        batch_table = str(tmpMod6_phasing_test / "mod6_batch_table")
    run:
        try:
            id_to_batch_dfs = []
            for batch in batches:
                print(f"Importing fam for batch {batch}.")
                file = f"{tmpMod2}/{batch}/m2_output.fam"
                fam = pd.read_table(file, sep = " ", names =["fid", "iid", "mid", "pid", "sex", "pheno"])
                fam['batch'] = batch
                id_to_batch = fam[['iid', 'batch']]
                id_to_batch_dfs.append(id_to_batch)

            merged_df = pd.concat(id_to_batch_dfs, ignore_index = True)
            merged_df.to_csv(output.batch_table, sep='\t', index = False)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

rule mod6_imputation_batch_files:
    input:
        batch_table = rules.mod6_batch_table.output.batch_table
    output:
        imputation_batches = expand(str(tmpMod6_phasing_test/"imputation_batch.{batch}"), batch = batches)
    params:
        r_script = "utils/make_imputation_batch_files.R"
    conda:
        "envs/r_4.2.yaml"
    run:
        out_trunk = mqc.plinkBase(output.imputation_batches[0])
        shell(f"Rscript {params.r_script} {input.batch_table} {out_trunk}")


rule mod6_filter_relationships:
    input:
        relationships = config['confirmed_relationships']
    output:
        filtered_relationships = str(tmpMod6_phasing_test / "filtered_relationships"),
        filtered_shapeit_fam = str(tmpMod6_phasing_test / "filtered_shapeit_fam"),
        filtered_trios = str(tmpMod6_phasing_test / "filtered_trios"),
        families = str(tmpMod6_phasing_test / "families"),
        males = str(tmpMod6_phasing_test / "males")
    params:
        r_script = "utils/filter_relationships.R"
    conda:
        "envs/r_4.2.yaml"
    run:
        shell(f"Rscript {params.r_script} {input.relationships} {output.filtered_shapeit_fam} {output.filtered_relationships} {output.filtered_trios} {output.families} {output.males}")

# rule mod6_make_relationships_tables:
#     input:
#         expected_relationships = config['confirmed_relationships'], # config['expected_relationships'],
#         batch_table = rules.mod6_batch_table.output.batch_table,
#         ids = config['id_mapping']
#     params:
#         batch_chip = "parameters/batch_chip",
#         r_script = "utils/make_relationships_tables.R",
#         king = "/mnt/archive3/snpQc/pipeOut_dev/2025.01.30/mod8-release_annotation/mod8_pedigree_ibd_estimate.kin0"
#     output:
#         all_relations = str(tmpMod6_phasing_test / "confirmed_all_relations"),
#         trios = str(tmpMod6_phasing_test / "confirmed_trios"),
#         shapeit_fam =  str(tmpMod6_phasing_test / "confirmed_shapeit_fam"),
#         imputation_batches = expand(str(tmpMod6_phasing_test/"imputation_batch.{batch}"), batch = batches)
#     conda:
#         "envs/r_4.2.yaml"
#     run:
#         imputation_batches_trunk = mqc.plinkBase(output.imputation_batches[0])
#         shell(f"Rscript {params.r_script} {input.expected_relationships} {params.king} {input.batch_table} {params.batch_chip} {input.ids} {output.all_relations} {output.shapeit_fam} {imputation_batches_trunk} {output.trios}")


# rule mod6_find_new_batches:
#     input:
#         relations_file = rules.mod6_make_relationships_tables.output.all_relations
#     output:
#         md_file = str(tmpMod6_phasing_test/"batch_shuffle.md"),
#         imputation_batches = expand(str(tmpMod6_phasing_test/"new_batches.imputation.{batch}"), batch = batches),
#         updated_relations = str(tmpMod6_phasing_test/"updated_relations"),
#         updated_trios = str(tmpMod6_phasing_test/"updated_trios")
#     params:
#         r_script = "utils/shuffle_imputation_batches.R"
#     conda:
#         "envs/r_4.2.yaml"
#     run:
#         out_trunk = mqc.plinkBase(mqc.plinkBase(output.imputation_batches[0]))
#         shell(f"Rscript {params.r_script} {input.relations_file} {out_trunk} {output.md_file} {output.updated_relations} {output.updated_trios}")

# rule mod6_find_families:
#     input:
#         relations = rules.mod6_filter_relationships.output.filtered_relationships #rules.mod6_find_new_batches.output.updated_relations,
#     output:
#         fids = str(tmpMod6_phasing_test /"fids"),
#         families = str(tmpMod6_phasing_test /"families") #str(tmpMod6_phasing_test/"families")
#     params:
#         python_script = "utils/find_families.py"
#     shell:
#         """
#         python {params.python_script} --relationships {input.relations} --fids {output.fids} --families {output.families}
#         """



def get_batches_with_chromosome(chr):
    batches_with_chromosome = []
    for batch in batches:
        chromosome_file = f"{tmpMod6str}/{batch}/chromosomes.txt"
        if mqc.chromosome_in_file(chromosome_file, chr):
            batches_with_chromosome.append(batch)
    return batches_with_chromosome

def get_chromosomes_in_batch(batch):
    chromosome_file = f"{tmpMod6str}/{batch}/chromosomes.txt"
    with open(chromosome_file, 'r') as infile:
        chromosomes = [line.strip() for line in infile]
    return chromosomes

rule mod6_find_par_phasing_batches:
    input:
        batch_table = rules.mod6_batch_table.output.batch_table
    output:
        phasing_batch = str(tmpMod6_phasing_test/"chr{chr}_phasing_batch.batch0")
    run:
        batches_with_chromosome = get_batches_with_chromosome(wildcards.chr)
        with open(input.batch_table, 'r') as infile, open(output.phasing_batch, 'w') as outfile:
            for line in infile:
                iid, batch = line.strip().split('\t')
                if batch in batches_with_chromosome:
                    outfile.write(f"{iid}\n")


rule mod6_find_phasing_batches:
    input:
        families = rules.mod6_filter_relationships.output.families
    output:
        phasing_batches = [str(tmpMod6_phasing_test/"phasing_batches_{n_batches}"/f"phasing_batch.batch{i}") for i in range(max_phasing_batches)]
    params:
        python_script = "utils/find_phasing_batches.py"
    run:
        out_trunk = mqc.plinkBase(output.phasing_batches[0])
        for f in output.phasing_batches:
            with open(f, 'w') as fp:
                pass
        shell(f"python {params.python_script} --families {input.families} --n_batches {wildcards.n_batches} --output_trunk {out_trunk}")




tmpMod6str = str(tmpMod6)
def get_index_conform_files_to_merge(wildcards):
    batches_with_chromosome = get_batches_with_chromosome(wildcards.chr)
    return [f"{tmpMod6str}/{batch}/mod6_conform.chr{wildcards.chr}.conformed.vcf.gz.tbi" for batch in batches_with_chromosome]


def get_conform_files_to_merge(wildcards):
    batches_with_chromosome = get_batches_with_chromosome(wildcards.chr)
    return [f"{tmpMod6str}/{batch}/mod6_conform.chr{wildcards.chr}.conformed.vcf.gz" for batch in batches_with_chromosome]

rule mod6_merge_batches:
    input:
        vcfs = get_conform_files_to_merge,
        index = get_index_conform_files_to_merge
    output:
        merged_bcf = "/mnt/archive3/phasing_test/mod6_merge_batches_chr{chr}.bcf"
    log:
        # str(tmpMod7 / "{number_of_samples}_samples" / "mod7_merge_batches.log")
        "/mnt/archive3/phasing_test/mod6_merge_batches_chr{chr}.log"
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        echo "Output file: {output.merged_bcf}" > {log}
        echo "Merge started $(date '+%Y-%m-%d %H:%M:%S')" >> {log}
        bcftools merge {input.vcfs} -o {output.merged_bcf} --write-index
        echo "Merge finished $(date '+%Y-%m-%d %H:%M:%S')" >> {log}
        echo "Merged files:" >> {log}
        for file in {input.vcfs}; do echo "$file" >> {log}; done
        """

# rule mod6_fill_ac_merged:
#     input:
#         bcf = rules.mod6_merge_batches.output.merged_bcf 
#     output:
#         bcf = "/mnt/archive3/phasing_test/mod6_fill_ac_merged.chr{chr}.bcf"
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         bcftools +fill-AN-AC {input.bcf} -o {output.bcf} --write-index
#         """

def get_map_chr(wildcards):
    if wildcards.chr == "PAR1":
        return "X_par1"
    elif wildcards.chr == "PAR2":
        return "X_par2"
    else:
        return wildcards.chr

        

# rule mod6_phase_merged:
#     input:
#         shapeit_fam = rules.mod6_make_relationships_tables.output.shapeit_fam,
#         bcf = rules.mod6_fill_ac_merged.output.bcf
#     output:
#         phased_bcf = str(tmpMod6_phasing_test / "mod6_phase_merged.chr{chr}.phased.bcf"),
#         shapeit_log = str(tmpMod6_phasing_test/ "mod6_phase_merged.chr{chr}.phased.log")
#     params:
#         map_chr=get_map_chr,
#         ref_chr=get_reference_chr,
#         region_chr=get_beagle_chr
#     conda:
#         "envs/shapeit_5.yaml"
#     threads: 32
#     shell:
#         """
#         reffile=$(echo {hrc_vcf}/HRC.r1-1.EGA.GRCh37.chr{params.ref_chr}.haplotypes*.vcf.gz)
#         mapfile={mapfiles}/shapeit/chr{params.map_chr}.b37.gmap.gz
#         SHAPEIT5_phase_common --input {input.bcf} --pedigree {input.shapeit_fam} --region {params.region_chr} --reference $reffile --map $mapfile --output {output.phased_bcf} --output-format bcf --log {output.shapeit_log} --thread {threads}
#         """


# rule mod6_phase_common:
#     input:
#         shapeit_fam ="/mnt/archive3/phasing_test/phase_merged_reshuffle/expected_shapeit_fam", # rules.mod6_make_relationships_tables.output.shapeit_fam,
#         bcf =  "/mnt/archive3/phasing_test/phase_related_reshuffle_imputation/mod6_split_phasing_batches.batch0.chr21.bcf" #rules.mod6_fill_ac_merged.output.bcf
#     output:
#         phased_bcf = "/mnt/archive3/phasing_test/mod6_phase_commom.chr{chr}.phased.bcf",
#         shapeit_log = "/mnt/archive3/phasing_test/mod6_phase_common.chr{chr}.phased.log"
#     params:
#         map_chr=get_map_chr,
#         ref_chr=get_reference_chr,
#         region_chr=get_beagle_chr
#     conda:
#         "envs/shapeit_5.yaml"
#     threads: 32
#     shell:
#         """
#         reffile=$(echo {hrc_vcf}/HRC.r1-1.EGA.GRCh37.chr{params.ref_chr}.haplotypes*.vcf.gz)
#         mapfile={mapfiles}/shapeit/chr{params.map_chr}.b37.gmap.gz
#         SHAPEIT5_phase_common --input {input.bcf} --filter-maf 0.001 --pedigree {input.shapeit_fam} --region {params.region_chr} --reference $reffile --map $mapfile --output {output.phased_bcf} --output-format bcf --log {output.shapeit_log} --thread {threads}
#         """


# rule mod6_phase_rare:
#     input:
#         shapeit_fam = "/mnt/archive3/phasing_test/phase_merged_reshuffle/expected_shapeit_fam", #rules.mod6_make_relationships_tables.output.shapeit_fam,
#         bcf = "/mnt/archive3/phasing_test/phase_related_reshuffle_imputation/mod6_split_phasing_batches.batch0.chr21.bcf",
#         phased_bcf = rules.mod6_phase_common.output.phased_bcf
#     output:
#         phased_bcf = "/mnt/archive3/phasing_test/mod6_phase_rare.chr{chr}.chunk0.phased.bcf"
#     params:
#         map_chr=get_map_chr,
#         ref_chr=get_reference_chr,
#         region_chr=get_beagle_chr
#     conda:
#         "envs/shapeit_5.yaml"
#     threads: 32
#     shell:
#         """
#         reffile=$(echo {hrc_vcf}/HRC.r1-1.EGA.GRCh37.chr{params.ref_chr}.haplotypes*.vcf.gz)
#         mapfile={mapfiles}/shapeit/chr{params.map_chr}.b37.gmap.gz
#         SHAPEIT5_phase_rare --input {input.bcf} --scaffold {input.phased_bcf} --pedigree {input.shapeit_fam}  --map $mapfile --input-region 21:1-39967491 --scaffold-region 21:1-48100155 --output {output.phased_bcf} --thread {threads}
#         """

# phasing_batches = batches + ["problem"]
# rule mod6_find_new_batches:
#     input:
#         relations_file = rules.mod6_make_relationships_tables.output.all_relations
#     output:
#         md_file = str(tmpMod6_phasing_test/"batch_shuffle.md"),
#         imputation_batches = expand(str(tmpMod6_phasing_test/"new_batches.imputation.{batch}"), batch = batches),
#         phasing_batches = expand(str(tmpMod6_phasing_test/"new_batches.phasing.{batch}"), batch = phasing_batches),
#         updated_relations = str(tmpMod6_phasing_test/"updated_relations"),
#         updated_trios = str(tmpMod6_phasing_test/"updated_trios"),
#         problem_children = str(tmpMod6_phasing_test/"problem_children")
#     params:
#         r_script = "utils/shuffle_batches.R"
#     conda:
#         "envs/r_4.2.yaml"
#     run:
#         out_trunk = mqc.plinkBase(mqc.plinkBase(output.imputation_batches[0]))
#         shell(f"Rscript {params.r_script} {input.relations_file} {out_trunk} {output.md_file} {output.updated_relations} {output.updated_trios} {output.problem_children}")



def get_phasing_samples_file(wildcards):
    if wildcards.chr == "PAR1" or wildcards.chr == "PAR2":
        return str(tmpMod6_phasing_test/f"chr{wildcards.chr}_phasing_batch.batch0")
    else:
        n_batches = n_phasing_batches[f'chr{wildcards.chr}']
        # return f"/mnt/archive3/phasing_test/phasing_batch.{wildcards.batch}"
        # return str(tmpMod6_phasing_test / f"mod6_make_split_samples_list.batch_{wildcards.batch}")
        return str(tmpMod6_phasing_test/f"phasing_batches_{n_batches}"/f"phasing_batch.{wildcards.batch}")
        # return str(tmpMod6_phasing_test/ f"new_batches.phasing.{wildcards.batch}")

# def get_phased_bcf(wildcards):
#     return 
    #return str(tmpMod6_phasing_test / f"mod6_phase_rare.chr{wildcards.chr}.phased.bcf")
    #return str(tmpMod6_phasing_test / f"mod6_phase_merged.chr{wildcards.chr}.phased.bcf"),

# Note the fixploidy plugin: male haploid chr X samples must be recoded as diploid homozygotes before phasing due to a bug in shapeit
rule mod6_split_phasing_batches:
    input:
        samples = get_phasing_samples_file,
        bcf = rules.mod6_merge_batches.output.merged_bcf
    output:
        bcf = str(tmpMod6_phasing_test / "mod6_split_phasing_batches.{batch}.chr{chr}.bcf")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        bcftools view {input.bcf} --samples-file {input.samples} | bcftools +fixploidy | bcftools +fill-AN-AC -Ob -o {output.bcf} --write-index
        """

# rule mod6_generate_male_list:
#     input:
#         fam = rules.mod5_output.output.bedset[2]
#     output:
#         male_list = str(tmpMod6 / "{batch}" / "males.txt"),
#         blank_list = str(tmpMod6 / "{batch}" / "blank_list.txt")
#     run:
#         mqc.create_male_list(input.fam, output.male_list)
#         mqc.create_empty_files([output.blank_list])   

rule mod6_phase:
    input:
        shapeit_fam = rules.mod6_filter_relationships.output.filtered_shapeit_fam,
        bcf = rules.mod6_split_phasing_batches.output.bcf,
        male_list = rules.mod6_filter_relationships.output.males,
        # blank_list = rules.mod6_generate_male_list.output.blank_list
    output:
        phased_bcf = str(tmpMod6_phasing_test  / "mod6_phase.{batch}.chr{chr}.phased.bcf"),
        shapeit_log = str(tmpMod6_phasing_test / "mod6_phase.{batch}.chr{chr}.phased.log")
    params:
        map_chr=get_map_chr,
        ref_chr=get_reference_chr,
        region_chr=get_beagle_chr,
        blank_file = "utils/blank_file"
    conda:
        "envs/shapeit_5.yaml"
    threads: 32
    shell:
        """
        if [[ "{wildcards.chr}" == "X" ]]; then
            haploid_file={input.male_list}
        else
            haploid_file={params.blank_file}
        fi
        reffile=$(echo {hrc_vcf}/HRC.r1-1.EGA.GRCh37.chr{params.ref_chr}.haplotypes*.vcf.gz)
        mapfile={mapfiles}/shapeit/chr{params.map_chr}.b37.gmap.gz
        SHAPEIT5_phase_common --input {input.bcf} --pedigree {input.shapeit_fam} --region {params.region_chr} --reference $reffile --haploids $haploid_file --map $mapfile --output {output.phased_bcf} --output-format bcf --log {output.shapeit_log} --thread {threads}
        """



# rule mod6_extract_phased_problem_children:
#     input:
#         bcf = str(tmpMod6_phasing_test / "mod6_phase.problem.chr{chr}.phased.bcf"),
#         problem_children = rules.mod6_find_new_batches.output.problem_children
#     output:
#         bcf = str(tmpMod6_phasing_test / "mod6_phase.problem_children.chr{chr}.phased.bcf")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         bcftools view {input.bcf} --samples-file {input.problem_children} | bcftools +fill-AN-AC -Ob -o {output.bcf} --write-index
#         """


# batches_and_problem_children = batches + ["problem_children"]
def get_phased_bcf(wildcards):
    return [str(tmpMod6_phasing_test / f"mod6_phase.{batch}.chr{wildcards.chr}.phased.bcf") for batch in phasing_batches[f"chr{wildcards.chr}"]]


rule mod6_merge_phased:
    input:
        bcfs = get_phased_bcf
    output:
        merged_bcf = str(tmpMod6_phasing_test / "mod6_merged_phased.chr{chr}.bcf")    
    log:
        str(tmpMod6_phasing_test / "mod6_merged_phased.chr{chr}.log")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        echo "Output file: {output.merged_bcf}" > {log}
        echo "Merge started $(date '+%Y-%m-%d %H:%M:%S')" >> {log}
        bcftools merge {input.bcfs} -o {output.merged_bcf} --force-single --write-index
        echo "Merge finished $(date '+%Y-%m-%d %H:%M:%S')" >> {log}
        echo "Merged files:" >> {log}
        for file in {input.bcfs}; do echo "$file" >> {log}; done
        """


def get_samples_file(wildcards):
    # return str(tmpMod6_phasing_test / f"mod6_make_split_samples_list.batch_{wildcards.batch}")
    return str(tmpMod6_phasing_test/ f"imputation_batch.{wildcards.batch}")
    #return f"/mnt/archive3/phasing_test/phase_merged_reshuffle/new_batches.batch_{wildcards.batch}"

def get_phased_bcf(wildcards):
    return str(tmpMod6_phasing_test / f"mod6_phase_rare.chr{wildcards.chr}.phased.bcf")
    # return str(tmpMod6_phasing_test / f"mod6_phase_merged.chr{wildcards.chr}.phased.bcf"),

def get_merged_phased(wildcards):
    return str(tmpMod6_phasing_test / "mod6_merged_phased.chr{wildcards.chr}.bcf")


rule mod6_split_imputation_batches_samples:
    input:
        samples = get_samples_file,
        bcf = rules.mod6_merge_phased.output.merged_bcf,
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file
    output:
        vcf = str(tmpMod6_phasing_test / "mod6_split_imputation_batches_samples.{batch}.chr{chr}.vcf.gz")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        mapfile -t chromosomes < {input.chromosome_file}
        if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
            echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_split_imputation_batches_samples"
            touch {output.vcf}
        else
             bcftools view {input.bcf} --samples-file {input.samples} | bcftools +fill-AN-AC -Oz -o {output.vcf} --write-index
        fi
        """

rule mod6_split_imputation_batches_variants:
    input:
        vcf = rules.mod6_split_imputation_batches_samples.output.vcf,
        conform = rules.mod6_conform.output.conformed_vcf,
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file
    output:
        vcf = str(tmpMod6_phasing_test / "mod6_split_imputation_batches_variants.{batch}.chr{chr}.vcf")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        mapfile -t chromosomes < {input.chromosome_file}
        if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
            echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_split_imputation_batches_variants"
            touch {output.vcf}
        else
            bcftools view {input.vcf} --regions-file {input.conform} -Ov -o {output.vcf}
        fi
        """

rule mod6_generate_bcftools_sex_files:
    input:
        fam = rules.mod5_output.output.bedset[2]
    output:
        sex_list = str(tmpMod6 / "{batch}" / "sex_list.txt")
    run:
        mqc.create_sex_list_for_bcftools(input.fam, output.sex_list) 

# convert male X variants back to haploid before imputation
rule mod6_reset_male_x_ploidy:
    input:
        vcf = rules.mod6_split_imputation_batches_variants.output.vcf, #rules.mod6_convert_to_vcf.output.vcf,
        sex_list = rules.mod6_generate_bcftools_sex_files.output.sex_list
    output:
        vcf = str(tmpMod6 / "{batch}" / "mod6_reset_male_x_ploidy.chr{chr}.vcf")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        if [[ {wildcards.chr} == "X" ]]; then
            bcftools +fixploidy {input.vcf} -o {output.vcf} -- -p {haploid_x_file} -s {input.sex_list}
        else
            cp {input.vcf} {output.vcf}
        fi
        """

rule_stem = "mod6_impute"
rule mod6_impute:
    input:
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
        vcf = rules.mod6_reset_male_x_ploidy.output.vcf #rules.mod6_split_imputation_batches_variants.output.vcf #rules.mod6_split_merged_variants.output.vcf #rules.mod6_reset_male_x_ploidy.output.vcf #rules.mod6_conform.output.conformed_vcf
    output:
        imputed_vcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_impute.chr{chr}.imputed.vcf.gz")
    params:
        map_chr=get_map_chr,
        beagle_chr=get_beagle_chr
    threads: 32
    log:
        str(tmpMod6_phasing_test/"{batch}" / "mod6_impute_log_chr{chr}.log")
    shell:
        """
        mapfile -t chromosomes < {input.chromosome_file}
        
        if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
            echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_impute"
            touch {output.imputed_vcf}
        else
            reffile={hrc_bref}/HRC_GRCh37.chr{wildcards.chr}.bref3
            mapfile={mapfiles}/plink.chr{params.map_chr}.GRCh37.map
            output_full={output.imputed_vcf}
            outTrunk="${{output_full%.vcf.gz}}"
            java -Xmx{config[mem]} -jar {beagle} gt={input.vcf} ref=$reffile impute=true out=$outTrunk chrom={params.beagle_chr} nthreads={threads} ap=true map=$mapfile
        fi 

        """

    
rule mod6_index:
    input:
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
        imputed_vcf = rules.mod6_impute.output.imputed_vcf
    output:
        index = str(tmpMod6_phasing_test / "{batch}" / "mod6_impute.chr{chr}.imputed.vcf.gz.tbi")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        mapfile -t chromosomes < {input.chromosome_file}
        
        if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
            echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_index"
            touch {output.index}
        
        else
            tabix -p vcf {input.imputed_vcf}
        fi 
        """

rule mod6_query:
    input:
        chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
        index = rules.mod6_index.output.index,
        imputed_vcf = rules.mod6_impute.output.imputed_vcf
    output:
        info = str(tmpMod6_phasing_test / "{batch}" / "mod6_impute.chr{chr}.imputed.vcf.gz.info")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        mapfile -t chromosomes < {input.chromosome_file}
        if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
            echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_query"
            touch {output.info}
        
        else
            bcftools query -f '%CHROM %POS %ID %IMP %REF %ALT %DR2 %AF\n' {input.imputed_vcf} -o {output.info}
        fi 
        """

def get_ref_vcf(wildcards):
    if wildcards.chr == "!":
        return str(hrc_vcf / "HRC.r1-1.EGA.GRCh37.chr1.haplotypes.noIBD.vcf.gz")
    elif wildcards.chr == "X":
        return str(hrc_vcf / "HRC.r1-1.EGA.GRCh37.chrX_nonPAR.haplotypes.vcf.gz")
    elif wildcards.chr == "PAR1":
        return str(hrc_vcf / "HRC.r1-1.EGA.GRCh37.chrX_PAR1.haplotypes.vcf.gz")
    elif wildcards.chr == "PAR2":
        return str(hrc_vcf / "HRC.r1-1.EGA.GRCh37.chrX_PAR2.haplotypes.vcf.gz")
    else:
        return str(hrc_vcf /f"HRC.r1-1.EGA.GRCh37.chr{wildcards.chr}.haplotypes.vcf.gz")

rule mod6_find_ref_af:
    input:
        vcf = get_ref_vcf
    output:
        af = str(hrc_af / "HRC_af_chr{chr}")
    conda:
        "envs/bcf_tabix.yaml"
    shell:
        """
        bcftools query -f '%CHROM\t%POS\t%ID\t%AF\n' {input.vcf} -o {output.af}
        """

def get_query_files(wildcards):
    chromosomes = ["3"] #get_chromosomes_in_batch(wildcards.batch)
    return [str(tmpMod6_phasing_test / f"{wildcards.batch}" / f"mod6_impute.chr{chr}.imputed.vcf.gz.info") for chr in chromosomes]
    #return [str(tmpMod6 / f"{wildcards.batch}" / f"mod6_impute.chr{chr}.imputed.vcf.gz.info") for chr in chromosomes]

rule mod6_imputation_report:
    input:
        imputed_info = get_query_files,
        ref_af = expand(str(hrc_af / "HRC_af_chr{chr}"), chr=chrs)
    output:
        report = str(tmpMod6_phasing_test / "{batch}" / "imputation_report.md")
    params:
        r_script = "utils/imputation_report.R"
    conda:
        "envs/r_4.2.yaml"
    run:
        ref_directory = os.path.dirname(input.ref_af[0])
        imp_directory = os.path.dirname(input.imputed_info[0])
        shell(f"Rscript {params.r_script} {ref_directory} {imp_directory} {output.report}")

# def split_samples(input_file, output_file, batch):
#     with open(input_file) as f:
#         lines = f.readlines()
#     second_column = [line.split()[1] for line in lines]
#     if batch[0:-2] in batches_to_split:
#         half_point = len(second_column) // 2
#         if batch.endswith("_1"):
#             with open(output_file, "w") as f1:
#                 f1.writelines("\n".join(second_column[:half_point]) + "\n")
#         else:
#             with open(output_file, "w") as f2:
#                 f2.writelines("\n".join(second_column[half_point:]) + "\n")
#     else:
#         with open(output_file, "w") as f:
#             f.writelines("\n".join(second_column) + "\n")

# def get_input_fam_file(wildcards):
#     if wildcards.split_batch[0:-2] in batches_to_split:
#         b = wildcards.split_batch[0:-2]
#     else:
#         b = wildcards.split_batch
#     return str(tmpMod5 / b / "mod5_output.fam")

# rule mod6_make_samples_list:
#     input:
#         fam = get_input_fam_file
#     output:
#         samples = str(tmpMod6_phasing_test / "mod6_make_split_samples_list.batch_{split_batch}")
#     run:
#         split_samples(input.fam, output.samples, wildcards.split_batch)







# rule mod6_make_samples_list:
#     input:
#         fam = rules.mod5_output.output.bedset[2]
#     output:
#         samples = str(tmpMod6_phasing_test / "mod6_make_samples_list.batch_{batch}")
#     shell:
#         """
#         cut -f2 {input.fam} > {output.samples}
#         """

# def get_samples_file(wildcards):
#     # return str(tmpMod6_phasing_test / f"mod6_make_split_samples_list.batch_{wildcards.batch}")
#     return str(tmpMod6_phasing_test/ f"new_batches.batch_{wildcards.batch}")

# def get_phased_bcf(wildcards):
#     return str(tmpMod6_phasing_test / f"mod6_phase_rare.chr{wildcards.chr}.phased.bcf")
#     # return str(tmpMod6_phasing_test / f"mod6_phase_merged.chr{wildcards.chr}.phased.bcf"),

# rule mod6_split_merged_samples:
#     input:
#         samples = get_samples_file,
#         bcf = get_phased_bcf
#     output:
#         vcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_split_merged_samples.chr{chr}.vcf.gz")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         bcftools view {input.bcf} --samples-file {input.samples} -Oz -o {output.vcf} --write-index
#         """
        

# rule mod6_split_merged_variants:
#     input:
#         vcf = rules.mod6_split_merged_samples.output.vcf,
#         conform = rules.mod6_conform.output.conformed_vcf
#     output:
#         vcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_split_merged_variants.chr{chr}.vcf")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         bcftools view {input.vcf} --regions-file {input.conform} -Ov -o {output.vcf}
#         """
# rule mod6_impute_split_phased:
#     input:
#         vcf = rules.mod6_split_merged_phased.out.vcf
#     output:
#         imputed_vcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_impute_split_phased.chr{chr}.imputed.vcf.gz")
#     params:
#         map_chr=get_map_chr,
#         beagle_chr=get_beagle_chr
#     threads: 32
#     log:
#         str(tmpMod6_phasing_test/"{batch}" / "mod6_impute_split_phased.chr{chr}.log")
#     shell:
#         """
#         reffile={hrc_bref}/HRC_GRCh37.chr{wildcards.chr}.bref3
#         mapfile={mapfiles}/plink.chr{params.map_chr}.GRCh37.map
#         output_full={output.imputed_vcf}
#         outTrunk="${{output_full%.vcf.gz}}"
#         java -Xmx{config[mem]} -jar {beagle} gt={input.vcf} ref=$reffile impute=true out=$outTrunk chrom={params.beagle_chr} nthreads={threads} ap=true map=$mapfile
#         """



# rule mod6_generate_bcftools_sex_files:
#     input:
#         fam = rules.mod5_output.output.bedset[2]
#     output:
#         sex_list = str(tmpMod6_phasing_test / "{batch}" / "sex_list.txt")
#     run:
#         mqc.create_sex_list_for_bcftools(input.fam, output.sex_list) 

# # convert male X variants back to haploid before imputation
# rule mod6_reset_male_x_ploidy:
#     input:
#         vcf = rules.mod6_split_merged_phased.output.vcf,
#         sex_list = rules.mod6_generate_bcftools_sex_files.output.sex_list
#     output:
#         vcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_reset_male_x_ploidy.chr{chr}.vcf")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         if [[ {wildcards.chr} == "X" ]]; then
#             bcftools +fixploidy {input.vcf} -o {output.vcf} -- -p {haploid_x_file} -s {input.sex_list}
#         else
#             cp {input.vcf} {output.vcf}
#         fi
#         """










# chrs = ["20, 21"]
# rule mod6_find_new_batches:
#     input:
#         relations_file = "/mnt/archive3/phasing_test/all_relations" # hook later
#     output:
#         md_file = "/mnt/archive3/phasing_test/batch_shuffle.md",
#         new_batches = expand("/mnt/archive3/phasing_test/new_batches.batch_{batch}", batch = batches)
#     params:
#         r_script = "utils/shuffle_batches.R"
#     conda:
#         "envs/r_4.2.yaml"
#     run:
#         out_trunk = mqc.plinkBase(output.new_batches[0])
#         shell(f"Rscript {params.r_script} {input.relations_file} {out_trunk} {output.md_file}")


# # def get_chr_shuffle_file(wildcards):
# #     return f"/mnt/archive3/phasing_test/new_batches.chr{wildcards.chr}"

# def get_merged_chr_file(wildcards):
#     return f"/mnt/archive3/phasing_test/mod6_merge_batches_chr{wildcards.chr}.bcf"

# def get_samples_file(wildcards):
#     return f"/mnt/archive3/phasing_test/new_batches.batch_{wildcards.batch}"

# rule mod6_split_new_batches:
#     input:
#         samples_file = get_samples_file,
#         merged_chr_file = rules.mod6_merge_batches.output.merged_bcf
#     output:
#         bcf = "/mnt/archive3/phasing_test/{batch}/mod6_split_new_batches.chr{chr}.bcf"
#     conda:
#         "envs/bcf_tabix.yaml"
#     run:
#         shell(f"bcftools view {input.merged_chr_file} --samples-file {input.samples_file} -o {output.bcf} --write-index")
#         # shell(f"bcftools +split {input.merged_chr_file} -o {output_folder} --samples-file {input.new_batches}")
    

# # Note the fixploidy plugin: male haploid chr X samples must be recoded as diploid homozygotes before phasing due to a bug in shapeit
# rule mod6_fill_ac:
#     input:
#         chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
#         bcf = rules.mod6_split_new_batches.output.bcf, #rules.mod6_conform.output.conformed_vcf,
#         index = rules.mod6_index_conform.output.index
#     output:
#         bcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_fill_ac.chr{chr}.bcf")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         mapfile -t chromosomes < {input.chromosome_file}
#         if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
#             echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_fill_ac"
#             touch {output.bcf}
#         else
#             bcftools +fill-AN-AC {input.bcf} | bcftools +fixploidy -o {output.bcf} --write-index
#         fi
#         """



# # rule mod6_index_fill_ac:
# #     input:
# #         chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
# #         bcf = rules.mod6_fill_ac.output.bcf
# #     output:
# #         index = str(tmpMod6 / "{batch}" / "mod6_fill_ac.chr{chr}.bcf.gz.csi")
# #     conda:
# #         "envs/bcf_tabix.yaml"
# #     shell:
# #         """
# #         mapfile -t chromosomes < {input.chromosome_file}
# #         if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
# #             echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_index_fill_ac"
# #             touch {output.index}
# #         else
# #             tabix -p bcf {input.bcf}
# #         fi
# #         """




# # rule mod6_generate_shapeit_family_files:
# #     input:
# #         fam = rules.mod5_output.output.bedset[2]
# #     output:
# #         shapeit_fam = str(tmpMod6 / "{batch}" / "shapeit_fam.fam")
# #     run:
# #         mqc.filter_fam_table_for_shapeit(input.fam, output.shapeit_fam)




# tmpMod6str = str(tmpMod6)
# def get_shapeit_fam(wildcards):
#     return f"{tmpMod6}/{wildcards.batch}/shapeit_fam.fam"



# rule mod6_phase:
#     input:
#         chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
#         shapeit_fam = "/mnt/archive3/phasing_test/shapeit_fam",
#         bcf = rules.mod6_fill_ac.output.bcf,
#         male_list = rules.mod6_generate_male_list.output.male_list,
#         blank_list = rules.mod6_generate_male_list.output.blank_list
#     output:
#         phased_bcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_phase.chr{chr}.phased.bcf"),
#         shapeit_log = str(tmpMod6_phasing_test / "{batch}" / "mod6_phase.chr{chr}.phased.log")
#     params:
#         map_chr=get_map_chr,
#         ref_chr=get_reference_chr,
#         region_chr=get_beagle_chr
#     conda:
#         "envs/shapeit_5.yaml"
#     threads: 1
#     shell:
#         """
#         mapfile -t chromosomes < {input.chromosome_file}
#         if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
#             echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_phase"
#             touch {output.phased_bcf}
#             touch {output.shapeit_log}
#         else
#             if [[ "{wildcards.chr}" == "X" ]]; then
#                 haploid_file={input.male_list}
#             else
#                 haploid_file={input.blank_list}
#             fi
#             reffile=$(echo {hrc_vcf}/HRC.r1-1.EGA.GRCh37.chr{params.ref_chr}.haplotypes*.vcf.gz)
#             mapfile={mapfiles}/shapeit/chr{params.map_chr}.b37.gmap.gz
#             SHAPEIT5_phase_common --input {input.bcf} --pedigree {input.shapeit_fam} --region {params.region_chr} --haploids $haploid_file --reference $reffile --map $mapfile --output {output.phased_bcf} --output-format bcf --log {output.shapeit_log} --thread {threads}
#         fi
#         """


# rule mod6_convert_to_vcf:
#     input:
#         chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
#         bcf = rules.mod6_phase.output.phased_bcf
#     output:
#         vcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_phase.chr{chr}.phased.vcf")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         mapfile -t chromosomes < {input.chromosome_file}
#         if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
#             echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_convert_to_vcf"
#             touch {output.vcf}
#         else
#             bcftools convert -Ov -o {output.vcf} {input.bcf}
#         fi
#         """

# rule mod6_generate_bcftools_sex_files:
#     input:
#         fam = rules.mod5_output.output.bedset[2]
#     output:
#         sex_list = str(tmpMod6_phasing_test / "{batch}" / "sex_list.txt")
#     run:
#         mqc.create_sex_list_for_bcftools(input.fam, output.sex_list) 

# # convert male X variants back to haploid before imputation
# rule mod6_reset_male_x_ploidy:
#     input:
#         vcf = rules.mod6_convert_to_vcf.output.vcf,
#         sex_list = rules.mod6_generate_bcftools_sex_files.output.sex_list
#     output:
#         vcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_reset_male_x_ploidy.chr{chr}.vcf")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         if [[ {wildcards.chr} == "X" ]]; then
#             bcftools +fixploidy {input.vcf} -o {output.vcf} -- -p {haploid_x_file} -s {input.sex_list}
#         else
#             cp {input.vcf} {output.vcf}
#         fi
#         """

# rule_stem = "mod6_impute"
# rule mod6_impute:
#     input:
#         chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
#         vcf = rules.mod6_reset_male_x_ploidy.output.vcf #rules.mod6_conform.output.conformed_vcf
#     output:
#         imputed_vcf = str(tmpMod6_phasing_test / "{batch}" / "mod6_impute.chr{chr}.imputed.vcf.gz")
#     params:
#         map_chr=get_map_chr,
#         beagle_chr=get_beagle_chr
#     threads: 32
#     log:
#         str(tmpMod6_phasing_test/"{batch}" / "mod6_impute_log_chr{chr}.log")
#     shell:
#         """
#         mapfile -t chromosomes < {input.chromosome_file}
        
#         if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
#             echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_impute"
#             touch {output.imputed_vcf}
        
#         else
#             reffile={hrc_bref}/HRC_GRCh37.chr{wildcards.chr}.bref3
#             mapfile={mapfiles}/plink.chr{params.map_chr}.GRCh37.map
#             output_full={output.imputed_vcf}
#             outTrunk="${{output_full%.vcf.gz}}"
#             java -Xmx{config[mem]} -jar {beagle} gt={input.vcf} ref=$reffile impute=true out=$outTrunk window-markers={config[beagle_window_markers]} chrom={params.beagle_chr} nthreads={threads} ap=true map=$mapfile
#         fi 
#         """

    
# rule mod6_index:
#     input:
#         chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
#         imputed_vcf = rules.mod6_impute.output.imputed_vcf
#     output:
#         index = str(tmpMod6_phasing_test / "{batch}" / "mod6_impute.chr{chr}.imputed.vcf.gz.tbi")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         mapfile -t chromosomes < {input.chromosome_file}
        
#         if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
#             echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_index"
#             touch {output.index}
        
#         else
#             tabix -p vcf {input.imputed_vcf}
#         fi 
        
#         """

# rule mod6_query:
#     input:
#         chromosome_file = rules.mod6_generate_chromosome_file.output.chromosome_file,
#         index = rules.mod6_index.output.index,
#         imputed_vcf = rules.mod6_impute.output.imputed_vcf
#     output:
#         info = str(tmpMod6_phasing_test / "{batch}" / "mod6_impute.chr{chr}.imputed.vcf.gz.info")
#     conda:
#         "envs/bcf_tabix.yaml"
#     shell:
#         """
#         mapfile -t chromosomes < {input.chromosome_file}
#         if [[ ! " ${{chromosomes[@]}} " =~ " {wildcards.chr} " ]]; then
#             echo "Chromosome {wildcards.chr} not in chromosome list for {wildcards.batch}, bypassing mod6_query"
#             touch {output.info}
        
#         else
#             bcftools query -f '%CHROM %POS %ID %IMP %REF %ALT %DR2 %AF\n' {input.imputed_vcf} -o {output.info}
#         fi 
#         """

    