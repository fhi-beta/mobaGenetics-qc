##
#
# This module generates documentation on qualtity, familial relatedness, sex assignment, and PCA analysis on the merged set of genotypes.
#
##
import os

mod7_output = "/mnt/work/qc_genotypes/pipeOut_dev/2024.09.23/mod7-post-imputation/all_samples/mod7_rename_missing_ids"
r2_table = "/mnt/work/qc_genotypes/pipeOut_dev/2024.09.23/mod7-post-imputation/all_samples/mod7_dr2.txt.gz"
best_hits_table = "/mnt/work/qc_genotypes/pipeOut_dev/2024.09.23/mod7-post-imputation/all_samples/mod7_best_snps_le.txt"

rule_stem = 'mod8_split_rare_common'
rule mod8_split_rare_common:
    'Split the rare from common markers'
    input:
        pgenset = [mod7_output + ".pgen"], # rules.mod7_rename_missing_ids.output.pgenset,
    output:
        pgenset_common_snps = multiext(str(tmpMod8 / rule_stem),".pgen",".pvar",".psam"),
        afreq_common_snps = tmpMod8/(rule_stem + '.afreq'),
        pgenset_rare_snps = multiext(str(tmpMod8/rule_stem) + "_rare", ".pgen", ".pvar", ".psam")
    params:
        release_maf_threshold = config['release_maf_thr'],
        mac_threshold = config['merged_set_best_snps_mac_thr']
    run:
        try:

            inTrunk =  mqc.plinkBase(input.pgenset[0])
            freqTrunk =  mqc.plinkBase(output.afreq_common_snps)
            outTrunk_rare_snps =  mqc.plinkBase(output.pgenset_rare_snps[0])
            outTrunk_common_snps =  mqc.plinkBase(output.pgenset_common_snps[0])

            print(f"Initial filtering.")

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--mac", str(params.mac_threshold),
                    "--maf", str(params.release_maf_threshold),
                    "--out", outTrunk_common_snps,
                    "--make-pgen"
                ],
                check=True
            )

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--exclude", outTrunk_common_snps.pvar,
                    "--out", outTrunk_rare_snps,
                    "--make-pgen"
                ],
                check=True
            )

            # Precompute frequencies
            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--freq",
                    "--out", freqTrunk
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

rule_stem = 'mod8_common_snps_filter'
rule mod8_common_snps_filter:
    'Select common markers genotyped or with best imputation scores, filter by mac and geno rate'
    input:
        pgenset = rules.mod8_split_rare_common.output.pgenset_common_snps,
        afreq_common_snps = rules.mod8_split_rare_common.output.afreq_common_snps,
        r2_table = r2_table, # rules.summarize_dr2.output.r2,
        best_snps = best_hits_table, # rules.summarize_dr2.output.top_snps
        high_ld_regions_hg19 = high_ld_regions_hg19
    output:
        pgenset_common_snps = temp(multiext(str(tmpMod8 / rule_stem),".pgen",".pvar",".psam")),
        pgenset_best_snps = temp(multiext(str(tmpMod8/rule_stem) + "_best_snps", ".pgen", ".pvar", ".psam")),
        best_pruned_list = str(tmpMod8/rule_stem) + "_best_snps_pruned.prune.in"
    params:
        release_maf_threshold = config['release_maf_thr'],
        release_hw_threshold = config['release_hw_thr'],
        release_sd_het_threshold = config['release_sd_het_thr'],
        mac_threshold = config['merged_set_best_snps_mac_thr'],
        geno_threshold = config['merged_set_best_snps_geno_thr'],
        info_threshold = config['merged_set_best_snps_info_thr']
    run:
        try:

            inTrunk =  mqc.plinkBase(input.pgenset[0])
            outTrunk_best_snps =  mqc.plinkBase(output.pgenset_best_snps[0])
            outTrunk_common =  mqc.plinkBase(output.pgenset_common_snps[0])

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--hardy", "midp",
                    "--read-freq", input.afreq_common_snps,
                    "--out", inTrunk
                ],
                check = True
            )

            mqc.extract_list(
                inTrunk + ".hardy",
                inTrunk + ".exclude",
                threshold_doc_file = inTrunk + ".details",
                sep = None,
                colName = "^MIDP$",
                condition = "<",
                threshold = params.release_hw_threshold,
                key_cols = [1],
                doc_cols = [0, 1]
            )

            mqc.extract_list(
                inTrunk + ".hardy.x",
                inTrunk + "_x.exclude",
                threshold_doc_file = inTrunk + ".details",
                sep = None,
                colName = "^MIDP$",
                condition = "<",
                threshold = params.release_hw_threshold,
                key_cols = [1],
                doc_cols = [0, 1]
            )


            print(f"het.")

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--read-freq", input.afreq_common_snps,
                    "--autosome",
                    "--maf", str(0.01),
                    "--het",
                    "--out",
                    inTrunk
                ],
                check = True
            )

            het_p_values = inTrunk + ".het"
            mqc.compute_excess_het(
                het_p_values,
                inTrunk + "_het.exclude",
                params.release_sd_het_threshold,
                plink1=False
            )

            with open(inTrunk + ".exclude", 'a') as exclude_file:
                with open(inTrunk + "_x.exclude", 'r') as exclude_x_file:
                    exclude_file.write(exclude_x_file.read())
                with open(inTrunk + "_het.exclude", 'r') as exclude_het_file:
                    exclude_file.write(exclude_het_file.read())

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--exclude", inTrunk + ".exclude",
                    "--out", outTrunk_common,
                    "--make-pgen"
                ],
                check = True
            )


            print(f"Best snps.")

            id_file = tmpMod8/"ids_best"
            print(f"Extracting markers with overall r2 >= {params.info_threshold}.")
            r2_data = pd.read_csv(r2_table, sep = "\t")
            snp_08 = r2_data[r2_data['COMBINED'] >= params.info_threshold]
            snp_08['ID'].to_csv(id_file, index = False, header = False)

            # Change to best snps when chrom fixed
                    # "--pfile", inTrunk,
                    # "--extract", input.best_snps,

            temp1 = outTrunk_best_snps + "_temp1"

            subprocess.run(
                [
                    plink2local,
                    "--pfile", outTrunk_common,
                    "--extract", id_file,
                    "--max-alleles", "2",
                    "--mac", str(params.mac_threshold),
                    "--geno", str(params.geno_threshold),
                    "--out", temp1,
                    "--make-pgen"
                ],
                check=True
            )

            temp2 = outTrunk_best_snps + "_pruned"

            subprocess.run(
                [
                    plink2local,
                    "--pfile", temp1,
                    "--autosome",
                    "--exclude", "range", input.high_ld_regions_hg19
                ] + params.prune_cmd.split() + [
                    "--out", temp2
                ],
                check = True
            )

            mqc.remove_bedset(temp1)

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--extract", output.pruned_list,
                    "--out", outTrunk_best_snps,
                    "--make-pgen"
                ],
                check = True
            )

            mqc.remove_bedset(temp2)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'mod8_generate_best_snps_stats'
rule mod8_generate_best_snps_stats:
    'Generate statistics on the filtered snps'
    input:
        pgenset = rules.mod8_common_snps_filter.output.pgenset_best_snps
    output:
        het = tmpMod8/'mod8_best_snps.het',
        hardy = tmpMod8/'mod8_best_snps.hardy',
        afreq = tmpMod8/'mod8_best_snps.afreq',
        smiss = tmpMod8/'mod8_best_snps.smiss',
        vmiss = tmpMod8/'mod8_best_snps.vmiss',
    threads: 1
    run:
        try:
            # Plink base paths
            plink_input = mqc.plinkBase(input.pgenset[0])
            plink_het_output = mqc.plinkBase(output.het)
            plink_hwe_output = mqc.plinkBase(output.hardy)
            plink_freq_output = mqc.plinkBase(output.afreq)
            plink_miss_output = mqc.plinkBase(output.smiss)

            # Frequencies
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--freq",
                    "--out", plink_freq_output
                ],
                check=True
            )

            # Heterozygocity rate
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--read-freq", output.afreq,
                    "--het",
                    "--out", plink_het_output
                ],
                check=True
            )

            # HWE
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--hardy", "midp",
                    "--read-freq", output.afreq,
                    "--out", plink_hwe_output
                ],
                check=True
            )

            # Missingness
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--read-freq", output.afreq,
                    "--missing",
                    "--out", plink_miss_output
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

rule_stem = 'mod8_check_sex'
rule mod8_check_sex:
    'Sex imputation. Currently not supported in plink2, running in plink1.'
    input:
        pgenset_best_snps = rules.mod8_common_snps_filter.output.pgenset_best_snps,
    params:
        info_threshold = config['merged_set_best_snps_info_thr']
    output:
        sex_check = tmpMod8/(rule_stem + ".sexcheck")
    run:
        try:

            x_fixed = False # Currently the sex chromosomes are not available, so we take the sex check results prior to imputation

            if x_fixed:

                plink_input = mqc.plinkBase(input.pgenset_best_snps[0])
                plink1_input = plink_input + "_plink1"
                ouput_file = mqc.plinkBase(output.sex_check)

                subprocess.run(
                    [
                        plink2local,
                        "--pfile", plink_input,
                        "--extract", id_file,
                        "--make-bed",
                        "--out", plink1_input
                    ],
                )

                subprocess.run(
                    [
                        plinklocal,
                        "--bfile", plink1_input,
                        "--check-sex", "ycount",
                        "--out", ouput_file
                    ],
                    check = True
                )

                mqc.remove_bedset(plink1_input)

            else:

                sex_checks = []

                for batch in batches:
                    print(f"Importing sex_check for batch {batch}.")
                    file = f"/mnt/work/qc_genotypes/pipeOut_dev/2024.07.01/mod2-genetic-relationship/{batch}/m2_output.sexcheck"
                    sex_check = pd.read_table(file, delim_whitespace=True)
                    sex_checks.append(sex_check)

                merged_df = pd.concat(sex_checks, ignore_index = True)

                merged_df.to_csv(output.sex_check, sep='\t', index = False)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

def get_fam_per_batch():
    return [f"{tmpMod2}/{batch}/m2_output.fam" for batch in batches]

rule_stem = 'mod8_batch_table'
rule mod8_batch_table:
    'Create a table listing the batch for each sample.'
    input:
        batch_fam = get_fam_per_batch()
    output:
        batch_table = tmpMod8/(rule_stem + "_batch")
    run:
        try:

            id_to_batch_dfs = []

            for batch in batches:
                print(f"Importing fam for batch {batch}.")
                file = f"{tmpMod2}/{batch}/m2_output.fam"
                fam = pd.read_table(file, sep = " ", names =["fid", "iid", "mid", "pid", "sex", "pheno"])
                fam['batch'] = batch
                id_to_batch = fam[['iid', 'batch']]
                id_to_batch_dfs.append(id_to_batch)

            merged_df = pd.concat(id_to_batch_dfs, ignore_index = True)

            merged_df.to_csv(output.batch_table, sep='\t', index = False)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'mod8_pedigree_ibd_estimate'
rule mod8_pedigree_ibd_estimate:
    'IBD estimation. Requires conversion to plink1.'
    input:
        pgenset = rules.mod8_common_snps_filter.output.pgenset_best_snps,
    output:
        king_relatedness = tmpMod8/(rule_stem + ".kin0")
    threads: 24
    run:
        try:
            plink_input = mqc.plinkBase(input.pgenset[0])
            plink_input_1 = mqc.plinkBase(input.pgenset[0]) + "_plink1"
            outTrunk = mqc.plinkBase(output.king_relatedness)

            # Convert to plink1
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--make-bed",
                    "--out", plink_input_1
                ],
            )

            # Make FIDs unique to skip within-family computation
            fam_file = plink_input_1 + ".fam"
            fam_data = pd.read_csv(fam_file, sep = "\t", names =["fid", "iid", "mid", "pid", "sex", "pheno"])
            fam_data['fid'] = fam_data['iid']
            fam_data.to_csv(fam_file, index = False, header = False, sep='\t')

            # King relatedness analysis
            subprocess.run(
                [
                    kinglocal,
                    "-b", plink_input_1 + ".bed",
                    "--related",
                    "--cpus", str(threads),
                    "--prefix", outTrunk
                ],
                check = True
            )

            mqc.remove_bedset(plink_input_1)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'mod8_psam_reconstruction'
rule mod8_psam_reconstruction:
    input:
        psam_all_markers = rules.mod8_common_snps_filter.output.pgenset_common_snps[2],
        king_relatedness = rules.mod8_pedigree_ibd_estimate.output.king_relatedness,
        sex_check = rules.mod8_check_sex.output.sex_check,
        expected_relationships = config['expected_relationships'],
        birth_year = config['birth_year']
    params:
        title = "\"Psam file reconstruction\""
    output:
        updated_psam = tmpMod8/(rule_stem + ".psam"),
        pedigree_sample_exclusion = tmpMod8/(rule_stem + "_pedigree_sample_exclusion"),
        mismatch_information = tmpMod8/"mismatch_information.gz",
        mismatch_relationship = tmpMod8/"mismatch_relationship.gz",
        md_file = github_docs/(rule_stem + ".md")
    conda:
        "envs/r_4.2.yaml"
    threads: 1
    shell:
        """
        Rscript utils/pedigree/simple_psam_reconstruction.R \
            {input.king_relatedness} \
            {input.sex_check} \
            {input.expected_relationships} \
            {input.birth_year} \
            {input.psam_all_markers} \
            {output.updated_psam} \
            {output.pedigree_sample_exclusion} \
            {output.mismatch_information} \
            {output.mismatch_relationship} \
            {output.md_file} \
            {params.title}
        """


rule_stem = 'mod8_exclude_conflictual_relationships'
rule mod8_exclude_conflictual_relationships:
    input:
        pgenset_common_snps = rules.mod8_common_snps_filter.output.pgenset_common_snps,
        pgenset_rare_snps = rules.mod8_split_rare_common.output.pgenset_rare_snps,
        pgenset_best_snps = rules.mod8_common_snps_filter.output.pgenset_best_snps,
        pedigree_sample_exclusion = rules.mod8_psam_reconstruction.output.pedigree_sample_exclusion,
        updated_psam = rules.mod8_psam_reconstruction.output.updated_psam
    output:
        pgenset_common_snps =  multiext(str(tmpMod8/rule_stem), ".pgen", ".pvar", ".psam"),
        pgenset_rare_snps = multiext(str(tmpMod8/(rule_stem + "_rare")), ".pgen", ".pvar", ".psam"),
        pgenset_best_snps = multiext(str(tmpMod8/(rule_stem + "_best_snps")), ".pgen", ".pvar", ".psam")
    run:
        try:
            inTrunk_common_markers = mqc.plinkBase(input.pgenset_common_snps[0])
            outTrunk_common_markers = mqc.plinkBase(output.pgenset_common_snps[0])
            inTrunk_rare_markers = mqc.plinkBase(input.pgenset_rare_snps[0])
            outTrunk_rare_markers = mqc.plinkBase(output.pgenset_rare_snps[0])
            inTrunk_best_markers = mqc.plinkBase(input.pgenset_best_snps[0])
            outTrunk_best_markers = mqc.plinkBase(output.pgenset_best_snps[0])

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk_common_markers,
                    "--remove", input.pedigree_sample_exclusion,
                    "--out", outTrunk_common_markers,
                    "--make-pgen"
                ],
                check = True
            )

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk_rare_markers,
                    "--remove", input.pedigree_sample_exclusion,
                    "--out", outTrunk_rare_markers,
                    "--make-pgen"
                ],
                check = True
            )

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk_best_markers,
                    "--remove", input.pedigree_sample_exclusion,
                    "--out", outTrunk_best_markers,
                    "--make-pgen"
                ],
                check = True
            )

            # Update psam
            copyfile(input.updated_psam, outTrunk_common_markers + ".psam")
            copyfile(input.updated_psam, outTrunk_rare_markers + ".psam")
            copyfile(input.updated_psam,outTrunk_best_markers + ".psam")


        except Exception as e:
                    print(f"An exception occurred in rule {rule}.")
                    print(e)


# Reduce 1000 genome markers to the intersection with pruned markers
rule_stem = 'mod8_common_markers_moba_ref'
rule mod8_common_markers_moba_ref:
    input:
        bedset_ref = multiext(config["1000_genomes_stem"], '.bed', '.bim', '.fam'),
        pgenset_moba = rules.mod8_exclude_conflictual_relationships.output.pgenset_best_snps
    output:
        bedset_ref = multiext(str(tmpMod8/"pca_ref") ,'.bed','.bim','.fam'),
        bedset_moba = multiext(str(tmpMod8/"pca_moba") ,'.bed','.bim','.fam'),
        tri_alleles = tmpMod8/(rule_stem + "_tri_alleles.missnp"),
        marker_list = tmpMod8/(rule_stem + ".txt")
    benchmark:
        tmpMod8/(rule_stem + ".benchmark")

    run:
        inTrunk_ref =  mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba =  mqc.plinkBase(input.pgenset_moba[0])
        outTrunk_ref =  mqc.plinkBase(output.bedset_ref[0])
        outTrunk_moba =  mqc.plinkBase(output.bedset_moba[0])
        inTrunk_moba_1 = mqc.plinkBase(input.pgenset_moba[0]) + "_plink1"
        outTrunk_ref_temp = outTrunk_ref + "_temp"
        outTrunk_moba_temp = outTrunk_moba + "_temp"
        triallelesTrunk =  mqc.plinkBase(output.tri_alleles)

        # At this stage, 1KG is in plink1 format, MoBa plink2, we convert everything to plink1 for PCA
        subprocess.run(
            [
                plink2local,
                "--pfile", inTrunk_moba,
                "--make-bed",
                "--out", inTrunk_moba_1
            ],
        )


        # Common markers found in marker_list
        mqc.intersect_rsid(inTrunk_moba_1 + ".bim", inTrunk_ref + ".bim",  output.marker_list)

        # Reduce both sets to the common markers
        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk_ref,
                "--extract", output.marker_list,
                "--out", outTrunk_ref_temp,
                "--allow-extra-chr",
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk_moba_1,
                "--extract", output.marker_list,
                "--out", outTrunk_moba_temp,
                "--make-bed"
            ],
            check = True
        )

        # alas these two are not identical enough -
        # discover tri-allele problems by dummy-merging
        # Note that we don't want to abort on plink-failure (as this will be)
        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_ref_temp,
                "--bmerge", outTrunk_moba_temp,
                "--out", triallelesTrunk
            ],
            check = False
        )

        # ... And then remove these markers from both sets
        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_ref_temp,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_ref,
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_moba_temp,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_moba,
                "--make-bed"
            ],
            check = True
        )

        mqc.remove_bedset(inTrunk_moba_1)
        mqc.remove_bedset(outTrunk_moba_temp)
        mqc.remove_bedset(outTrunk_ref_temp)

# We would prefer to run the PCA on 1kg and project MoBa on the eigenvectors but merging is more robust and works just fine.
rule_stem = "mod8_pca_both"
rule mod8_pca_both:
    input:
        bedset_ref = rules.mod8_common_markers_moba_ref.output.bedset_ref,
        bedset_moba = rules.mod8_common_markers_moba_ref.output.bedset_moba,
    output:
        bedset = multiext(str(tmpMod8/rule_stem), '.bed', '.bim', '.fam'),
        pcs = tmpMod8/(rule_stem + ".pcs"),
        eigenvector = tmpMod8/(rule_stem + ".vec"),
        snp_loadings = tmpMod8/(rule_stem + ".load"),
        eigenvalues = tmpMod8/(rule_stem + ".val"),
        variance_explained = tmpMod8/(rule_stem + ".pve"),
    benchmark:
        tmpMod8/(rule_stem + ".benchmark")
    run:
        inTrunk_ref = mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba = mqc.plinkBase(input.bedset_moba[0])
        outTrunk = mqc.plinkBase(output.bedset[0])

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk_ref,
                "--bmerge", inTrunk_moba,
                "--out", outTrunk,
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                flashpca,
                "--bfile", outTrunk,
                "--outpc", output.pcs,
                "--outvec", output.eigenvector,
                "--outload", output.snp_loadings,
                "--outval", output.eigenvalues,
                "--outpve", output.variance_explained,
            ],
            check = True
        )

rule_stem = "mod8_plot_pca_both"
rule mod8_plot_pca_both:
    input:
        pcs = rules.mod8_pca_both.output.pcs,
        pop_map = config["1000_genomes_pop"],
    params:
        title = "\"Principal Component Analysys (PCA) vs. 1 KG\""
    output:
        md_file = github_docs/"pca_1kg_moba.md",
        cluster_file = tmpMod8/"clusters",
        ceu_id_file = tmpMod8/"ceu_core_ids"
    conda:
        "envs/plot_pca_both.yaml"
    threads: 1
    shell:
        """
        Rscript utils/pca/plot_pca_population_cluster_1kg.R \
            {input.pcs} \
            {input.pop_map} \
            {output.md_file} \
            {params.title} \
            {output.cluster_file} \
            {output.ceu_id_file}
        """

rule_stem = "release_md"
rule release_md:
    input:
        pca_md_file = github_docs/"pca_1kg_moba.md",
        relatedness_md_file = github_docs/"mod8_psam_reconstruction.md"
    params:
        docs_folder = github_docs,
        version = config['release']
    output:
        release_md_file = github_docs/"readme.md"
    conda:
        "envs/plot_pca_both.yaml"
    threads: 1
    shell:
        """
        Rscript utils/documentation/release_documentation.R \
            {params.version} \
            {params.docs_folder} \
            "readme.md"
        """

rule_stem = 'release_genotypes'
rule release_genotypes:
    'Copies the genotype files to the release folder.'
    input:
        pgenset_rare_snps = rules.mod8_exclude_conflictual_relationships.output.pgenset_rare_snps,
        pgenset_common_snps = rules.mod8_exclude_conflictual_relationships.output.pgenset_common_snps,
        pgenset_best_snps = rules.mod8_exclude_conflictual_relationships.output.pgenset_best_snps
    params:
        version = config['release']
    output:
        pgenset_rare_snps =  multiext(str(release_folder / (release_base_name + "_rare")), ".pgen", ".pvar", ".psam"),
        pgenset_common_snps =  multiext(str(release_folder / (release_base_name + "_common")), ".pgen", ".pvar", ".psam"),
        pgenset_best_snps =  multiext(str(release_folder / (release_base_name + "_common_best_pruned")), ".pgen", ".pvar", ".psam")
    run:
        try:

            print(f"Writing release genotypes {release_base_name} to {release_folder}.")

            # rare SNPs
            inTrunk =  mqc.plinkBase(input.pgenset_rare_snps[0])
            releaseTrunk =  mqc.plinkBase(output.pgenset_rare_snps[0])
            for extension in ['.pgen', '.pvar', '.psam']:
                print(f"Copying {inTrunk + extension} to {releaseTrunk + extension}")
                copyfile(inTrunk + extension, releaseTrunk + extension)

            # Common SNPs
            inTrunk =  mqc.plinkBase(input.pgenset_common_snps[0])
            releaseTrunk =  mqc.plinkBase(output.pgenset_common_snps[0])
            for extension in ['.pgen', '.pvar', '.psam']:
                print(f"Copying {inTrunk + extension} to {releaseTrunk + extension}")
                copyfile(inTrunk + extension, releaseTrunk + extension)

            # Common best pruned SNPs
            inTrunk =  mqc.plinkBase(input.pgenset_best_snps[0])
            releaseTrunk =  mqc.plinkBase(output.pgenset_best_snps[0])
            for extension in ['.pgen', '.pvar', '.psam']:
                print(f"Copying {inTrunk + extension} to {releaseTrunk + extension}")
                copyfile(inTrunk + extension, releaseTrunk + extension)


        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'release_additional_files'
rule release_additional_files:
    'Copies accompanying files to the release folder.'
    input:
        release_genotypes = rules.release_genotypes.output.pgenset_common_snps,
        r2_table = r2_table, # rules.summarize_dr2.output.r2,
        best_snps = best_hits_table, # rules.summarize_dr2.output.top_snps
        pcs = rules.mod8_pca_both.output.pcs,
        eigenvector = rules.mod8_pca_both.output.eigenvector,
        snp_loadings = rules.mod8_pca_both.output.snp_loadings,
        eigenvalues = rules.mod8_pca_both.output.eigenvalues,
        variance_explained = rules.mod8_pca_both.output.variance_explained,
        cluster_file = rules.mod8_plot_pca_both.output.cluster_file,
        ceu_id_file = rules.mod8_plot_pca_both.output.ceu_id_file,
        king_relatedness = rules.mod8_pedigree_ibd_estimate.output.king_relatedness,
        sex_check = rules.mod8_check_sex.output.sex_check,
        batch_table = rules.mod8_batch_table.output.batch_table
    params:
        version = config['release']
    output:
        r2_table = release_folder/"snp"/(release_base_name + "_snp_r2"),
        best_snps = release_folder/"snp"/(release_base_name + "_reference_500k_snps"),
        pcs = release_folder/"pca"/(release_base_name + ".pcs"),
        eigenvector = release_folder/"pca"/(release_base_name + ".vec"),
        snp_loadings = release_folder/"pca"/(release_base_name + ".load"),
        eigenvalues = release_folder/"pca"/(release_base_name + ".val"),
        variance_explained = release_folder/"pca"/(release_base_name + ".pve"),
        cluster_file = release_folder/"pca"/(release_base_name + "_clusters"),
        ceu_id_file = release_folder/"pca"/(release_base_name + "_ceu_core_ids"),
        king_relatedness = release_folder/"kinship"/(release_base_name + ".kin0"),
        sex_check = release_folder/"sex_check"/(release_base_name + ".sexcheck"),
        batch_table = release_folder/"batch"/(release_base_name + "_batches"),
        readme = release_folder/"readme.md"
    run:
        try:

            print(f"Writing release additional files {release_base_name} to {release_folder}.")

            releaseTrunk =  mqc.plinkBase(input.release_genotypes[0])

            # Housekeeping
            if not os.path.exists(release_folder/"snp"):
                os.makedirs(release_folder/"snp")

            if not os.path.exists(release_folder/"pca"):
                os.makedirs(release_folder/"pca")

            if not os.path.exists(release_folder/"kinship"):
                os.makedirs(release_folder/"kinship")

            if not os.path.exists(release_folder/"sex_check"):
                os.makedirs(release_folder/"sex_check")

            if not os.path.exists(release_folder/"batch"):
                os.makedirs(release_folder/"batch")

            # Readme
            with open(output.readme, 'w') as file:
                file.write("## MoBa Genotypes\n")
                file.write(f"This folder contains genotype files from the [Norwegian Mother, Father and Child Cohort Study (MoBa)](https://www.fhi.no/en/studies/moba/), release version {params.version}\n")
                file.write(f"The genotypes have been quality controlled, imputed, and formatted prior to release. Associated code and documentation can be found at our [repository](https://github.com/fhi-beta/mobaGenetics-qc).\n")
                file.write(f"Please note that filtering of variants and samples has been kept to a minimum. You will find tables next to the genotypes providing information on markers and samples to further filter the data set to your needs.\n")

                file.write(f"### Expected content\n")
                file.write(f"- {os.path.basename(releaseTrunk)}(.pgen, .pvar, .psam): Phased and imputed genotypes in plink2 format. For details on the format please refer to the [plink documentation](https://www.cog-genomics.org/plink/2.0/formats#pgen).\n")
                file.write(f"- snp/{os.path.basename(output.best_snps)}: List of 500k autosomal SNPs with high imputation r2 and pruned for LD.\n")
                file.write(f"- snp/{os.path.basename(output.r2_table)}: Table of imputation r2.\n")
                file.write(f"- pca/{os.path.basename(output.pcs)}: PCs as computed by flashPCA using high quality pruned autosomal markers.\n")
                file.write(f"- pca/{os.path.basename(output.eigenvector)}: Eigen vectoes as computed by flashPCA using high quality pruned autosomal markers.\n")
                file.write(f"- pca/{os.path.basename(output.snp_loadings)}: SNP loadings as computed by flashPCA using high quality pruned autosomal markers.\n")
                file.write(f"- pca/{os.path.basename(output.eigenvalues)}: Eigen values as computed by flashPCA using high quality pruned autosomal markers.\n")
                file.write(f"- pca/{os.path.basename(output.variance_explained)}: Variance explained as computed by flashPCA using high quality pruned autosomal markers.\n")
                file.write(f"- pca/{os.path.basename(output.cluster_file)}: Sample clustering in the PCA with superpopulations from the 1000 genomes project.\n")
                file.write(f"- pca/{os.path.basename(output.ceu_id_file)}: Identifiers of samples of short distance in the PCA to the CEU cluster.\n")
                file.write(f"- kinship/{os.path.basename(output.king_relatedness)}: Kinship analysis as computed by king using high quality pruned autosomal markers.\n")
                file.write(f"- sex_check/{os.path.basename(output.sex_check)}: Sex check computed by plink on sex markers prior to imputation. Warning: the presence of variants on the sex chromosomes varies between genotyping batches.\n")
                file.write(f"- {os.path.basename(output.readme)}: Description of the folder content.\n\n")

                file.write(f"### Help and troubleshooting\n")
                file.write(f"For more information, help, and troubleshooting, please consult our [repository](https://github.com/fhi-beta/mobaGenetics-qc).\n")
                file.write(f"We hope that this release will be useful to you. All our wishes of success in your research.\n")
                file.write(f"Made with love by the [Genetics and Bioinformatics department of the Norwegian Institute of Public Health](https://www.fhi.no/om/organisasjon/genetikk-og-bioinformatikk/).\n")

            # r2 table
            copyfile(input.r2_table, output.r2_table)

            # List of top SNPs
            copyfile(input.best_snps, output.best_snps)

            # PCA files
            copyfile(input.pcs, output.pcs)
            copyfile(input.eigenvector, output.eigenvector)
            copyfile(input.snp_loadings, output.snp_loadings)
            copyfile(input.eigenvalues, output.eigenvalues)
            copyfile(input.variance_explained, output.variance_explained)
            copyfile(input.cluster_file, output.cluster_file)
            copyfile(input.ceu_id_file, output.ceu_id_file)

            # Kinship files
            copyfile(input.king_relatedness, output.king_relatedness)

            # Sex check files
            copyfile(input.sex_check, output.sex_check)

            # Sex batch table
            copyfile(input.batch_table, output.batch_table)


        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

