##
#
# This module generates documentation on qualtity, familial relatedness, sex assignment, and PCA analysis on the merged set of genotypes.
#
##
import os
import gzip
import shutil
import copy

rule_stem = 'mod8_split_rare_common'
rule mod8_split_rare_common:
    'Split the rare from common markers'
    input:
        pgenset = rules.mod7_rename_missing_ids.output.pgenset
    output:
        pgenset_common_snps = multiext(str(tmpMod8 / rule_stem),".pgen",".pvar",".psam"),
        afreq_common_snps = tmpMod8/(rule_stem + '.afreq'),
        common_snps_list = tmpMod8/(rule_stem + ".snplist"),
        pgenset_rare_snps = multiext(str(tmpMod8/rule_stem) + "_rare", ".pgen", ".pvar", ".psam")
    params:
        release_maf_threshold = config['release_maf_thr'],
        mac_threshold = config['merged_set_best_snps_mac_thr']
    run:
        try:

            inTrunk =  mqc.plinkBase(input.pgenset[0])
            outTrunk_rare_snps =  mqc.plinkBase(output.pgenset_rare_snps[0])
            outTrunk_common_snps =  mqc.plinkBase(output.pgenset_common_snps[0])

            print(f"Initial filtering.")

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--mac", str(params.mac_threshold),
                    "--maf", str(params.release_maf_threshold),
                    "--out", outTrunk_common_snps,
                    "--make-pgen",
                    "--write-snplist",
                    "--freq"
                ],
                check=True
            )

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--exclude", output.common_snps_list,
                    "--out", outTrunk_rare_snps,
                    "--make-pgen"
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

chrs_without_par = copy.copy(chrs) # remove PAR since they are not covered in all batches
if 'PAR1' in chrs_without_par:
    chrs_without_par.remove('PAR1')
if 'PAR2' in chrs_without_par:
    chrs_without_par.remove('PAR2')
def get_info_files(wildcards):
    tmpMod6str = str(tmpMod6)
    return [rf"{tmpMod6str}/{batch}/mod6_impute.chr{chr}.imputed.vcf.gz.info" for batch in batches for chr in chrs_without_par]

rule summarize_dr2:
    input:
        info = get_info_files
    output:
        dr2 = str(tmpMod8 / "mod8_dr2.txt.gz")
    threads: 24
    run:
        input_base = str(tmpMod6)
        mqc.summarize_dr2(input_base, output.dr2, batches, chrs_without_par, threads)


rule_stem = 'mod8_common_snps_filter'
rule mod8_common_snps_filter:
    'Select common markers genotyped or with best imputation scores, filter by mac and geno rate'
    input:
        pgenset = rules.mod8_split_rare_common.output.pgenset_common_snps,
        afreq_common_snps = rules.mod8_split_rare_common.output.afreq_common_snps,
        r2_table = rules.summarize_dr2.output.dr2,
        high_ld_regions_hg19 = high_ld_regions_hg19
    output:
        pgenset_common_snps = multiext(str(tmpMod8 / rule_stem),".pgen",".pvar",".psam"),
    params:
        release_hw_threshold = config['release_hw_thr'],
        release_sd_het_threshold = config['release_sd_het_thr'],
        mac_threshold = config['merged_set_best_snps_mac_thr'],
    run:
        try:

            inTrunk =  mqc.plinkBase(input.pgenset[0])
            outTrunk_common =  mqc.plinkBase(output.pgenset_common_snps[0])

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--hardy", "midp",
                    "--read-freq", input.afreq_common_snps,
                    "--out", inTrunk
                ],
                check = True
            )

            mqc.extract_list(
                inTrunk + ".hardy",
                inTrunk + ".exclude",
                threshold_doc_file = inTrunk + ".details",
                sep = None,
                colName = "^MIDP$",
                condition = "<",
                threshold = params.release_hw_threshold,
                key_cols = [1],
                doc_cols = [0, 1]
            )

            mqc.extract_list(
                inTrunk + ".hardy.x",
                inTrunk + "_x.exclude",
                threshold_doc_file = inTrunk + ".details",
                sep = None,
                colName = "^MIDP$",
                condition = "<",
                threshold = params.release_hw_threshold,
                key_cols = [1],
                doc_cols = [0, 1]
            )


            print(f"het.")

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--read-freq", input.afreq_common_snps,
                    "--autosome",
                    "--maf", str(0.01),
                    "--het",
                    "--out",
                    inTrunk
                ],
                check = True
            )

            het_p_values = inTrunk + ".het"
            mqc.compute_excess_het(
                het_p_values,
                inTrunk + "_het.exclude",
                params.release_sd_het_threshold,
                plink1=False
            )

            with open(inTrunk + ".exclude", 'a') as exclude_file:
                with open(inTrunk + "_x.exclude", 'r') as exclude_x_file:
                    exclude_file.write(exclude_x_file.read())
                with open(inTrunk + "_het.exclude", 'r') as exclude_het_file:
                    exclude_file.write(exclude_het_file.read())

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk,
                    "--exclude", inTrunk + ".exclude",
                    "--out", outTrunk_common,
                    "--make-pgen"
                ],
                check = True
            )


        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

rule mod8_best_snps:
    input:
        pgenset = multiext("/mnt/archive3/snpQc/pipeOut_dev/2025.01.30/mod8-release_annotation/mod8_split_rare_common", ".pgen", ".pvar", ".psam"), # rules.mod8_split_rare_common.output.pgenset_common_snps, #rules.mod8_common_snps_filter.output.pgenset_common_snps,
        r2_table = "/mnt/archive3/snpQc/pipeOut_dev/2025.01.30/mod8-release_annotation/mod8_dr2.txt.gz", #rules.summarize_dr2.output.dr2,
        high_ld_regions_hg19 = high_ld_regions_hg19
    output:
        pgenset = multiext(str(tmpMod8_2/"mod8_best_snps"), ".pgen", ".pvar", ".psam"),
        best_pruned_list = str(tmpMod8_2/"mod8_best_snps_pruned.prune.in")
    params:
        release_maf_threshold = config['release_maf_thr'],
        release_hw_threshold = config['release_hw_thr'],
        release_sd_het_threshold = config['release_sd_het_thr'],
        mac_threshold = config['merged_set_best_snps_mac_thr'],
        geno_threshold = config['merged_set_best_snps_geno_thr'],
        info_threshold = config['merged_set_best_snps_info_thr'],
        batch_info_threshold = config['merged_set_best_snps_batch_info_thr'],
        prune_cmd = config["prune_cmd"]
    run:
        inTrunk = mqc.plinkBase(input.pgenset[0])
        outTrunk =  mqc.plinkBase(output.pgenset[0])
        id_file = tmpMod8_2/"ids_best"
        print(f"Extracting markers with overall r2 >= {params.info_threshold} and all batches r2 >= {params.batch_info_threshold}")
        mqc.find_high_dr2_variants(input.r2_table, id_file, params.batch_info_threshold, params.info_threshold)

        temp1 = outTrunk + "_temp1"

        subprocess.run(
            [
                plink2local,
                "--pfile", inTrunk,
                "--extract", id_file,
                "--max-alleles", "2",
                "--mac", str(params.mac_threshold),
                "--geno", str(params.geno_threshold),
                "--out", temp1,
                "--make-pgen"
            ],
            check=True
        )

        temp2 = outTrunk + "_pruned"

        subprocess.run(
            [
                plink2local,
                "--pfile", temp1,
                "--autosome",
                "--exclude", "range", input.high_ld_regions_hg19
            ] + params.prune_cmd.split()   + [
                "--out", temp2
            ],
            check = True
        )

        subprocess.run(
            [
                plink2local,
                "--pfile", temp1,
                "--extract", output.best_pruned_list,
                "--out", outTrunk,
                "--make-pgen"
            ],
            check = True
        )

        mqc.remove_pgenset(temp1)


rule mod8_best_snps_list:
    input:
        dr2 = rules.summarize_dr2.output.dr2,
        pgenset = rules.mod8_best_snps.output.pgenset
    output:
        best_snps_list = tmpMod8_2/'mod8_best_snps_list.txt'
    run:
        mqc.best_snps_of_subset(input.dr2, output.best_snps_list, 500000, input.pgenset[1])


rule_stem = 'mod8_generate_best_snps_stats'
rule mod8_generate_best_snps_stats:
    'Generate statistics on the filtered snps'
    input:
        pgenset = rules.mod8_best_snps.output.pgenset
    output:
        het = tmpMod8_2/'mod8_best_snps.het',
        hardy = tmpMod8_2/'mod8_best_snps.hardy',
        afreq = tmpMod8_2/'mod8_best_snps.afreq',
        smiss = tmpMod8_2/'mod8_best_snps.smiss',
        vmiss = tmpMod8_2/'mod8_best_snps.vmiss',
    threads: 1
    run:
        try:
            # Plink base paths
            plink_input = mqc.plinkBase(input.pgenset[0])
            plink_het_output = mqc.plinkBase(output.het)
            plink_hwe_output = mqc.plinkBase(output.hardy)
            plink_freq_output = mqc.plinkBase(output.afreq)
            plink_miss_output = mqc.plinkBase(output.smiss)

            # Frequencies
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--freq",
                    "--out", plink_freq_output
                ],
                check=True
            )

            # Heterozygocity rate
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--read-freq", output.afreq,
                    "--het",
                    "--out", plink_het_output
                ],
                check=True
            )

            # HWE
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--hardy", "midp",
                    "--read-freq", output.afreq,
                    "--out", plink_hwe_output
                ],
                check=True
            )

            # Missingness
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--read-freq", output.afreq,
                    "--missing",
                    "--out", plink_miss_output
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)




rule_stem = 'mod8_check_sex'
rule mod8_check_sex:
    input:
        pgenset = rules.mod8_split_rare_common.output.pgenset_common_snps #rules.mod8_common_snps_filter.output.pgenset_common_snps
    output:
        sex_check = tmpMod8_2/(rule_stem + ".sexcheck")
    run:
        try:
            in_trunk = mqc.plinkBase(input.pgenset[0])
            out_trunk = mqc.plinkBase(output.sex_check)
            subprocess.run(
                [
                    "plink2",
                    "--pfile", in_trunk,
                    "--chr", "X",
                    "--check-sex", "max-female-xf=0.6", "min-male-xf=0.8",
                    "--out", out_trunk
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

# import ycounts from pre-imputation
rule mod8_import_ycounts:
    input:
        sex_check =  rules.mod8_check_sex.output.sex_check
    output:
        sex_check = tmpMod8_2/"mod8_import_ycounts.sexcheck"
    run:
        ycounts = []
        for batch in batches:
            ycount_file =  f"{tmpMod2}/{batch}/m2_output.sexcheck"
            ycount = pd.read_table(ycount_file, delim_whitespace = True)
            ycounts.append(ycount)
        ycounts_df = pd.concat(ycounts, ignore_index = True)
        sex_check_df = pd.read_table(input.sex_check, dtype={'PEDSEX': 'str', 'SNPSEX': 'str'}, delim_whitespace = True)
        merged_df = pd.merge(sex_check_df, ycounts_df[['IID', 'YCOUNT']], left_on='#IID', right_on='IID', how='left')
        merged_df.drop(columns=['IID'], inplace=True)
        merged_df.to_csv(output.sex_check, sep = "\t", na_rep = "NA", index = False)

def get_fam_per_batch():
    return [f"{tmpMod2}/{batch}/m2_output.fam" for batch in batches]

rule_stem = 'mod8_batch_table'
rule mod8_batch_table:
    'Create a table listing the batch for each sample.'
    input:
        batch_fam = get_fam_per_batch()
    output:
        batch_table = tmpMod8_2/(rule_stem + "_batch")
    run:
        try:

            id_to_batch_dfs = []

            for batch in batches:
                print(f"Importing fam for batch {batch}.")
                file = f"{tmpMod2}/{batch}/m2_output.fam"
                fam = pd.read_table(file, sep = " ", names =["fid", "iid", "mid", "pid", "sex", "pheno"])
                fam['batch'] = batch
                id_to_batch = fam[['iid', 'batch']]
                id_to_batch_dfs.append(id_to_batch)

            merged_df = pd.concat(id_to_batch_dfs, ignore_index = True)

            merged_df.to_csv(output.batch_table, sep='\t', index = False)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'mod8_pedigree_ibd_estimate'
rule mod8_pedigree_ibd_estimate:
    'IBD estimation. Requires conversion to plink1.'
    input:
        pgenset = rules.mod8_best_snps.output.pgenset,
    output:
        king_relatedness = tmpMod8_2/(rule_stem + ".kin0")
    threads: 24
    run:
        try:
            plink_input = mqc.plinkBase(input.pgenset[0])
            plink_input_1 = mqc.plinkBase(input.pgenset[0]) + "_plink1"
            outTrunk = mqc.plinkBase(output.king_relatedness)

            # Convert to plink1
            subprocess.run(
                [
                    plink2local,
                    "--pfile", plink_input,
                    "--make-bed",
                    "--out", plink_input_1
                ],
            )

            # Make FIDs unique to skip within-family computation
            fam_file = plink_input_1 + ".fam"
            fam_data = pd.read_csv(fam_file, sep = "\t", names =["fid", "iid", "mid", "pid", "sex", "pheno"])
            fam_data['fid'] = fam_data['iid']
            fam_data.to_csv(fam_file, index = False, header = False, sep='\t')

            # King relatedness analysis
            subprocess.run(
                [
                    kinglocal,
                    "-b", plink_input_1 + ".bed",
                    "--related",
                    "--cpus", str(threads),
                    "--prefix", outTrunk
                ],
                check = True
            )

            mqc.remove_bedset(plink_input_1)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'mod8_psam_reconstruction'
rule mod8_psam_reconstruction:
    input:
        psam_all_markers = rules.mod8_split_rare_common.output.pgenset_common_snps[2], # rules.mod8_common_snps_filter.output.pgenset_common_snps[2],
        king_relatedness = rules.mod8_pedigree_ibd_estimate.output.king_relatedness,
        sex_check = rules.mod8_import_ycounts.output.sex_check,
        expected_relationships = config['expected_relationships'],
        birth_year = config['birth_year'],
        id_mapping = config['id_mapping']
    params:
        title = "\"Psam file reconstruction\""
    output:
        updated_psam = tmpMod8_2/(rule_stem + ".psam"),
        pedigree_sample_exclusion = tmpMod8_2/(rule_stem + "_pedigree_sample_exclusion"),
        mismatch_information = tmpMod8_2/"mismatch_information.gz",
        mismatch_relationship = tmpMod8_2/"mismatch_relationship.gz",
        md_file = github_docs_2/(rule_stem + ".md")
    conda:
        "envs/r_4.2.yaml"
    threads: 1
    shell:
        """
        Rscript utils/pedigree/simple_psam_reconstruction.R \
            {input.king_relatedness} \
            {input.sex_check} \
            {input.expected_relationships} \
            {input.birth_year} \
            {input.id_mapping} \
            {input.psam_all_markers} \
            {output.updated_psam} \
            {output.pedigree_sample_exclusion} \
            {output.mismatch_information} \
            {output.mismatch_relationship} \
            {output.md_file} \
            {params.title} \
            2
        """

rule_stem = 'mod8_exclude_conflictual_relationships'
rule mod8_exclude_conflictual_relationships:
    input:
        pgenset_common_snps = rules.mod8_split_rare_common.output.pgenset_common_snps, # rules.mod8_common_snps_filter.output.pgenset_common_snps,
        pgenset_rare_snps = rules.mod8_split_rare_common.output.pgenset_rare_snps,
        pgenset_best_snps = rules.mod8_best_snps.output.pgenset,
        pedigree_sample_exclusion = rules.mod8_psam_reconstruction.output.pedigree_sample_exclusion,
        updated_psam = rules.mod8_psam_reconstruction.output.updated_psam
    output:
        pgenset_common_snps =  multiext(str(tmpMod8_2/rule_stem), ".pgen", ".pvar", ".psam"),
        pgenset_rare_snps = multiext(str(tmpMod8_2/(rule_stem + "_rare")), ".pgen", ".pvar", ".psam"),
        pgenset_best_snps = multiext(str(tmpMod8_2/(rule_stem + "_best_snps")), ".pgen", ".pvar", ".psam")
    run:
        try:
            inTrunk_common_markers = mqc.plinkBase(input.pgenset_common_snps[0])
            outTrunk_common_markers = mqc.plinkBase(output.pgenset_common_snps[0])
            inTrunk_rare_markers = mqc.plinkBase(input.pgenset_rare_snps[0])
            outTrunk_rare_markers = mqc.plinkBase(output.pgenset_rare_snps[0])
            inTrunk_best_markers = mqc.plinkBase(input.pgenset_best_snps[0])
            outTrunk_best_markers = mqc.plinkBase(output.pgenset_best_snps[0])

            # Backup original .psam
            copyfile(inTrunk_common_markers + ".psam", inTrunk_common_markers + "_original.psam")
            copyfile(inTrunk_rare_markers + ".psam", inTrunk_rare_markers + "_original.psam")
            copyfile(inTrunk_best_markers + ".psam", inTrunk_best_markers + "_original.psam")

            # Update psam
            copyfile(input.updated_psam, inTrunk_common_markers + ".psam")
            copyfile(input.updated_psam, inTrunk_rare_markers + ".psam")
            copyfile(input.updated_psam, inTrunk_best_markers + ".psam")

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk_common_markers,
                    "--remove", input.pedigree_sample_exclusion,
                    "--out", outTrunk_common_markers,
                    "--make-pgen"
                ],
                check = True
            )

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk_rare_markers,
                    "--remove", input.pedigree_sample_exclusion,
                    "--out", outTrunk_rare_markers,
                    "--make-pgen"
                ],
                check = True
            )

            subprocess.run(
                [
                    plink2local,
                    "--pfile", inTrunk_best_markers,
                    "--remove", input.pedigree_sample_exclusion,
                    "--out", outTrunk_best_markers,
                    "--make-pgen"
                ],
                check = True
            )
            # Restore original .psam
            copyfile(inTrunk_common_markers + "_original.psam", inTrunk_common_markers + ".psam")
            copyfile(inTrunk_rare_markers + "_original.psam", inTrunk_rare_markers + ".psam")
            copyfile(inTrunk_best_markers + "_original.psam", inTrunk_best_markers + ".psam")




        except Exception as e:
                    print(f"An exception occurred in rule {rule}.")
                    print(e)


rule mod8_make_duplicates_table:
    input:
        pgenset = rules.mod8_exclude_conflictual_relationships.output.pgenset_best_snps,
        batches = rules.mod8_batch_table.output.batch_table,
        ids = config['id_mapping'],
        smiss = rules.mod8_generate_best_snps_stats.output.smiss,
    output:
        duplicates = tmpMod8_2/'mod8_make_duplicates_table.txt'
    run:
        psam_file = input.pgenset[2]
        mqc.make_duplicates_table(psam_file, input.batches, input.ids, input.smiss, output.duplicates)



# Reduce 1000 genome markers to the intersection with pruned markers
rule_stem = 'mod8_common_markers_moba_ref'
rule mod8_common_markers_moba_ref:
    input:
        bedset_ref = multiext(config["1000_genomes_stem"], '.bed', '.bim', '.fam'),
        pgenset_moba = rules.mod8_exclude_conflictual_relationships.output.pgenset_best_snps
    output:
        bedset_ref = multiext(str(tmpMod8_2/"pca_ref") ,'.bed','.bim','.fam'),
        bedset_moba = multiext(str(tmpMod8_2/"pca_moba") ,'.bed','.bim','.fam'),
        bedset_only_moba = multiext(str(tmpMod8_2/"pca_only_moba") ,'.bed','.bim','.fam'),
        tri_alleles = tmpMod8_2/(rule_stem + "_tri_alleles.missnp"),
        marker_list = tmpMod8_2/(rule_stem + ".txt")
    benchmark:
        tmpMod8_2/(rule_stem + ".benchmark")

    run:
        inTrunk_ref =  mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba =  mqc.plinkBase(input.pgenset_moba[0])
        outTrunk_ref =  mqc.plinkBase(output.bedset_ref[0])
        outTrunk_moba =  mqc.plinkBase(output.bedset_moba[0])
        outTrunk_only_moba = mqc.plinkBase(output.bedset_only_moba[0])
        #inTrunk_moba_1 = mqc.plinkBase(input.pgenset_moba[0]) + "_plink1"
        outTrunk_ref_temp = outTrunk_ref + "_temp"
        outTrunk_moba_temp = outTrunk_moba + "_temp"
        triallelesTrunk =  mqc.plinkBase(output.tri_alleles)

        # At this stage, 1KG is in plink1 format, MoBa plink2, we convert everything to plink1 for PCA
        subprocess.run(
            [
                plink2local,
                "--pfile", inTrunk_moba,
                "--make-bed",
                "--out", outTrunk_only_moba # inTrunk_moba_1
            ],
        )


        # Common markers found in marker_list
        mqc.intersect_rsid(outTrunk_only_moba + ".bim", inTrunk_ref + ".bim",  output.marker_list)

        # Reduce both sets to the common markers
        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk_ref,
                "--extract", output.marker_list,
                "--out", outTrunk_ref_temp,
                "--allow-extra-chr",
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_only_moba,
                "--extract", output.marker_list,
                "--out", outTrunk_moba_temp,
                "--make-bed"
            ],
            check = True
        )

        # alas these two are not identical enough -
        # discover tri-allele problems by dummy-merging
        # Note that we don't want to abort on plink-failure (as this will be)
        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_ref_temp,
                "--bmerge", outTrunk_moba_temp,
                "--out", triallelesTrunk
            ],
            check = False
        )

        # ... And then remove these markers from both sets
        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_ref_temp,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_ref,
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_moba_temp,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_moba,
                "--make-bed"
            ],
            check = True
        )

        mqc.remove_bedset(outTrunk_moba_temp)
        mqc.remove_bedset(outTrunk_ref_temp)

# We would prefer to run the PCA on 1kg and project MoBa on the eigenvectors but merging is more robust and works just fine.
rule_stem = "mod8_pca_both"
rule mod8_pca_both:
    input:
        bedset_ref = rules.mod8_common_markers_moba_ref.output.bedset_ref,
        bedset_moba = rules.mod8_common_markers_moba_ref.output.bedset_moba,
    output:
        bedset = multiext(str(tmpMod8_2/rule_stem), '.bed', '.bim', '.fam'),
        pcs = tmpMod8_2/(rule_stem + ".pcs"),
        eigenvector = tmpMod8_2/(rule_stem + ".vec"),
        snp_loadings = tmpMod8_2/(rule_stem + ".load"),
        eigenvalues = tmpMod8_2/(rule_stem + ".val"),
        variance_explained = tmpMod8_2/(rule_stem + ".pve"),
    benchmark:
        tmpMod8_2/(rule_stem + ".benchmark")
    run:
        inTrunk_ref = mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba = mqc.plinkBase(input.bedset_moba[0])
        outTrunk = mqc.plinkBase(output.bedset[0])

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk_ref,
                "--bmerge", inTrunk_moba,
                "--out", outTrunk,
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                flashpca,
                "--bfile", outTrunk,
                "--outpc", output.pcs,
                "--outvec", output.eigenvector,
                "--outload", output.snp_loadings,
                "--outval", output.eigenvalues,
                "--outpve", output.variance_explained,
            ],
            check = True
        )
rule_stem = "mod8_pca_only_moba"
rule mod8_pca_only_moba:
    input:
        bedset = rules.mod8_common_markers_moba_ref.output.bedset_only_moba
    output:
        pcs = tmpMod8_2/(rule_stem + ".pcs"),
        eigenvector = tmpMod8_2/(rule_stem + ".vec"),
        snp_loadings = tmpMod8_2/(rule_stem + ".load"),
        eigenvalues = tmpMod8_2/(rule_stem + ".val"),
        variance_explained = tmpMod8_2/(rule_stem + ".pve")
    run:
        inTrunk = mqc.plinkBase(input.bedset[0])
        subprocess.run(
            [
                flashpca,
                "--bfile", inTrunk,
                "--outpc", output.pcs,
                "--outvec", output.eigenvector,
                "--outload", output.snp_loadings,
                "--outval", output.eigenvalues,
                "--outpve", output.variance_explained,
            ],
            check = True
        )


rule_stem = "mod8_plot_pca_both"
rule mod8_plot_pca_both:
    input:
        pcs = rules.mod8_pca_both.output.pcs,
        pcs_only_moba = rules.mod8_pca_only_moba.output.pcs,
        pop_map = config["1000_genomes_pop"],
        ids = config["id_mapping"],
        batches = rules.mod8_batch_table.output.batch_table,
        het = rules. mod8_generate_best_snps_stats.output.het,
        psam = rules.mod8_exclude_conflictual_relationships.output.pgenset_best_snps[2]
    params:
        title = "\"Principal Component Analysys (PCA) vs. 1 KG\"",
        std_het_cutoff = config["release_sd_het_thr"]
    output:
        md_file = github_docs_2/"pca_1kg_moba.md",
        cluster_file = tmpMod8_2/"clusters",
        ceu_id_file = tmpMod8_2/"ceu_core_ids"
    conda:
        "envs/plot_pca_both.yaml"
    threads: 1
    shell:
        """
        Rscript utils/pca/plot_pca_population_cluster_1kg.R \
            {input.pcs} \
            {input.pcs_only_moba} \
            {input.pop_map} \
            {input.het} \
            {output.md_file} \
            {params.title} \
            {output.cluster_file} \
            {output.ceu_id_file} \
            {input.ids} \
            {input.batches} \
            {input.psam} \
            2
        """
        

rule_stem = "release_md"
rule release_md:
    input:
        pca_md_file = github_docs_2/"pca_1kg_moba.md",
        relatedness_md_file = github_docs_2/"mod8_psam_reconstruction.md"
    params:
        docs_folder = github_docs_2,
        version = config['release2']
    output:
        release_md_file = github_docs_2/"readme.md"
    conda:
        "envs/plot_pca_both.yaml"
    threads: 1
    shell:
        """
        Rscript utils/documentation/release_documentation.R \
            {params.version} \
            {params.docs_folder} \
            "readme.md"
        """

rule_stem = 'release_genotypes'
rule release_genotypes:
    'Copies the genotype files to the release folder.'
    input:
        pgenset_rare_snps = rules.mod8_exclude_conflictual_relationships.output.pgenset_rare_snps,
        pgenset_common_snps = rules.mod8_exclude_conflictual_relationships.output.pgenset_common_snps,
        pgenset_best_snps = rules.mod8_exclude_conflictual_relationships.output.pgenset_best_snps
    params:
        version = config['release2']
    output:
        pgenset_rare_snps =  multiext(str(release_folder_2 / (release_base_name + "_rare")), ".pgen", ".pvar", ".psam"),
        pgenset_common_snps =  multiext(str(release_folder_2 / (release_base_name + "_common")), ".pgen", ".pvar", ".psam"),
        pgenset_best_snps =  multiext(str(release_folder_2 / (release_base_name + "_common_best_pruned")), ".pgen", ".pvar", ".psam")
    run:
        try:

            print(f"Writing release genotypes {release_base_name} to {release_folder_2}.")

            # rare SNPs
            inTrunk =  mqc.plinkBase(input.pgenset_rare_snps[0])
            releaseTrunk =  mqc.plinkBase(output.pgenset_rare_snps[0])
            for extension in ['.pgen', '.pvar', '.psam']:
                print(f"Copying {inTrunk + extension} to {releaseTrunk + extension}")
                copyfile(inTrunk + extension, releaseTrunk + extension)

            # Common SNPs
            inTrunk =  mqc.plinkBase(input.pgenset_common_snps[0])
            releaseTrunk =  mqc.plinkBase(output.pgenset_common_snps[0])
            for extension in ['.pgen', '.pvar', '.psam']:
                print(f"Copying {inTrunk + extension} to {releaseTrunk + extension}")
                copyfile(inTrunk + extension, releaseTrunk + extension)

            # Common best pruned SNPs
            inTrunk =  mqc.plinkBase(input.pgenset_best_snps[0])
            releaseTrunk =  mqc.plinkBase(output.pgenset_best_snps[0])
            for extension in ['.pgen', '.pvar', '.psam']:
                print(f"Copying {inTrunk + extension} to {releaseTrunk + extension}")
                copyfile(inTrunk + extension, releaseTrunk + extension)


        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'release_additional_files'
rule release_additional_files:
    'Copies accompanying files to the release folder.'
    input:
        release_genotypes = rules.release_genotypes.output.pgenset_common_snps,
        r2_table = rules.summarize_dr2.output.dr2,
        best_snps = rules.mod8_best_snps_list.output.best_snps_list, # rules.summarize_dr2.output.top_snps
        pcs_with_1000G = rules.mod8_pca_both.output.pcs,
        eigenvector_with_1000G = rules.mod8_pca_both.output.eigenvector,
        snp_loadings_with_1000G = rules.mod8_pca_both.output.snp_loadings,
        eigenvalues_with_1000G = rules.mod8_pca_both.output.eigenvalues,
        variance_explained_with_1000G = rules.mod8_pca_both.output.variance_explained,
        pcs_only_moba = rules.mod8_pca_only_moba.output.pcs,
        eigenvector_only_moba = rules.mod8_pca_only_moba.output.eigenvector,
        snp_loadings_only_moba = rules.mod8_pca_only_moba.output.snp_loadings,
        eigenvalues_only_moba = rules.mod8_pca_only_moba.output.eigenvalues,
        variance_explained_only_moba = rules.mod8_pca_only_moba.output.variance_explained,
        cluster_file = rules.mod8_plot_pca_both.output.cluster_file,
        ceu_id_file = rules.mod8_plot_pca_both.output.ceu_id_file,
        king_relatedness = rules.mod8_pedigree_ibd_estimate.output.king_relatedness,
        sex_check = rules.mod8_check_sex.output.sex_check,
        batch_table = rules.mod8_batch_table.output.batch_table,
        duplicates_table = rules.mod8_make_duplicates_table.output.duplicates
    params:
        version = config['release']
    output:
        r2_table = release_folder_2/"snp"/(release_base_name + "_snp_r2.gz"),
        best_snps = release_folder_2/"snp"/(release_base_name + "_reference_500k_snps"),
        pcs_with_1000G = release_folder_2/"pca_with_1000G"/(release_base_name + ".pcs"),
        eigenvector_with_1000G = release_folder_2/"pca_with_1000G"/(release_base_name + ".vec"),
        snp_loadings_with_1000G = release_folder_2/"pca_with_1000G"/(release_base_name + ".load"),
        eigenvalues_with_1000G = release_folder_2/"pca_with_1000G"/(release_base_name + ".val"),
        variance_explained_with_1000G = release_folder_2/"pca_with_1000G"/(release_base_name + ".pve"),
        pcs_only_moba = release_folder_2/"pca_only_moba"/(release_base_name + ".pcs"),
        eigenvector_only_moba = release_folder_2/"pca_only_moba"/(release_base_name + ".vec"),
        snp_loadings_only_moba = release_folder_2/"pca_only_moba"/(release_base_name + ".load"),
        eigenvalues_only_moba = release_folder_2/"pca_only_moba"/(release_base_name + ".val"),
        variance_explained_only_moba = release_folder_2/"pca_only_moba"/(release_base_name + ".pve"),
        cluster_file = release_folder_2/"pca"/(release_base_name + "_clusters"),
        ceu_id_file = release_folder_2/"pca"/(release_base_name + "_ceu_core_ids"),
        king_relatedness = release_folder_2/"kinship"/(release_base_name + ".kin0"),
        sex_check = release_folder_2/"sex_check"/(release_base_name + ".sexcheck"),
        batch_table = release_folder_2/"batch"/(release_base_name + "_batches"),
        duplicates_table = release_folder_2/"batch"/(release_base_name + "_duplicates"),
        readme = release_folder_2/"readme.md"
    run:
        try:

            print(f"Writing release additional files {release_base_name} to {release_folder_2}.")

            releaseTrunk =  mqc.plinkBase(input.release_genotypes[0])

            # Housekeeping
            if not os.path.exists(release_folder_2/"snp"):
                os.makedirs(release_folder_2/"snp")

            if not os.path.exists(release_folder_2/"pca_with_1000G"):
                os.makedirs(release_folder_2/"pca_with_1000G")

            
            if not os.path.exists(release_folder_2/"pca_only_moba"):
                os.makedirs(release_folder_2/"pca_only_moba")

            if not os.path.exists(release_folder_2/"kinship"):
                os.makedirs(release_folder_2/"kinship")

            if not os.path.exists(release_folder_2/"sex_check"):
                os.makedirs(release_folder_2/"sex_check")

            if not os.path.exists(release_folder_2/"batch"):
                os.makedirs(release_folder_2/"batch")

            # Readme
            with open(output.readme, 'w') as file:
                file.write("## MoBa Genotypes\n")
                file.write(f"This folder contains genotype files from the [Norwegian Mother, Father and Child Cohort Study (MoBa)](https://www.fhi.no/en/studies/moba/), release version {params.version}\n")
                file.write(f"The genotypes have been quality controlled, imputed, and formatted prior to release. Associated code and documentation can be found at our [repository](https://github.com/fhi-beta/mobaGenetics-qc).\n")
                file.write(f"Please note that filtering of variants and samples has been kept to a minimum. You will find tables next to the genotypes providing information on markers and samples to further adjust the data set to your needs.\n")

                file.write(f"### Expected content\n")
                file.write(f"- {os.path.basename(releaseTrunk)}_common(.pgen, .pvar, .psam): Phased and imputed genotypes for common variants in plink2 format (maf: {config['release_maf_thr']}, mac: {config['merged_set_best_snps_mac_thr']}). For details on the format please refer to the [plink documentation](https://www.cog-genomics.org/plink/2.0/formats#pgen).\n")
                file.write(f"- {os.path.basename(releaseTrunk)}_rare(.pgen, .pvar, .psam): Phased and imputed genotypes for rare variants in plink2 format. These genotypes are provided as obtained from the imputation software and should be handled with care.\n")
                file.write(f"- {os.path.basename(releaseTrunk)}_common_best_pruned(.pgen, .pvar, .psam): Phased and imputed genotypes filtered to retain a high quality set of common autosomal variants with LD pruning in plink2 format. These variants are the ones used to compute PCs, adjust for relatedness and population structure.\n")
                file.write(f"- snp/{os.path.basename(output.best_snps)}: List of variants making the high quality set of common autosomal variants with LD pruning used to generate the common_best_pruned fileset.\n")
                file.write(f"- snp/{os.path.basename(output.r2_table)}: Table of imputation r2.\n")
                file.write(f"- pca_with_1000G/{os.path.basename(output.pcs)}: PCs as computed by flashPCA using high quality pruned autosomal markers (with 1000 genomes).\n")
                file.write(f"- pca_with_1000G/{os.path.basename(output.eigenvector)}: Eigen vectors as computed by flashPCA using high quality pruned autosomal markers (with 1000 genomes).\n")
                file.write(f"- pca_with_1000G/{os.path.basename(output.snp_loadings)}: SNP loadings as computed by flashPCA using high quality pruned autosomal markers (with 1000 genomes).\n")
                file.write(f"- pca_with_1000G/{os.path.basename(output.eigenvalues)}: Eigen values as computed by flashPCA using high quality pruned autosomal markers (with 1000 genomes).\n")
                file.write(f"- pca_with_1000G/{os.path.basename(output.variance_explained)}: Variance explained as computed by flashPCA using high quality pruned autosomal markers (with 1000 genomes).\n")
                file.write(f"- pca_only_moba/{os.path.basename(output.pcs)}: PCs as computed by flashPCA using high quality pruned autosomal markers (only MoBa).\n")
                file.write(f"- pca_only_moba/{os.path.basename(output.eigenvector)}: Eigen vectors as computed by flashPCA using high quality pruned autosomal markers (only MoBa).\n")
                file.write(f"- pca_only_moba/{os.path.basename(output.snp_loadings)}: SNP loadings as computed by flashPCA using high quality pruned autosomal markers (only MoBa).\n")
                file.write(f"- pca_only_moba/{os.path.basename(output.eigenvalues)}: Eigen values as computed by flashPCA using high quality pruned autosomal markers (only MoBa).\n")
                file.write(f"- pca_only_moba/{os.path.basename(output.variance_explained)}: Variance explained as computed by flashPCA using high quality pruned autosomal markers (only MoBa).\n")
                file.write(f"- pca_with_1000G/{os.path.basename(output.cluster_file)}: Sample clustering in the PCA with superpopulations from the 1000 genomes project.\n")
                file.write(f"- pca_with_1000G/{os.path.basename(output.ceu_id_file)}: Identifiers of samples of short distance in the PCA to the CEU cluster.\n")
                file.write(f"- kinship/{os.path.basename(output.king_relatedness)}: Kinship analysis as computed by king using high quality pruned autosomal markers.\n")
                file.write(f"- sex_check/{os.path.basename(output.sex_check)}: Sex check computed by plink on sex markers after imputation.\n")
                file.write(f"- batch/{os.path.basename(output.batch_table)}: Batch table\n")
                file.write(f"- batch/{os.path.basename(output.duplicates_table_table)}: Table of duplicate samples with batch, parents' sentrix ids, parents' batches, number of parents in same batch (for children), and call rate\n")
                file.write(f"- {os.path.basename(output.readme)}: Description of the folder content.\n\n")
                file.write(f"### Help and troubleshooting\n")
                file.write(f"For more information, help, and troubleshooting, please consult our [repository](https://github.com/fhi-beta/mobaGenetics-qc).\n")
                file.write(f"We hope that this release will be useful to you. All our wishes of success in your research.\n")
                file.write(f"Made with love by the [Genetics and Bioinformatics department of the Norwegian Institute of Public Health](https://www.fhi.no/om/organisasjon/genetikk-og-bioinformatikk/).\n")

            # r2 table
            with open(input.r2_table, 'rb') as f_in:
                with gzip.open(output.r2_table, 'wb') as f_out:
                    shutil.copyfileobj(f_in, f_out)

            # List of top SNPs
            copyfile(input.best_snps, output.best_snps)

            # PCA files
            copyfile(input.pcs_with_1000G, output.pcs_with_1000G)
            copyfile(input.eigenvector_with_1000G, output.eigenvector_with_1000G)
            copyfile(input.snp_loadings_with_1000G, output.snp_loadings_with_1000G)
            copyfile(input.eigenvalues_with_1000G, output.eigenvalues_with_1000G)
            copyfile(input.variance_explained_with_1000G, output.variance_explained_with_1000G)

            copyfile(input.pcs_only_moba, output.pcs_only_moba)
            copyfile(input.eigenvector_only_moba, output.eigenvector_only_moba)
            copyfile(input.snp_loadings_only_moba, output.snp_loadings_only_moba)
            copyfile(input.eigenvalues_only_moba, output.eigenvalues_only_moba)
            copyfile(input.variance_explained_only_moba, output.variance_explained_only_moba)

            copyfile(input.cluster_file, output.cluster_file)
            copyfile(input.ceu_id_file, output.ceu_id_file)
            

            # Kinship files
            copyfile(input.king_relatedness, output.king_relatedness)

            # Sex check files
            copyfile(input.sex_check, output.sex_check)

            # Sex batch table
            copyfile(input.batch_table, output.batch_table)
            copyfile(input.duplicates_table, output.duplicates_table)


        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

