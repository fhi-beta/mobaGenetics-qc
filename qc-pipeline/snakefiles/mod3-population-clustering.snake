# Generate statistics on raw dataset before anything happens to the data
rule_stem = 'mod3_generate_start_stats'
rule mod3_generate_start_stats:
    input:
        bedset = rules.m2_output.output.bedset
    output:
        het = tmpMod3/"{batch}"/'mod3_start_het.het',
        hwe = tmpMod3/"{batch}"/'mod3_start_hwe.hwe',
        freq = tmpMod3/"{batch}"/'mod3_start_freq.frq',
        lmiss = tmpMod3/"{batch}"/'mod3_start_missing.lmiss',
        imiss = tmpMod3/"{batch}"/'mod3_start_missing.imiss',
    threads: 1
    run:
        try:
            # Plink base paths
            plink_input = mqc.plinkBase(input.bedset[0])
            plink_het_output = mqc.plinkBase(output.het)
            plink_hwe_output = mqc.plinkBase(output.hwe)
            plink_freq_output = mqc.plinkBase(output.freq)
            plink_miss_output = mqc.plinkBase(output.lmiss)

            # Heterozygocity rate
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--het",
                    "--out", plink_het_output
                ],
                check=True
            )

            # HWE
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--hardy",
                    "--out", plink_hwe_output
                ],
                check=True
            )

            # Frequencies
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--freq",
                    "--out", plink_freq_output
                ],
                check=True
            )

            # Missingness
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--missing",
                    "--out", plink_miss_output
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

# Reduce 1000 genome markers to the ones pruned in module 2
rule_stem = 'common_markers_moba_ref'
rule common_markers_moba_ref:
    input:
        bedset_ref = multiext(config["1000_genomes_stem"] ,'.bed','.bim','.fam'),
        bedset_moba = rules.m2_output.output.pruned_bedset
    output:
        bedset_ref = multiext(str(tmpMod3/"{batch}"/"pca_ref") ,'.bed','.bim','.fam'),
        bedset_moba = multiext(str(tmpMod3/"{batch}"/"pca_moba") ,'.bed','.bim','.fam'),
        marker_list = (tmpMod3/"{batch}"/rule_stem).with_suffix(".txt"),
        tri_alleles = report(
            (tmpMod3/"{batch}"/rule_stem).with_suffix(".missnp"),
            category = "Module 3 1000Genomes prep",
            caption = (resultPath/"{batch}"/"pca_ref").with_suffix(".rst")
        ),
        results_moba = report(
            (resultPath/"{batch}"/"pca_moba").with_suffix(".yaml"),
            category = "Module 3 1000Genomes prep",
            caption = (resultPath/"{batch}"/"pca_moba").with_suffix(".rst")
        ),
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk_ref =  mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba =  mqc.plinkBase(input.bedset_moba[0])
        outTrunk_ref =  mqc.plinkBase(output.bedset_ref[0])
        outTrunk_moba =  mqc.plinkBase(output.bedset_moba[0])
        outTrunk_ref_temp = outTrunk_ref + "_temp"
        outTrunk_moba_temp = outTrunk_moba + "_temp"
        triallelesTrunk =  mqc.plinkBase(output.tri_alleles)

        # Common markers found in marker_list
        mqc.intersect_rsid(inTrunk_moba + ".bim", inTrunk_ref + ".bim",  output.marker_list)

        # Reduce both sets to the common markers
        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk_ref,
                "--extract", output.marker_list,
                "--out", outTrunk_ref_temp,
                "--allow-extra-chr",
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk_moba,
                "--extract", output.marker_list,
                "--out", outTrunk_moba_temp,
                "--make-bed"
            ],
            check = True
        )

        # alas these two are not identical enough -
        # discover tri-allele problems by dummy-merging
        # Note that we don't want to abort on plink-failure (as this will be)
        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_ref_temp,
                "--bmerge", outTrunk_moba_temp,
                "--out", triallelesTrunk
            ],
            check = False
        )

        # ... And then remove these markers from both sets
        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_ref_temp,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_ref,
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", outTrunk_moba_temp,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_moba,
                "--make-bed"
            ],
            check = True
        )

        print (f"checking {inTrunk_moba} -> {outTrunk_moba}")
        # Document the reduction for moba
        dropouts = mqc.checkUpdates(
            inTrunk_moba + ".bim",
            outTrunk_moba + ".bim",
            cols = [0, 1, 3, 4, 5],
            sanityCheck = "removal",
            fullList = False,
            allele_flip = True
        )

        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Excluded markers"] = f"Common markers in {output.marker_list}, trialleles removed in {output.tri_alleles}"
        mqc.saveYamlResults(output.results_moba, dropouts)

# We would prefer to run the PCA on 1kg and project MoBa on the eigenvectors but merging is more robust and works just fine.
rule_stem = "pca_both"
rule pca_both:
    input:
        bedset_ref = rules.common_markers_moba_ref.output.bedset_ref,
        bedset_moba = rules.common_markers_moba_ref.output.bedset_moba,
    output:
        bedset = multiext(str(tmpMod3/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        pcs = tmpMod3/"{batch}"/(rule_stem+".pcs"),
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk_ref =  mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba =  mqc.plinkBase(input.bedset_moba[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk_ref,
                "--bmerge", inTrunk_moba,
                "--out", outTrunk,
                "--make-bed"
            ],
            check = True
        )

        subprocess.run(
            [
                flashpca,
                "--bfile", outTrunk,
                "--outpc", output.pcs,
            ],
            check = True
        )


rule_stem = "plot_pca_both"
rule plot_pca_both:
    input:
        pop_map = config["1000_genomes_pop"],       # maps samples to population-groups
        pcs = rules.pca_both.output.pcs,            # principal components
        moba = mqc.plinkBase(rules.common_markers_moba_ref.output.bedset_moba[0]) + ".fam"

    output:
        plot = report((resultPath/"{batch}"/rule_stem).with_suffix(".png"),
                      category="Module 3 Good markers",
                      caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    # force this url into the report
    params: "Legend on https://www.internationalgenome.org/faq/which-populations-are-part-your-study/"
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")
    run:
        # To remove when this goes to mobaQcTools
        pc = pd.read_csv(input.pcs, usecols=['IID','PC1','PC2'], delim_whitespace=True)
        # Populations for colouring -
        pop = pd.read_csv(input.pop_map,usecols=['#IID','SuperPop','Population'],delim_whitespace=True)
        # Simulate population for Moba, read 2-column in fam-file
        popmoba = pd.read_csv(input.moba,usecols=[1], header=None,
                              delim_whitespace=True)
        popmoba.columns = ["#IID"]  # rename to match earlier pop
        moba_legend = '->MoBa'
        popmoba['SuperPop'] = moba_legend
        popmoba['Population'] = moba_legend
        all_pop = pd.concat([pop,popmoba],ignore_index=True)
        merged = pd.merge(left=pc, right=all_pop, left_on='IID', right_on='#IID')
        # mqc.find_moba_pca_outlier(merged[merged.Population=='->MoBa'])
        # Explode Europe to Countries in Population
        merged.loc[merged['SuperPop'] == 'EUR', 'SuperPop'] = 'EUR_'+merged['Population']
        legend_info = params[0]
        # Set up colours   - not using this - did not get it right and dont want to spend time on it
        # colours = {'EUR': 'red',
        #            'EAS': 'darkblue',
        #            'AMR': 'violet',
        #            'SAS': 'orange',
        #            'AFR': 'yellow',
        #            'Moba':'black'}
        popc = "SuperPop"
        # Visualize what will be excluded
        print("SUPERDIRTY PCA EXCLUSION!!!! (visualization for now ...)")
        # rename moba-samples above cut-off
        merged.loc[
            (merged["PC1"]>rules.extract_pca_outliers.params.treshold) &
            (merged[popc]==moba_legend), popc]  +=  "(outlier)"
        p = p9.ggplot(data=merged, mapping=p9.aes(x='PC1',y='PC2',color=popc, shape=popc))
        p +=  p9.geom_point()
        p += p9.scale_colour_brewer(type="qual", palette="Set1")  # better for colourblind
        p9.ggsave(plot=p, filename=output.plot, dpi=600)
        # create the caption usually made by saveYamlResults
        with open(str(resultPath/rule)+".rst", 'w') as file:
            file.write(f'Rule {rule_info[rule]["Rule order"]} ({rule_info[rule]["rule action"]})\n')
            file.write(f"{legend_info}\n")

rule_stem = 'extracted_pca_outliers'
rule extract_pca_outliers:
    input:
        bedset = rules.common_markers_moba_ref.output.bedset_moba,
        pcs = rules.pca_both.output.pcs,            # principal components
        moba = rules.plot_pca_both.input.moba,      # moba samples
    output:
        bedset=multiext(str(tmpMod3/"{batch}"/rule_stem)
                          ,'.bed','.bim','.fam'),
        exclude_list = (tmpMod3/"{batch}"/rule_stem).with_suffix(".txt"),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    params:
        treshold = -0.05752391   # Stupid and visual - for now
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        mqc.log(runlog, "PCA exlude {item_type} ({params.treshold})\n")

        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        pca_treshold = params.treshold
        pc = pd.read_csv(input.pcs, usecols=['IID','PC1','PC2'],delim_whitespace=True)
        # List (only) moba samples that pca-wise are too spread
        mobasamples = pd.read_csv(input.moba,usecols=[0,1], header=None,
                                  delim_whitespace=True)
        mobasamples.columns = ["FID","IID"]
        # keep just moba-samples
        moba_pca = pd.merge(left=pc, right=mobasamples, left_on='IID', right_on='IID')

        # This is a superdirty hack to exclude the same number of samples as
        # was excluded by the hapmap pca. Must be replace by a sensible function
        # Samples to exclude found put in output.excludelist
        print("SUPERDIRTY PCA EXCLUSION!!!!")
        moba_pca.loc[(moba_pca.PC1 > params.treshold)].to_csv(output.exclude_list,
                columns=['FID','IID'],index=False, header=False, sep = ' ')

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--remove", output.exclude_list,
                "--out", outTrunk,
                "--make-bed" ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",
                                    cols = [0,1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)