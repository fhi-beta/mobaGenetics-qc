# Generate statistics on raw dataset before anything happens to the data
rule_stem = 'mod2_generate_start_stats'
rule mod2_generate_start_stats:
    input:
        bedset = rules.m1_output.output.bedset
    output:
        het = tmpMod2/"{batch}"/'mod2_start_het.het',
        hwe = tmpMod2/"{batch}"/'mod2_start_hwe.hwe',
        freq = tmpMod2/"{batch}"/'mod2_start_freq.frq',
        lmiss = tmpMod2/"{batch}"/'mod2_start_missing.lmiss',
        imiss = tmpMod2/"{batch}"/'mod2_start_missing.imiss',
    threads: 1
    run:
        try:
            # Plink base paths
            plink_input = mqc.plinkBase(input.bedset[0])
            plink_het_output = mqc.plinkBase(output.het)
            plink_hwe_output = mqc.plinkBase(output.hwe)
            plink_freq_output = mqc.plinkBase(output.freq)
            plink_miss_output = mqc.plinkBase(output.lmiss)

            # Heterozygocity rate
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--het",
                    "--out", plink_het_output
                ],
                check=True
            )

            # HWE
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--hardy",
                    "--out", plink_hwe_output
                ],
                check=True
            )

            # Frequencies
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--freq",
                    "--out", plink_freq_output
                ],
                check=True
            )

            # Missingness
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--missing",
                    "--out", plink_miss_output
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'maf_removal_markers'
rule maf_removal_markers:
    input:
        bedset = rules.m1_output.output.bedset,
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem), '.bed','.bim','.fam'),
        callrate_sample = tmpMod2/"{batch}"/(rule_stem + '.imiss'),
        callrate_marker = tmpMod2/"{batch}"/(rule_stem + '.lmiss'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        plot = report(
            resultPath/"{batch}"/(rule_stem + ".png"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    params:
        threshold = config['pedigree_maf_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, f"Initial cleaning: Low minor allele frequencies removal (--maf {params.threshold})\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--maf", str(params.threshold),
                    "--out", outTrunk,
                    "--make-bed"
                ],
                check=True
            )
            dropouts = mqc.checkUpdates(
                inTrunk+".bim",
                outTrunk+".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip=True
            )
            dropouts.update(rule_info[rule])
            dropouts["Threshold"] = params.threshold
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

            # call rates for maf will be maf_removal_markers.output.bedset imiss and lmiss
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", outTrunk,
                    "--missing",
                    "--out", outTrunk
                ],
                check=True
            )

            mqc.plot_point_and_line(
                dropouts,
                output.callrate_marker,
                output.plot,
                column = "F_MISS",
                ylabel = "1 - missingness"
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'missing_genotype_samples'
rule missing_genotype_samples:
    input:
        bedset = rules.maf_removal_markers.output.bedset
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/(rule_stem + ".rst")
        )
    params:
        threshold = config['pedigree_mind_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, f"Missing genotype {item_type} (--mind {params.threshold})\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            # First extract temporary samples based on earlier filtered markers (maf_removal_markers)
            # Next these will be used to extract samples permanently (rule clean_samples:)
            mqc.missing_genotype_rate(
                rule,
                inTrunk,
                outTrunk,
                sample = True,
                threshold = params.threshold,
                result_file = output.results
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = "callrate_permanent_removal"
rule callrate_permanent_removal:
    input:
        mod1_bedset = rules.m1_output.output.bedset,
        bedset = rules.missing_genotype_samples.output.bedset,
        callrate_sample = rules.maf_removal_markers.output.callrate_sample
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem),'.bed','.bim','.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        plot = report(
            resultPath/"{batch}"/(rule_stem + ".png"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    run:
        try:
            oldPermTrunk =  mqc.plinkBase(input.mod1_bedset[0])
            inTrunk =  mqc.plinkBase(input.bedset[0])
            permTrunk =  mqc.plinkBase(output.bedset[0])

            # PERMANENT removal of very-missing individuals from FULL dataset
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", oldPermTrunk,
                    "--keep", inTrunk + ".fam",
                    "--out", permTrunk,
                    "--make-bed"
                ],
                check = True
            )

            dropouts = mqc.checkUpdates(
                oldPermTrunk + ".fam",
                permTrunk + ".fam",
                cols = [0, 1],
                sanityCheck = "removal",
                fullList = True
            )

            dropouts.update(rule_info[rule])
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

            # call rates for samples were previously computed,
            # we now know how many actually got cut
            mqc.plot_point_and_line(
                dropouts,
                input.callrate_sample,
                output.plot,
                column = "F_MISS",
                ylabel = "1 - missingness"
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'missing_genotype_markers'
rule missing_genotype_markers:
    input:
        bedset = rules.missing_genotype_samples.output.bedset
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        plot = report(
            resultPath/"{batch}"/(rule_stem + ".png"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    params:
        threshold = config['geno_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, f"Missing genotype {item_type} (--geno {params.threshold})\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            dropouts = mqc.missing_genotype_rate(
                rule,
                inTrunk,
                outTrunk,
                sample = False,
                threshold = params.threshold,
                result_file = output.results,
                plot_file = output.plot
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'exclude_unplaced_and_non_autosomal_markers'
rule exclude_unplaced_and_non_autosomal_markers:
    input:
        bedset = rules.missing_genotype_markers.output.bedset
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, f"Excluded unplaced and non-autosomal {item_type} (--autosome)\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--autosome",
                    "--out", outTrunk,
                    "--make-bed"
                ],
                check = True
            )

            dropouts = mqc.checkUpdates(
                inTrunk + ".bim",
                outTrunk + ".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )
            dropouts.update(rule_info[rule])
            dropouts["Rule"] = rule

            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'hardy_weinberg_filtered_markers'
rule hardy_weinberg_filtered_markers:
    input:
        bedset = rules.exclude_unplaced_and_non_autosomal_markers.output.bedset
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed','.bim','.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        plot = report(
            resultPath/"{batch}"/(rule_stem + ".png"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    params:
        threshold = config['pedigree_hwe_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, "Missing Hardy-Weinberg filtering {item_type} (--hwe {params.threshold})\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])

            mqc.low_hwe_rate(
                rule,
                inTrunk,
                outTrunk,
                threshold = params.threshold,
                hwe_switches = ["--hardy"],
                result_file = output.results,
                plot_file = output.plot
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'exclude_strand_ambigious_markers'
rule exclude_strand_ambigious_markers:
    input:
        bedset = rules.hardy_weinberg_filtered_markers.output.bedset
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem) , '.bed', '.bim', '.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, "Excluding ambigious {item_type} (GC/CG/AT/TA)\n")
            inTrunk = mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])

            mqc.exclude_strand_ambigious_markers(inTrunk, outTrunk, plinklocal)
            dropouts = mqc.checkUpdates(
                inTrunk + ".bim",
                outTrunk+".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )

            dropouts.update(rule_info[rule])
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'exclude_high_ld_markers'
rule exclude_high_ld_markers:
    input:
        bedset = rules.exclude_strand_ambigious_markers.output.bedset,
        high_ld_regions_hg19 = config["high_ld_regions_hg19"]
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed' ,'.bim' ,'.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--exclude", "range", input.high_ld_regions_hg19,
                    "--out", outTrunk,
                    "--make-bed"
                ],
                check = True
            )

            dropouts = mqc.checkUpdates(
                inTrunk + ".bim",
                outTrunk + ".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )

            dropouts.update(rule_info[rule])
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'mod2_prune_markers'
rule mod2_prune_markers:
    input:
        bedset = rules.exclude_high_ld_markers.output.bedset,
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        pruned_list = tmpMod2/"{batch}"/(rule_stem + ".prune.in"),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    params:
        prune_cmd = config["prune_cmd"]
    run:
        try:

            item_type = rule_info[rule]["rule type"]
            print("DEBUG1")
            mqc.log(runlog, rule_info[rule]["QC test"])
            print("DEBUG2")
            inTrunk = mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])
            print("DEBUG3")

            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--make-founders"
                ] + params.prune_cmd.split() + [
                        "--out", outTrunk
                ],
                check = True
            )

            subprocess.run(
                [
                    plinklocal,
                            "--bfile", inTrunk,
                            "--extract", output.pruned_list,
                            "--out", outTrunk,
                            "--make-bed"
                ],
                check = True
            )

            dropouts = mqc.checkUpdates(
                inTrunk + ".bim",
                outTrunk + ".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )
            dropouts.update(rule_info[rule])
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'check_sex'
rule check_sex:
    input:
        in_geno = rules.missing_genotype_markers.output.bedset
    output:
        sex_check = tmpMod2/"{batch}"/(rule_stem + ".sexcheck"),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inGenoTrunk = mqc.plinkBase(input.in_geno[0])

            subprocess.run(
                [
                    plinklocal,
                            "--bfile", inGenoTrunk,
                            "--check-sex", "ycount",
                            "--out", mqc.plinkBase(output.sex_check)
                ],
                check = True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'ibd_prune'
rule ibd_prune:
    input:
        in_geno = rules.missing_genotype_markers.output.bedset,
        clean_snps = rules.mod2_prune_markers.output.pruned_list
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed','.bim','.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inGenoTrunk = mqc.plinkBase(input.in_geno[0])
            outTrunk = mqc.plinkBase(output.bedset[0])

            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inGenoTrunk,
                    "--extract", input.clean_snps,
                    "--out", outTrunk,
                    "--make-bed"
                ],
                check = True
            )

            dropouts = mqc.checkUpdates(
                inGenoTrunk + ".bim",
                outTrunk + ".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "remove",
                fullList = True,
                allele_flip = True
            )
            dropouts.update(rule_info[rule])
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'pedigree_ibd_estimate'
rule pedigree_ibd_estimate:
    input:
        in_geno = rules.ibd_prune.output.bedset,
    params:
        king_prefix = tmpMod2/"{batch}"/rule_stem,
    output:
        king_relatedness = tmpMod2/"{batch}"/(rule_stem + ".relatedness"),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 2 Core samples and pedigree inference",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    threads: 8
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            outTrunk = mqc.plinkBase(output.bedset[0])

            subprocess.run(
                [
                    kinglocal,
                    "-b", input.in_geno[0],
                    "--related",
                    "--cpus", str(threads),
                    "--prefix", outTrunk
                ],
                check = True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'm2_output'
rule m2_output:
    input:
        bedset_m1 = rules.m1_output.output.bedset,
        bedset_all_markers = rules.callrate_permanent_removal.output.bedset,
        bedset_pruned_markers = rules.ibd_prune.output.bedset,
        pruned_snps = rules.mod2_prune_markers.output.pruned_list,
        sex_check = rules.check_sex.output.sex_check,
        king_relatedness = rules.pedigree_ibd_estimate.output.king_relatedness,
    output:
        mod2_bedset =  multiext(str(tmpMod2/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        mod2_pruned_bedset = multiext(str(tmpMod2/"{batch}"/(rule_stem + "_pruned")), '.bed', '.bim', '.fam'),
        pruned_snps = tmpMod2/"{batch}"/(rule_stem + ".prune.in"),
        sex_check = tmpMod2/"{batch}"/(rule_stem + ".sexcheck"),
        king_relatedness = tmpMod2/"{batch}"/(rule_stem + ".relatedness"),
        report_markers = report(
            resultPath/"{batch}"/(rule_stem + ".markers.yaml"),
            category = "- Module 2 Pedigree fix recap",
            caption = resultPath/"{batch}"/(rule_stem + ".markers.rst")
        ),
        report_samples = report(
            resultPath/"{batch}"/(rule_stem + ".samples.yaml"),
            category = "- Module 2 Pedigree fix recap",
            caption = resultPath/"{batch}"/(rule_stem + ".samples.rst")
        )
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            m1Trunk = mqc.plinkBase(input.bedset_m1[0])
            inTrunk_all_markers = mqc.plinkBase(input.bedset_all_markers[0])
            outTrunk_all_markers =  mqc.plinkBase(output.mod2_bedset[0])
            inTrunk_pruned_markers = mqc.plinkBase(input.bedset_pruned_markers[0])
            outTrunk_pruned_markers =  mqc.plinkBase(output.mod2_pruned_bedset[0])
            docs = "For more documentation see https://github.com/folkehelseinstituttet/mobaGenetics-qc/wiki/Module2 . In the html file see info on individual module steps through the section for results of Module 2"

            # copy bedsets
            for extension in ['.bed', '.bim']:
                copyfile(inTrunk_all_markers + extension, outTrunk_all_markers + extension)
                copyfile(inTrunk_pruned_markers + extension, outTrunk_pruned_markers + extension)

            # Copy new fam files
            # @TODO: update once triads are fixed
            copyfile(inTrunk_all_markers + ".fam", outTrunk_all_markers + ".fam")
            copyfile(inTrunk_pruned_markers + ".fam", outTrunk_pruned_markers + ".fam")

            # Copy other outcomes of the module
            copyfile(input.prunedsnps, output.prunedsnps)
            copyfile(input.genome, output.genome)
            copyfile(input.sex_check, output.sex_check)

            # report markers (we only do this for mod5 output aka outTrunk_all_markers)
            dropouts = mqc.checkUpdates(
                m1Trunk + ".bim",
                outTrunk_all_markers + ".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )
            dropouts.update(rule_info[rule])
            dropouts["Rule"] = rule
            dropouts["Documentation details"] = docs
            mqc.saveYamlResults(output.report_markers, dropouts)

            # report samples, same logic as markers
            dropouts = mqc.checkUpdates(
                m1Trunk + ".fam",
                outTrunk_all_markers + ".fam",
                cols = [0, 1],
                sanityCheck = "update",
                fullList = True
            )
            dropouts.update(rule_info[rule])
            dropouts["Rule"] = rule
            dropouts["Documentation details"] = docs

            mqc.saveYamlResults(output.report_samples, dropouts)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

