
# Generate statistics on raw dataset before anything happens to the data
rule_stem = 'generate_start_stats'
rule generate_start_stats:
    input:
        bedset = rules.m1_output.output.bedset
    output:
        het = tmpMod2/"{batch}"/'mod2_start_het.het',
        hwe = tmpMod2/"{batch}"/'mod2_start_hwe.hwe',
        freq = tmpMod2/"{batch}"/'mod2_start_freq.frq',
        lmiss = tmpMod2/"{batch}"/'mod2_start_missing.lmiss',
        imiss = tmpMod2/"{batch}"/'mod2_start_missing.imiss',
    threads: 1
    run:
        try:
            # Plink base paths
            plink_input = mqc.plinkBase(input.bedset[0])
            plink_het_output = mqc.plinkBase(output.het)
            plink_hwe_output = mqc.plinkBase(output.hwe)
            plink_freq_output = mqc.plinkBase(output.freq)
            plink_miss_output = mqc.plinkBase(output.lmiss)

            # Heterozygocity rate
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--het",
                    "--out", plink_het_output
                ],
                check=True
            )

            # HWE
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--hardy",
                    "--out", plink_hwe_output
                ],
                check=True
            )

            # Frequencies
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--freq",
                    "--out", plink_freq_output
                ],
                check=True
            )

            # Missingness
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--missing",
                    "--out", plink_miss_output
                ],
                check=True
            )

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


rule_stem = 'maf_removal_markers'
rule maf_removal_markers:   #Minor allele frequencies removal
    input:
        bedset = rules.m1_output.output.bedset,
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem), '.bed','.bim','.fam'),
        callrate_sample = (tmpMod2/"{batch}"/rule_stem).with_suffix('.imiss'),
        callrate_marker = (tmpMod2/"{batch}"/rule_stem).with_suffix('.lmiss'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{batch}"/rule_stem).with_suffix(".png"),
                      category="Module 2 Core samples and infere pedigree",
                      caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    params:
        treshold = config['maf_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, "Initial cleaning: Low minor allele frequencies removal(--maf)\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            subprocess.run([plinklocal,
                    "--bfile",inTrunk,
                    "--maf", str(params.treshold),
                    "--out", outTrunk,      # previously named superclean_maf
                    "--make-bed" ], check=True)
            dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",
                                        cols = [0,1,3,4,5],
                                        sanityCheck = "removal",
                                        fullList = True, allele_flip=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Treshold"] = params.treshold
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

            # call rates for maf will be maf_removal_markers.output.bedset imiss and lmiss
            # these will be reused later
            subprocess.run([plinklocal,
                    "--bfile", outTrunk,
                    "--missing",
                    "--out", outTrunk ], check=True)

            mqc.plot_point_and_line(dropouts, output.callrate_marker, output.plot,
                                    column="F_MISS",ylabel="1 - missingness")

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


rule_stem = 'missing_genotype_samples'
rule missing_genotype_samples:
    input:
        bedset = rules.maf_removal_markers.output.bedset
    output:
        # bedset earlier called superclean_maf_mind
        bedset=multiext(str(tmpMod2/"{batch}"/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    params:
        treshold = config['mind_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, "Missing genotype {item_type} (--mind)\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])
            # First extract temporary samples based on earlier filtered markers (maf_removal_markers)
            # Next these will be used to extract samples permanently (rule clean_samples:)
            mqc.missing_genotype_rate(rule,
                            inTrunk, outTrunk, sample=True, treshold=params.treshold,
                            result_file=output.results)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


rule_stem = "callrate_permanent_removal"
rule callrate_permanent_removal:
    input:
        # This is for permanent removal - samples from module1
        mod1_bedset = rules.m1_output.output.bedset,
        # bedset is samples we removed at last stage, and where markers have been
        # temorary removed
        bedset = rules.missing_genotype_samples.output.bedset,
        # While this are callrates we computed at the --maf stage, while removing markers
        callrate_sample = rules.maf_removal_markers.output.callrate_sample
    output:
        bedset=multiext(str(tmpMod2/"{batch}"/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{batch}"/rule_stem).with_suffix(".png"),
                      category="Module 2 Core samples and infere pedigree",
                      caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))

    run:
        try:
            oldPermTrunk =  mqc.plinkBase(input.mod1_bedset[0])   # what we had
            inTrunk =  mqc.plinkBase(input.bedset[0])        # what we temporary filtered markers on
            permTrunk =  mqc.plinkBase(output.bedset[0])     # what we are making

            # PERMANENT removal of very-missing individuals from FULL dataset
            subprocess.run([plinklocal,
                    "--bfile",oldPermTrunk,
                    "--keep",inTrunk + ".fam", # keeping those samples that just passed the --mind threshold
                    "--out", permTrunk,        # earlier called full_mind
                    "--make-bed" ], check=True)
            dropouts = mqc.checkUpdates(oldPermTrunk+".fam", permTrunk+".fam",
                                        cols = [0,1],
                                        sanityCheck = "removal",
                                        fullList = True)

            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

            # call rates for samples were previously computed,
            # we now know how many actually got cut
            mqc.plot_point_and_line(dropouts, input.callrate_sample, output.plot,
                                    column="F_MISS",ylabel="1 - missingness")

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


rule_stem = 'missing_genotype_markers' # used for outputfilenames
rule missing_genotype_markers:
    input:
        # This is based on earlier temporary filters - the same that we used to remember samples permanently
        bedset = rules.missing_genotype_samples.output.bedset
    output:
        bedset=multiext(str(tmpMod2/"{batch}"/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{batch}"/rule_stem).with_suffix(".png"),
                      category="Module 2 Core samples and infere pedigree",
                      caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    params:
        treshold = config['geno_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, "Missing genotype {item_type} (--geno)\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            dropouts = mqc.missing_genotype_rate(rule,
                            inTrunk, outTrunk, sample=False, treshold=params.treshold,
                            result_file=output.results,
                            plot_file=output.plot)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


rule_stem = 'tmp_exclude_non-autosomal+unplaced_markers' # used for outputfilenames
rule exclude_unplaced_and_non_autosomal_markers:
    input:
        # This is based on earlier temporary filters - the same that we used to remember samples permanently
        bedset = rules.missing_genotype_markers.output.bedset
    output:
        bedset = multiext(str(tmpMod2/"{batch}"/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, "Excluded unplaced and non-autosomal {item_type} (--autosome)\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])
            subprocess.run([plinklocal,
                    "--bfile",inTrunk,
                    "--autosome",                     # identifies markers
                    "--out", outTrunk,                # called superclean_autosomal
                    "--make-bed" ], check=True)

            dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",
                                        cols = [0,1,3,4,5],
                                        sanityCheck = "removal",
                                        fullList = True, allele_flip=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule

            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


rule_stem = 'tmp_hwe_filtered_markers' # used for outputfilenames
rule hardy_weinberg_filtered_markers:
    input:
        # This is based on earlier temporary filters - the same that we used to remember samples permanently
        bedset = rules.exclude_unplaced_and_non_autosomal_markers.output.bedset
    output:
        bedset=multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed','.bim','.fam'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{batch}"/rule_stem).with_suffix(".png"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    params:
        treshold = config['hwe_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, "Missing Hardy-Weinberg filtering {item_type} (--hwe)\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])

            mqc.low_hwe_rate(rule, inTrunk, outTrunk, treshold=params.treshold,
                         hwe_switches = ["--hardy"],
                         result_file = output.results, plot_file=output.plot)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)

rule_stem = 'tmp_excluded_strand_amb_markers' # used for outputfilenames
rule exclude_strand_ambigious_markers:
    input:
        # This is based on earlier temporary filters
        bedset = rules.hardy_weinberg_filtered_markers.output.bedset
    output:
        bedset=multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed','.bim','.fam'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, "Excluding ambigious {item_type} (GC/CG/AT/TA\n")
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            mqc.exclude_strand_ambigious_markers(inTrunk, outTrunk, plinklocal)
            dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",
                                        cols=[0,1,3,4,5],
                                        sanityCheck="removal", fullList = True,
                                        allele_flip=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)

rule_stem = 'tmp_high_ld_excluded_markers' # used for outputfilenames
rule exclude_high_ld_markers:
    input:
        # This is based on earlier temporary filters
        bedset = rules.exclude_strand_ambigious_markers.output.bedset,
        high_ld_regions_hg19 = config["high_ld_regions_hg19"]
    output:
        bedset=multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed','.bim','.fam'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])


            subprocess.run([plinklocal,
                    "--bfile",inTrunk,
                    "--exclude", "range", input.high_ld_regions_hg19,    # identifies markers
                    "--out", outTrunk,                                   # called superclean_no_ag_ct_ld before
                    "--make-bed"  ], check=True)

            dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",
                                        cols=[0,1,3,4,5],
                                        sanityCheck="removal",
                                        fullList=True, allele_flip=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


rule_stem = 'tmp_prune_markers' # used for outputfilenames
rule prune_markers:
    input:
        # This is based on earlier temporary filters
        bedset = rules.exclude_high_ld_markers.output.bedset,
    output:
        bedset=multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed','.bim','.fam'),
        exclude_list = (tmpMod2/"{batch}"/rule_stem).with_suffix(".prune.in"),  # called prune_markers_tmp.prune.in before. Will be used both in a temporary pass, but also during final core-set generation
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    params:
        prune_cmd = config["prune_cmd"].split()    # As plink will want a list

    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            subprocess.run([plinklocal,
                    "--bfile", inTrunk,
                    "--make-founders",
                    "--out", outTrunk]    # no bed-file prodused, just .prune.in (exclude_list)
                    + params.prune_cmd , check=True)  # note that we here add a list to another list ...


            subprocess.run([plinklocal,
                    "--bfile", inTrunk,
                    "--extract", output.exclude_list,
                    "--out", outTrunk,                  # called superclean_pruned before
                    "--make-bed" ], check=True)

            dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",
                                        cols=[0,1,3,4,5],
                                        sanityCheck="removal", fullList=True,
                                        allele_flip=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


rule_stem = 'pedigree_ibd_estimate' # used for outputfilenames
rule pedigree_ibd_estimate:
    input:
        in_geno = rules.missing_genotype_markers.output.bedset,
        in_all= rules.callrate_permanent_removal.output.bedset,
        clean_snps = rules.prune_markers.output.exclude_list
    output:
        bedset=multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed','.bim','.fam'),
        genome = (tmpMod2/"{batch}"/rule_stem).with_suffix(".genome"),
        inferpedx = tmpMod2/"{batch}/inferpedx.sexcheck",
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))

    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inGenoTrunk =  mqc.plinkBase(input.in_geno[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

        # plink will recommend sex assignments based on X het and Y calls
            subprocess.run([plinklocal,
                    "--bfile", inGenoTrunk,
                    "--check-sex", "ycount",
                    "--out", mqc.plinkBase(output.inferpedx)  ], check=True) # local stem: don't want to overwrite logfiles

            # get PIHAT estimates
            subprocess.run([plinklocal,
                    "--bfile", inGenoTrunk,
                    "--extract", input.clean_snps,
                    "--genome", "--min", "0.10",                 # not parametrized for now
                    "--out", outTrunk,                           # called inferped_pruned before
                    "--make-bed" ], check=True)

            dropouts = mqc.checkUpdates(inGenoTrunk+".bim", outTrunk+".bim",
                                        cols=[0,1,3,4,5],
                                        sanityCheck="remove", fullList=True,
                                        allele_flip=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)


# This rule is still in shell-syntax as we have not decided what the final solution should be.
# We would like to automate the triad-patching - but anyway the repair of triad/sample-mixes should be done outside this module.
rule pedigree_fu_detector_solver:
    input:
        in_geno = rules.missing_genotype_markers.output.bedset,
        in_all = rules.callrate_permanent_removal.output.bedset,
        ped_pruned = rules.pedigree_ibd_estimate.output.bedset,
        ped_pruned_pihat = rules.pedigree_ibd_estimate.output.genome,
        ped_sexcheck = rules.pedigree_ibd_estimate.output.inferpedx
    output:
        # A list of samples that have passed sanitycheck
        # TRUE in this file is OK, FALSE is not
        pheno_ok_flags = tmpMod2/'{batch}/phenotypesOK.txt',
        # A better family file will be used later
        # In this file a fixed family has changed ID from n to n_i
        # Samples with phono_ok_falgs=FALSE, will have family ID prblm<count>
        Rfixed_fam = tmpMod2/"{batch}/inferped_updated.fam",
    params:
        outdir = tmpMod2,
        resdir = resultPath,
	    inferfam = config['infer_recfam'],
	    inferbad = config['infer_badids']

    shell:
        """
        set -x
        # lets use trunks to mimic earlier behaviour by extracting truncs from input/output
        foo={input.in_geno[0]}
        inGenoTrunk=${{foo%\.*}}
        foo={input.in_all[0]}
        inAllTrunk=${{foo%\.*}}
        foo={input.ped_pruned[0]}
        pedPrunedTrunk=${{foo%\.*}}

        # There used to be a column extractor here, but it didn't work so gutorm removed it
        # the .genome file is not tab-separated). Remove this after test/confirm
 	# cut -f 2,4,8,10 input.ped_pruned_pihat > output.ped_pruned_pihat
        # We use the input.ped_pruned_pihat directlry in the R script later

	# # ERROR if fam files were different for PRUNED and ALL markers (can't update then)
       	diff $inAllTrunk.fam $pedPrunedTrunk.fam

	# R script for updating fam file
	# 1. input fam file
	# 2. pihat file
	# 3. PLINK's sexcheck results
	# 4. /media/local-disk2/helgeland/rotterdam1/inferred-pedigree/permanent_reconstruct-fam.txt
	# 5. /media/local-disk2/helgeland/rotterdam1/inferred-pedigree/permanent_bad-sample-IIDs.txt
	# 6. inferped_data.RData
	# 7. updated fam file  - The one we will later use
	# 8. flag file for individuals/samples
	Rscript {libdir}/inferped_FuckupDetectorAndSolver.R \
	    $pedPrunedTrunk.fam \
	    {input.ped_pruned_pihat} \
	    {input.ped_sexcheck} \
	    {params.inferbad} \
	    {params.inferfam} \
	    {params.resdir}/inferped_data.RData \
	    {output.Rfixed_fam} \
	    {output.pheno_ok_flags}

        """

# Note the rule stem does not match the rule here, as the results are from the previous rule
rule_stem = "pedigree_fu_detector_solver"
rule document_pedigree_fu_detector_solver:
    input:
        bedset = mqc.plinkBase(rules.pedigree_fu_detector_solver.input.ped_pruned[0]) + ".fam",
        fam_fix = rules.pedigree_fu_detector_solver.output.Rfixed_fam
    output: # Note that rst-path is copied in the run: body
        result = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        # File with families/samples we didnt manage to fix
        problems = report((resultPath/"{batch}"/rule_stem).with_suffix(".prblm"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        # The families we fixed
        fixed = report((resultPath/"{batch}"/rule_stem).with_suffix(".fix"),
                         category="Module 2 Core samples and infere pedigree",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        
    run:
        try:
            mqc.log(runlog, rule_info[rule]["QC test"])
            rst_file = (resultPath/"pedigree_fu_detector_solver").with_suffix(".rst")
            # During fu_detector, we left trace about problematic triads naming the families *prblm
            mqc.egrep('prblm', input.fam_fix, output.problems)
            mqc.egrep('^[0-9]+_i', input.fam_fix, output.fixed)

            dropouts = mqc.checkUpdates(input.bedset, input.fam_fix,
                                        cols = [0,1],
                                        sanityCheck="update", fullList=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            dropouts["Description"] += f" Fixed family rows found in {output.fixed} while problems are found in {output.problems}"

            # But we need more info about this strange rule
            # so we add stuff to it
            # We count mono, duo and triplets in the fam
            # file, but only if the family-id starts with a
            # number. Problematic items are called prblmxxx and wont match
            probs = mqc.line_count(output.problems)
            fixes = mqc.line_count(output.fixed)
            fams = mqc.count_families(input.fam_fix, "^\d+")
            msg = (f"Of the original {dropouts['in']} samples, {probs} are marked problematic\n"
                   f"{fams[1]} of the families contain 1 member\n"
                   f"{fams[2]} of the families contain 2 members\n"
                   f"{fams[3]} of the families contain 3 members\n"
                   f"Predigree fixed families have _i appended to their family-number file ({fixes} samples)\n")
            dropouts["Details"] = msg
            mqc.saveYamlResults(output.result, dropouts)
            # Now append to what saveYamlResults put in rst file
            with open(rst_file, "a") as f:
                f.write(msg)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)

# This recaps and show what happens in Modules 2. It permits the
# module to have some 'public' variables, that other rules can refer
# to.  It also ensure that snakemake --report is easer to read.
# The rule will rename/copy some files made previously.
rule_stem = 'm2_output'
rule m2_output:
    input:
        # End of module 1
        bedset_m1 = rules.m1_output.output.bedset,
        # We will tweak on the results of fu_detector
        fam_fix = rules.pedigree_fu_detector_solver.output.Rfixed_fam,
        bedset_all_markers = rules.callrate_permanent_removal.output.bedset,
        bedset_pruned_markers = rules.pedigree_fu_detector_solver.input.ped_pruned,
        problems = rules.document_pedigree_fu_detector_solver.output.problems,
        # To visualize/formalize that this is a reusable result
        prunedsnps = rules.prune_markers.output.exclude_list
    output:
        # Tagged to show who these are
        # This is the real output of mod2. It will be combined with good markers from a later module
        bedset =  multiext(str(tmpMod2/"{batch}"/'inferped_all_m2'),'.bed','.bim','.fam'),
        # This is a party pruned set, that mod3 will continue to prune
        mod3_bedset =  multiext(str(tmpMod2/"{batch}"/'inferped_pruned_m2'),'.bed','.bim','.fam'),
        # category is sorted as written below. We use - as prefix to force
        # final reports to be sorted first ...
        # We only report for mod5 results (where all markers kept)
        report_markers = report((resultPath/"{batch}"/rule_stem).with_suffix(".markers.yaml"),
                                category="- Module 2 Pedigree fix recap",
                                caption=(resultPath/"{batch}"/rule_stem).with_suffix(".markers.rst")),
        report_samples = report((resultPath/"{batch}"/rule_stem).with_suffix(".samples.yaml"),
                                category="- Module 2 Pedigree fix recap",
                                caption=(resultPath/"{batch}"/rule_stem).with_suffix(".samples.rst"))
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            m1Trunk =  mqc.plinkBase(input.bedset_m1[0])
            inTrunk_all_markers = mqc.plinkBase(input.bedset_all_markers[0])
            outTrunk_all_markers =  mqc.plinkBase(output.bedset[0])
            inTrunk_pruned_markers = mqc.plinkBase(input.bedset_pruned_markers[0])
            outTrunk_pruned_markers =  mqc.plinkBase(output.mod3_bedset[0])
            docs = "For more documentation see https://github.com/folkehelseinstituttet/mobaGenetics-qc/wiki/Module2 . In the html file see info on individual module steps through the section for results of Module 2"

            # Create new bedsets with the new pedigree/.fam
        # # produce bedset with ALL markers and INFERRED family info
        # produce/modify bedset with PRUNED markers by replacing earlier .fam file with fixed one
        # (inferped_pruned.bed and .bim were made by previous rule)

            for i in ['.bed', '.bim']:
                # the full markerset
                copyfile(inTrunk_all_markers+i, outTrunk_all_markers+i)
                # markers (temporarily removed)
                copyfile(inTrunk_pruned_markers+i, outTrunk_pruned_markers+i)
            # However, fam-file is new as made by pedigree_fu_detector_solver:
                copyfile(input.fam_fix, outTrunk_all_markers+".fam")
                copyfile(input.fam_fix, outTrunk_pruned_markers+".fam")

            # report markers (we only do this for mod5 output aka outTrunk_all_markers
            dropouts = mqc.checkUpdates(m1Trunk+".bim",
                                        outTrunk_all_markers+".bim",
                                        cols=[0,1,3,4,5],
                                        sanityCheck="removal",
                                        fullList=True, allele_flip=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            dropouts["Documentation details"] = docs
            mqc.saveYamlResults(output.report_markers, dropouts)

            # report samples, same logic as markers
            dropouts = mqc.checkUpdates(m1Trunk+".fam",
                                        outTrunk_all_markers+".fam",
                                        cols=[0,1],
                                        sanityCheck="update", fullList=True)
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            dropouts["Documentation details"] = docs

            mqc.saveYamlResults(output.report_samples, dropouts)

        except Exception as e:
            template = f"An exception occured in rule {rule_stem}."
            print(e)

