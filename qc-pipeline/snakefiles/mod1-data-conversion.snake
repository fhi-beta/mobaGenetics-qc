##
#
# This module removes chromosome zero, filters based on clustering and information from genome studio, and removes duplicate SNPs.
#
##

from datetime import datetime

# Paths
raw_folder_path = Path(config['raw_folder'])

rule_stem = 'remove_chr0'
rule remove_chr0:
    input:
        bedset = multiext(str(raw_folder_path/"{batch}"/"raw-data"/"bedset"/"{batch}"), '.bed', '.bim', '.fam'),
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 1 Data preparation",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    threads: 1
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inTrunk = mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])

            subprocess.run(
                [
                    plinklocal,
                    "--bfile",inTrunk,
                    "--not-chr", "0",
                    "--out", outTrunk,
                    "--make-bed"
                ],
                check=True
            )

            # Checking how many markers/chromosone 0 we removed  on this step
            # We turn of warning here as we know there might be duplicate markers to check for later
            dropouts = mqc.checkUpdates(
                inTrunk +".bim",
                outTrunk +".bim",
                cols = [0, 1, 3, 4, 5],
                indx = 1,
                sanityCheck = "none",
                fullList = True,
                allele_flip = True
            )

            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule

            mqc.saveYamlResults(output.results, dropouts)
            mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - (NSNP_CHR0_LOST) Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} chromosone 0 out of {dropouts["in"]}, leaving {dropouts["out"]} markers\n')

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


# Generate statistics on raw dataset before anything happens to the data
rule_stem = 'mod1_generate_start_stats'
rule mod1_generate_start_stats:
    input:
        bedset = rules.remove_chr0.output.bedset
    output:
        het = tmpMod1/"{batch}"/'mod1_start_het.het',
        hwe = tmpMod1/"{batch}"/'mod1_start_hwe.hwe',
        freq = tmpMod1/"{batch}"/'mod1_start_freq.frq',
        lmiss = tmpMod1/"{batch}"/'mod1_start_missing.lmiss',
        imiss = tmpMod1/"{batch}"/'mod1_start_missing.imiss',
    threads: 1
    run:
        try:
            # Plink base paths
            plink_input = mqc.plinkBase(input.bedset[0])
            plink_het_output = mqc.plinkBase(output.het)
            plink_hwe_output = mqc.plinkBase(output.hwe)
            plink_freq_output = mqc.plinkBase(output.freq)
            plink_miss_output = mqc.plinkBase(output.lmiss)

            # Heterozygocity rate
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--het",
                    "--out", plink_het_output
                ],
                check=True
            )

            # HWE
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--hardy",
                    "--out", plink_hwe_output
                ],
                check=True
            )

            # Frequencies
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--freq",
                    "--out", plink_freq_output
                ],
                check=True
            )

            # Missingness
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--missing",
                    "--out", plink_miss_output
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


# Check for duplicate markers, and remove all but one (keep best callrate)
# The code here is copied and reused in remove_dup_markers_1kg
# This rule could be smarter in the case no duplicate markers are found
rule_stem = 'remove_duplicate_markers'
rule remove_duplicate_markers:
    input:
        bedset = rules.remove_chr0.output.bedset,
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        excludeList = tmpMod1/"{batch}"/(rule_stem + ".txt"),
        resultDetails = resultPath/"{batch}"/(rule_stem + ".csv"),
        # plink hardcodes this
        plink_dup_list = tmpMod1/"{batch}"/"plink.dupvar",
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 1 Data preparation",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        )
    params:
        details = resultPath/"{batch}"/(rule_stem + ".yaml.details")
    threads: 1
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inTrunk = mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])
            callRateTrunk = mqc.plinkBase(output.excludeList)
            batch_wd = os.path.join(tmpMod1, wildcards.batch)
            print(batch_wd)
            # Create a plink.dupvar file
            # Plink-bug (1.90b5.4): Puts plink.dupvar in snakemake directory, so we change the working directory.
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--list-duplicate-vars"
                ],
                check = True,
                cwd = batch_wd
            )

            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--out", callRateTrunk,
                    "--missing"
                ],
                check = True
            )

            mqc.create_exclude_list(
                output.plink_dup_list,
                callRateTrunk + ".lmiss",
                output.resultDetails,
                output.excludeList
            )

            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--exclude", output.excludeList,
                    "--out", outTrunk,
                    "--make-bed"
                ],
                check=True
            )

            dropouts = mqc.checkUpdates(
                inTrunk + ".bim",
                outTrunk + ".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )
            dropouts["Callrates"] = output.resultDetails

            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)
            mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Due to duplicate markers, removed {dropouts["actionTakenCount"]} markers out of {dropouts["in"]}, leaving {dropouts["out"]} markers\n')

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

# If a snp_table was provided with the batch, remove markers on snp table metrics, otherwise leave as is.
rule_stem = 'remove_markers_cluster_sep'
rule remove_markers_cluster_sep:
    input:
        bedset = rules.remove_duplicate_markers.output.bedset,
        snptable = lambda wildcards: getSnpTable(wildcards.batch)
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 1 Data preparation",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        plot = report(
            resultPath/"{batch}"/(rule_stem + ".png"),
            category = "Module 1 Data preparation",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        # in addition to the removal list .txt, a *removal.txt.samples is produced, sporting only the sample-list
        removal= tmpMod1/"{batch}"/(rule_stem + ".txt"),
        removal_markers = tmpMod1/"{batch}"/(rule_stem + ".markers.txt"),
    params:
        threshold = config['cluster_sep_thr']
    message: "mod1 Remove markers by cluster metrics"
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inTrunk = mqc.plinkBase(input.bedset[0])
            outTrunk = mqc.plinkBase(output.bedset[0])

            column_name = getClusterSeparationColumn(wildcards.batch)

            if input.snptable != "utils/dummy":

                # identify markers for removal on cluster separation
                (removed, total) = mqc.extract_list(
                    input.snptable,
                    output.removal_markers,
                    output.removal,
                    colName = column_name,
                    sep = '\t',
                    condition = "<",
                    threshold = params.threshold,
                    key_cols = [0],
                    doc_cols = [0]
                )

                subprocess.run(
                    [
                        plinklocal,
                        "--bfile", inTrunk,
                        "--exclude", output.removal_markers,
                        "--out", outTrunk ,
                        "--make-bed"
                    ],
                    check = True
                )

                dropouts = mqc.checkUpdates(
                    inTrunk + ".bim",
                    outTrunk +".bim",
                    cols = [0, 1, 3, 4, 5],
                    sanityCheck = "removal",
                    fullList = True,
                    allele_flip = True
                )
                dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
                dropouts["Threshold"] = params.threshold
                dropouts["Rule"] = rule
                mqc.saveYamlResults(output.results, dropouts)

                mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} markers(NSNP_CLUSTERSEP_LOST) out of {dropouts["in"]} (BEFORE_SNPTABLE), leaving {dropouts["out"]} markers. Treshhold {params.threshold}\n')

                mqc.plot_point_and_line(
                    dropouts,
                    input.snptable,
                    output.plot,
                    column_name,
                    separator = '\t',
                    ylabel = "Separation",
                    invert = False
                )

            else:

                # Nothing to do for this batch
                mqc.copy_bedset(inTrunk,outTrunk)

                dropouts = mqc.checkUpdates(
                    inTrunk + ".bim",
                    outTrunk +".bim",
                    cols = [0, 1, 3, 4, 5],
                    sanityCheck = "removal",
                    fullList = True,
                    allele_flip = True
                )
                dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
                dropouts["Threshold"] = params.threshold
                dropouts["Rule"] = rule
                mqc.saveYamlResults(output.results, dropouts)

                mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} markers(NSNP_CLUSTERSEP_LOST) out of {dropouts["in"]} (BEFORE_SNPTABLE), leaving {dropouts["out"]} markers. Treshhold {params.threshold}\n')

                # Create empty output to document that no sample/marker have been removed
                sample = open(outFile, "w+").close()
                subset = open(threshold_doc_file, "w+").close()
                mqc.plot_text(
                    "No table for this batch",
                    output.plot
                ) 

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

rule_stem = 'remove_markers_gc_score'
rule remove_markers_gc_score:
    input:
        bedset = rules.remove_markers_cluster_sep.output.bedset,
        snptable = lambda wildcards: getSnpTable(wildcards.batch)
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 1 Data preparation",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        plot = report(
            resultPath/"{batch}"/(rule_stem + ".png"),
            category = "Module 1 Data preparation",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal= tmpMod1/"{batch}"/(rule_stem + ".txt"),
        removal_markers = tmpMod1/"{batch}"/(rule_stem + ".markers.txt"),
    params:
        threshold = config['10%_GC_score_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])

            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            # identify markers for removal
            (removed, total) = mqc.extract_list(
                input.snptable,
                output.removal_markers,
                output.removal,
                colName = config["10%_GC_score_col_name"],
                sep = '\t',
                condition = "<",
                threshold = params.threshold,
                key_cols=[0],
                doc_cols=[0]
            )
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--exclude", output.removal_markers,
                    "--out", outTrunk,
                    "--make-bed"
                ],
                check = True
            )

            dropouts = mqc.checkUpdates(
                inTrunk + ".bim",
                outTrunk + ".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Threshold"] = params.threshold
            dropouts["Rule"] = rule
            mqc.saveYamlResults(output.results, dropouts)

            mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} markers(NSNP_GC_LOST) out of {dropouts["in"]} (NSNP_BEFORE_GC), leaving {dropouts["out"]} markers. Treshhold {params.threshold}\n')

            mqc.plot_point_and_line(
                dropouts,
                input.snptable,
                output.plot,
                config["10%_GC_score_col_name"],
                separator = '\t',
                ylabel = "10% GC Score",
                invert = False
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


rule_stem = 'remove_markers_aa_theta_deviation'
rule remove_markers_aa_theta_deviation:
    input:
        bedset = rules.remove_markers_gc_score.output.bedset,
        snptable = lambda wildcards: getSnpTable(wildcards.batch)
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            resultPath/"{batch}"/(rule_stem + ".yaml"),
            category = "Module 1 Data preparation",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        plot = report(
            resultPath/"{batch}"/(rule_stem + ".png"),
            category = "Module 1 Data preparation",
            caption = resultPath/"{batch}"/(rule_stem + ".rst")
        ),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal = tmpMod1/"{batch}"/(rule_stem + ".txt"),
        removal_markers = tmpMod1/"{batch}"/(rule_stem + ".markers.txt"),
    params:
        threshold = config['aa_theta_dev_thr']
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            inTrunk =  mqc.plinkBase(input.bedset[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])

            # identify markers for removal
            column_name = getAaThetaDevColumn(wildcards.batch)
            (removed,total) = mqc.extract_list(
                input.snptable,
                output.removal_markers,
                output.removal,
                colName = column_name,
                sep = '\t',
                condition = ">",
                threshold = params.threshold,
                key_cols = [0],
                doc_cols = [0]
            )

            subprocess.run(
                [
                    plinklocal,
                    "--bfile", inTrunk,
                    "--exclude", output.removal_markers,
                    "--out", outTrunk,
                    "--make-bed"
                ],
                check = True
            )

            dropouts = mqc.checkUpdates(
                inTrunk+".bim",
                outTrunk+".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Threshold"] = params.threshold
            dropouts["Rule"] = rule

            mqc.saveYamlResults(output.results, dropouts)
            mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} markers(NSNP_AATHETADEV_LOST) out of {dropouts["in"]} (NSNP_GC_LOST), leaving {dropouts["out"]} markers. Treshhold {params.threshold}\n')

            mqc.plot_point_and_line(
                dropouts,
                input.snptable,
                output.plot,
                column_name,
                separator = '\t',
                ylabel = "AA-\u03B8 deviation",
                invert = False
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

rule_stem = 'm1_output'
rule m1_output:
    input:
        # Start of pipe
        bedset_first = rules.remove_chr0.input.bedset,
        # Note that this is actually the output of module 1, this rule is just a report rule
        bedset_last = rules.remove_markers_aa_theta_deviation.output.bedset,
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        # Category is sorted as written below.
        # We use - as prefix to force final reports to be sorted first.
        report_markers = report(
            resultPath/"{batch}"/(rule_stem + ".markers.yaml"),
            category = "- Module 1 Data conversion recap",
            caption = resultPath/"{batch}"/(rule_stem + ".markers.rst")
        ),
        report_samples = report(
            resultPath/"{batch}"/(rule_stem + ".samples.yaml"),
            category = "- Module 1 Data conversion recap",
            caption = resultPath/"{batch}"/(rule_stem + ".samples.rst")
        ),
    run:
        try:
            item_type = rule_info[rule]["rule type"]
            mqc.log(runlog, rule_info[rule]["QC test"])
            firstTrunk =  mqc.plinkBase(input.bedset_first[0])
            lastTrunk =  mqc.plinkBase(input.bedset_last[0])
            outTrunk =  mqc.plinkBase(output.bedset[0])
            docs = "For more documentation see https://github.com/folkehelseinstituttet/mobaGenetics-qc/wiki/Module1 . In the html file see info on individual module steps through the section for results of Module 1 Data preparation"

            # Create a dummy bedset we can refer to later that clearly show module1 output
            for i in ['.bed','.bim','.fam']:
                copyfile(lastTrunk+i, outTrunk+i)

            # report markers
            dropouts = mqc.checkUpdates(
                firstTrunk + ".bim",
                outTrunk + ".bim",
                cols = [0, 1, 3, 4, 5],
                sanityCheck = "removal",
                fullList = True,
                allele_flip = True
            )
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            dropouts["Documentation details"] = docs

            mqc.saveYamlResults(output.report_markers, dropouts)

            # report samples
            dropouts = mqc.checkUpdates(
                firstTrunk + ".fam",
                outTrunk + ".fam",
                cols = [0, 1],
                sanityCheck = "update",
                fullList = True
            )
            dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
            dropouts["Rule"] = rule
            dropouts["Documentation details"] = docs

            mqc.saveYamlResults(output.report_samples, dropouts)

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)


