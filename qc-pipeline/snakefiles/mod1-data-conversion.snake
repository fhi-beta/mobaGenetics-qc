# Rule updates raw bedset with biobank provided pedigree information and gender
# Sample IDs are updated to SentrixIDs
import os.path
from datetime import datetime

rule_stem = 'remove_chr0'
rule remove_chr0:
    input:
        bedset = multiext(os.path.join(config['raw_folder'], "{batch}", "raw-data", "bedset", "{batch}"), '.bed', '.bim', '.fam'),
    output:
        bedset = multiext(os.path.join(tmpMod1, "{batch}", rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            os.path.join(resultPath, "{batch}", rule_stem + ".yaml"),
            category = "Module 1 Data preparation",
            caption = os.path.join(resultPath, "{batch}", rule_stem + ".rst")
        )
    threads: 1
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk = mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.bedset[0])

        subprocess.run(
            [
                plinklocal,
                "--bfile",inTrunk,
                "--not-chr", "0",
                "--out", outTrunk,
                "--make-bed"
            ],
            check=True
        )

        # Checking how many markers/chromosone 0 we removed  on this step
        # We turn of warning here as we know there might be duplicate markers to check for later
        dropouts = mqc.checkUpdates(
            inTrunk +".bim",
            outTrunk +".bim",
            cols = [0, 1, 3, 4, 5],
            indx = 1,
            sanityCheck = "none",
            fullList = True,
            allele_flip = True
        )

        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule

        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - (NSNP_CHR0_LOST) Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} chromosone 0 out of {dropouts["in"]}, leaving {dropouts["out"]} markers\n')


# Generate statistics on raw dataset before anything happens to the data
rule generate_raw_stats:
    input:
        bedset = rules.remove_chr0.output.bedset
    output:
        het = str(tmpMod1/"{batch}"/'mod1_start_het.het'),
        hwe = str(tmpMod1/"{batch}"/'mod1_start_hwe.hwe'),
        freq = str(tmpMod1/"{batch}"/'mod1_start_freq.frq'),
        lmiss = str(tmpMod1/"{batch}"/'mod1_start_missing.lmiss'),
        imiss = str(tmpMod1/"{batch}"/'mod1_start_missing.imiss'),
    threads: 1
    run:

        print(f"start {input.bedset[0]}")
        print(f"plink {plinkBase(input.bedset[0])}")
        print(f"plink {plinkBase(output.het)}")
        # Heterozygocity rate
        subprocess.run(
            [
                plinklocal,
                "--bfile", plinkBase(input.bedset[0]),
                "--het",
                "--out", plinkBase(output.het)
            ],
            check=True
        )

        # HWE
        subprocess.run(
            [
                plinklocal,
                "--bfile", plinkBase(input.bedset[0]),
                "--hardy",
                "--out", plinkBase(output.hwe)
            ],
            check=True
        )

        # Frequencies
        subprocess.run(
            [
                plinklocal,
                "--bfile", plinkBase(input.bedset[0]),
                "--freq",
                "--out", plinkBase(output.freq)
            ],
            check=True
        )

        # Missingness
        subprocess.run(
            [
                plinklocal,
                "--bfile", plinkBase(input.bedset[0]),
                "--missing",
                "--out", plinkBase(output.lmiss)
            ],
            check=True
        )
        print("end")

# Check for duplicate markers, and remove all but one (keep best callrate)
# The code here is copied and reused in remove_dup_markers_1kg
# This rule could be smarter in the case no duplicate markers are found
rule_stem = 'remove_duplicate_markers'
rule remove_duplicate_markers:
    input:
        bedset = rules.remove_chr0.output.bedset,
        imiss = str(tmpMod1/"{batch}"/'mod1_start_missing.imiss'),
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        excludeList = (tmpMod1/"{batch}"/rule_stem).with_suffix(".txt"),
        resultDetails = (resultPath/"{batch}"/rule_stem).with_suffix(".csv"),
        # plink hardcodes this
        plink_dup_list = (tmpMod1/"{batch}"/"plink").with_suffix(".dupvar"),
        results = report(
            (resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
            category = "Module 1 Data preparation",
            caption = (resultPath/"{batch}"/rule_stem).with_suffix(".rst")
        )
    params:
        details = (resultPath/"{batch}"/rule_stem).with_suffix(".yaml.details")
    threads: 1
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk = mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.bedset[0])
        callRateTrunk = mqc.plinkBase(output.excludeList)
        batch_wd = os.path.join(tmpMod1, wildcards.batch)
        print(batch_wd)
        # Create a plink.dupvar file
        # Plink-bug (1.90b5.4): Puts plink.dupvar in snakemake directory, so we change the working directory.
        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk,
                "--list-duplicate-vars"
            ],
            check = True,
            cwd = batch_wd
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk,
                "--out", callRateTrunk,
                "--missing"
            ],
            check = True
        )

        mqc.create_exclude_list(
            output.plink_dup_list,
            callRateTrunk + ".lmiss",
            output.resultDetails,
            output.excludeList
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk,
                "--exclude", output.excludeList,
                "--out", outTrunk,
                "--make-bed"
            ],
            check=True
        )

        dropouts = mqc.checkUpdates(
            inTrunk + ".bim",
            outTrunk + ".bim",
            cols = [0, 1, 3, 4, 5],
            sanityCheck = "removal",
            fullList = True,
            allele_flip = True
        )
        dropouts["Callrates"] = output.resultDetails

        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Due to duplicate markers, removed {dropouts["actionTakenCount"]} markers out of {dropouts["in"]}, leaving {dropouts["out"]} markers\n')


# Remove markers on snp table metrics
rule_stem = 'remove_markers_cluster_sep'
rule remove_markers_cluster_sep:
    input:
        bedset = rules.remove_duplicate_markers.output.bedset,
        snptable = lambda wildcards: getSnpTable(wildcards.batch),
    output:
        bedset = multiext(os.path.join(tmpMod1, "{batch}", rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            os.path.join(resultPath, "{batch}", rule_stem + ".yaml"),
            category = "Module 1 Data preparation",
            caption = os.path.join(resultPath, "{batch}", rule_stem + ".rst")
        ),
        plot = report(
            os.path.join(resultPath, "{batch}", rule_stem + ".png"),
            category = "Module 1 Data preparation",
            caption = os.path.join(resultPath, "{batch}", rule_stem + ".rst")
        ),
        # in addition to the removal list .txt, a *removal.txt.samples is produced, sporting only the sample-list
        removal= os.path.join(tmpMod1, "{batch}", rule_stem + ".txt"),
        removal_markers = os.path.join(tmpMod1, "{batch}", rule_stem + ".markers.txt"),
    params:
        treshold = config['cluster_sep_thr']
    message: "mod1 Remove markers by cluster metrics"
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk = mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.bedset[0])

        # identify markers for removal on cluster separation
        (removed,total) = mqc.extract_list(
            input.snptable,
            output.removal_markers, output.removal,
            colName = config['cluster_sep_col_name'],
            sep = '\t',
            condition = "<",
            treshold = params.treshold,
            key_cols = [0],
            doc_cols = [0]
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk ,
                "--make-bed"
            ],
            check = True
        )

        dropouts = mqc.checkUpdates(
            inTrunk + ".bim",
            outTrunk +".bim",
            cols = [0, 1, 3, 4, 5],
            sanityCheck = "removal",
            fullList = True,
            allele_flip = True
        )
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

        mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} markers(NSNP_CLUSTERSEP_LOST) out of {dropouts["in"]} (BEFORE_SNPTABLE), leaving {dropouts["out"]} markers. Treshhold {params.treshold}\n')
        # The following has a huge potential for speedup (using round as in mqc.dotplot()
        mqc.plot_point_and_line(
            dropouts,
            input.snptable,
            output.plot,
            config["cluster_sep_col_name"],
            separator = '\t',
            ylabel = "Separation",
            invert = False
        )


rule_stem = 'remove_markers_gc_score'
rule remove_markers_gc_score:
    input:
        bedset = rules.remove_markers_cluster_sep.output.bedset,
        snptable = lambda wildcards: getSnpTable(wildcards.batch)
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            (resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
            category = "Module 1 Data preparation",
            caption = (resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        plot = report(
            (resultPath/"{batch}"/rule_stem).with_suffix(".png"),
            category = "Module 1 Data preparation",
            caption = (resultPath/"{batch}"/rule_stem).with_suffix(".rst")
        ),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal= (tmpMod1/"{batch}"/rule_stem).with_suffix(".txt"),
        removal_markers = (tmpMod1/"{batch}"/rule_stem).with_suffix(".markers.txt"),
    params:
        treshold = config['10%_GC_score_thr']
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        # identify markers for removal 
        (removed,total) = mqc.extract_list(
            input.snptable,
            output.removal_markers,
            output.removal,
            colName = config["10%_GC_score_col_name"],
            sep = '\t',
            condition = "<",
            treshold = params.treshold,
            key_cols=[0],
            doc_cols=[0]
        )
        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk,
                "--make-bed"
            ],
            check = True
        )

        dropouts = mqc.checkUpdates(
            inTrunk + ".bim",
            outTrunk + ".bim",
            cols = [0, 1, 3, 4, 5],
            sanityCheck = "removal",
            fullList = True,
            allele_flip = True
        )
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

        mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} markers(NSNP_GC_LOST) out of {dropouts["in"]} (NSNP_BEFORE_GC), leaving {dropouts["out"]} markers. Treshhold {params.treshold}\n')

        mqc.plot_point_and_line(
            dropouts,
            input.snptable,
            output.plot,
            config["10%_GC_score_col_name"],
            separator = '\t',
            ylabel = "10% GC Score",
            invert = False
        )



rule_stem = 'remove_markers_aa_theta_deviation'
rule remove_markers_aa_theta_deviation:
    input:
        bedset = rules.remove_markers_gc_score.output.bedset,
        snptable = lambda wildcards: getSnpTable(wildcards.batch)
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        results = report(
            (resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
            category = "Module 1 Data preparation",
            caption = (resultPath/"{batch}"/rule_stem).with_suffix(".rst")
        ),
        plot = report(
            (resultPath/"{batch}"/rule_stem).with_suffix(".png"),
            category = "Module 1 Data preparation",
            caption = (resultPath/"{batch}"/rule_stem).with_suffix(".rst")
        ),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal = (tmpMod1/"{batch}"/rule_stem).with_suffix(".txt"),
        removal_markers = (tmpMod1/"{batch}"/rule_stem).with_suffix(".markers.txt"),
    params:
        treshold = config['aa_theta_dev_thr']
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        # identify markers for removal 
        (removed,total) = mqc.extract_list(
            input.snptable,
            output.removal_markers,
            output.removal,
            colName = config["aa_theta_dev_col_name"],
            sep = '\t',
            condition = ">",
            treshold = params.treshold,
            key_cols = [0],
            doc_cols = [0]
        )

        subprocess.run(
            [
                plinklocal,
                "--bfile", inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk,
                "--make-bed"
            ],
            check = True
        )

        dropouts = mqc.checkUpdates(
            inTrunk+".bim",
            outTrunk+".bim",
            cols = [0, 1, 3, 4, 5],
            sanityCheck = "removal",
            fullList = True,
            allele_flip = True
        )
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule

        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'{datetime.now().strftime("%Y-%m-%d_%H:%M:%S")} - Batch {wildcards.batch}: Removed {dropouts["actionTakenCount"]} markers(NSNP_AATHETADEV_LOST) out of {dropouts["in"]} (NSNP_GC_LOST), leaving {dropouts["out"]} markers. Treshhold {params.treshold}\n')

        mqc.plot_point_and_line(
            dropouts,
            input.snptable,
            output.plot,
            config["aa_theta_dev_col_name"],
            separator = '\t',
            ylabel = "AA-\u03B8 deviation",
            invert = False
        )


# This is a non-functional rule which sole intention is to recap and
# show what happens in Module 1, It permits the module to have some
# 'public' variables (output), that other rules can refer to. It also
# ensures that snakemake DAG output is easier to read.
rule_stem = 'm1_output'
rule m1_output:
    input:
        # Start of pipe
        bedset_first = rules.remove_chr0.input.bedset,
        # Note that this is actually the output of module 1, this rule is just a report rule
        bedset_last = rules.remove_markers_aa_theta_deviation.output.bedset,
    output:
        bedset = multiext(str(tmpMod1/"{batch}"/rule_stem), '.bed', '.bim', '.fam'),
        # Category is sorted as written below.
        # We use - as prefix to force final reports to be sorted first.
        report_markers = report(
            (resultPath/"{batch}"/rule_stem).with_suffix(".markers.yaml"),
            category = "- Module 1 Data conversion recap",
            caption = (resultPath/"{batch}"/rule_stem).with_suffix(".markers.rst")
        ),
        report_samples = report(
            (resultPath/"{batch}"/rule_stem).with_suffix(".samples.yaml"),
            category = "- Module 1 Data conversion recap",
            caption = (resultPath/"{batch}"/rule_stem).with_suffix(".samples.rst")
        ),
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        firstTrunk =  mqc.plinkBase(input.bedset_first[0])
        lastTrunk =  mqc.plinkBase(input.bedset_last[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        docs = "For more documentation see https://github.com/folkehelseinstituttet/mobaGenetics-qc/wiki/Module1 . In the html file see info on individual module steps through the section for results of Module 1 Data preparation"

        # Create a dummy bedset we can refer to later that clearly show module1 output
        for i in ['.bed','.bim','.fam']:
            copyfile(lastTrunk+i, outTrunk+i)

        # report markers
        dropouts = mqc.checkUpdates(
            firstTrunk + ".bim",
            outTrunk + ".bim",
            cols = [0, 1, 3, 4, 5],
            sanityCheck = "removal",
            fullList = True,
            allele_flip = True
        )
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Documentation details"] = docs

        mqc.saveYamlResults(output.report_markers, dropouts)

        # report samples
        dropouts = mqc.checkUpdates(
            firstTrunk + ".fam",
            outTrunk + ".fam",
            cols = [0, 1],
            sanityCheck = "update",
            fullList = True
        )
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Documentation details"] = docs

        mqc.saveYamlResults(output.report_samples, dropouts)



