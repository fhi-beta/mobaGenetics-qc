# Rule updates raw bedset with biobank provided pedigree information and gender
# Sample IDs are updated to SentrixIDs

rule_stem ='remove_chr0'
rule remove_chr0:
    input:
        bedset=multiext(config['raw_bed_stem'],'.bed','.bim','.fam'),
    output:
        bedset=multiext(str(tmpMod1/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 1 Data preparation",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--not-chr", "0", 
                "--out", outTrunk,
                "--make-bed"
        ], check=True)

        # Checking how many markers/chromosone 0 we removed  on this step
        # We turn of warning here as we know there might be duplicate markers to check for later
        dropouts = mqc.checkUpdates(inTrunk+".bim",
                                    outTrunk+".bim", cols=[0,1,3,4,5], indx=1,
                                    sanityCheck="none", fullList=True ) 

        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule

        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'(NSNP_CHR0_LOST) Removed {dropouts["actionTakenCount"]} chromosone 0 out of {dropouts["in"]}, leaving {dropouts["out"]} markers\n')
        

# Check for duplicate markers, and remove all but one (keep best callrate)
# The code here is copied and reused in remove_dup_markers_1kg
# This rule could be smarter in the case no duplicate markers are found
rule_stem = 'remove_duplicate_markers'
rule remove_duplicate_markers:
    input:
        bedset= rules.remove_chr0.output.bedset
    output:
        bedset=multiext(str(tmpMod1/rule_stem),'.bed','.bim','.fam'),
        excludeList = (tmpMod1/rule_stem).with_suffix(".txt"),
        resultDetails = (resultPath/rule_stem).with_suffix(".csv"),
        # plink hardcodes this
        plink_dup_list = (tmpMod1/"plink").with_suffix(".dupvar"),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 1 Data preparation",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    params:
        details = (resultPath/rule_stem).with_suffix(".yaml.details")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        
        inTrunk = mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.bedset[0])
        callRateTrunk = mqc.plinkBase(output.excludeList)
        # Create a plink.dupvar file
        # Plink-bug (1.90b5.4): Puts plink.dupvar i snakemake directory. so we cwd ...
        subprocess.run([plinklocal,
                        "--bfile",inTrunk,
                        "--list-duplicate-vars"
        ], check=True, cwd=tmpMod1)
        
        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--out", callRateTrunk,
                        "--missing"
        ], check=True)

        mqc.create_exclude_list(output.plink_dup_list, callRateTrunk+".lmiss",
                                output.resultDetails, output.excludeList)

        subprocess.run([plinklocal,
                        "--bfile",inTrunk,
                        "--exclude", output.excludeList,
                        "--out", outTrunk,
                        "--make-bed"
        ], check=True)
        
        dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",
                                    cols=[0,1,3,4,5],
                                    sanityCheck="removal",
                                    fullList=True) 
        dropouts["Callrates"] = output.resultDetails

        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'Due to duplicate markers, removed {dropouts["actionTakenCount"]} markers out of {dropouts["in"]}, leaving {dropouts["out"]} markers\n')


rule_stem ='sampleIdUpdated'
rule update_sample_ids:
    input:
        bedset=rules.remove_duplicate_markers.output.bedset,
        recode=config['recode_ids']
    output:
        bedset=multiext(str(tmpMod1/rule_stem) ,'.bed','.bim','.fam'),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 1 Data preparation",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        
        inTrunk = mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.bedset[0])


        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--update-ids", input.recode,
                "--out", outTrunk ,
                "--make-bed"], check=True)
        updated = mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",cols=[0,1],
                                   indx=1,
                                   sanityCheck="updated", fullList=True,
                                   mapFile=input.recode, mapIndx=1) 
        updated.update(rule_info[rule])   # Metainfo and documentation about the rule
        updated["Rule"] = rule
        mqc.saveYamlResults(output.results, updated)
        mqc.log(runlog,f'Sample id: Updated {updated["actionTakenCount"]} samples (NIND_NOTUPDATEDID) out of {updated["in"]} (NIND_TOUPDATEID)\n')

rule_stem = 'parents-updated'
rule update_parents:
    input:
        bedset=rules.update_sample_ids.output.bedset,
        recode=config['recode_parents']
    output:
        bedset=multiext(str(tmpMod1/rule_stem) ,'.bed','.bim','.fam'),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 1 Data preparation",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--update-parents", input.recode,
                "--out", outTrunk ,
                "--make-bed"
        ], check=True)
        updated= mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",cols=[1,2,3],
                                  sanityCheck="updated",
                                  fullList=True, mapFile=input.recode)
        updated.update(rule_info[rule])   # Metainfo and documentation about the rule
        updated["Rule"] = rule

        mqc.saveYamlResults(output.results, updated)
        mqc.log(runlog,f'Sample id: Updated {updated["actionTakenCount"]} samples (NIND_NOTUPDATEDPAR) out of {updated["in"]} (NIND_TOUPDATEPAR)\n')


rule_stem = 'sex-updated'
rule update_sex:
    input:
        bedset=rules.update_parents.output.bedset,
        recode = config['recode_sex']
    output:
        bedset = multiext(str(tmpMod1/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 1 Data preparation",
                         caption=(resultPath/rule_stem).with_suffix(".rst"))        
        
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--update-sex", input.recode,
                "--out", outTrunk ,
                "--make-bed"
        ], check=True)
        # Checking how many of the original samples we still have
        updated = mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",
                                   cols = [1,4], indx=1, sanityCheck="updated",
                                   fullList=True,
                                   mapFile=input.recode, mapIndx=1)
        updated.update(rule_info[rule])   # Metainfo and documentation about the rule
        updated["Rule"] = rule


        mqc.saveYamlResults(output.results, updated)
        mqc.log(runlog,f'Sex updated: Updated {updated["actionTakenCount"]} samples (NIND_NOTUPDATEDPAR) out of {updated["in"]} (NIND_TOUPDATEPAR)\n')


# Remove markers on snp table metrics
rule_stem = 'clustersep_removal'
rule remove_markers_cluster_sep:
    input:
        bedset = rules.update_sex.output.bedset,
        snptable=config['snptable']
    output:
        bedset=multiext(str(tmpMod1/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 1 Data preparation",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/rule_stem).with_suffix(".png"),
                      category="Module 1 Data preparation",
                      caption=(resultPath/rule_stem).with_suffix(".rst")),
        # in addition to the removal list .txt, a *removal.txt.samples is produced, sporting only the sample-list
        removal= (tmpMod1/rule_stem).with_suffix(".txt"), 
        removal_markers = (tmpMod1/rule_stem).with_suffix(".markers.txt"),
    params:
        treshold = config['cluster_sep_thr']
    message: "mod1 Remove markers by cluster metrics" 
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        # identify markers for removal on cluster separation
        (removed,total) = mqc.extract_list(input.snptable, 
                output.removal_markers, output.removal, 
                colName=config['cluster_sep_col_name'], sep='\t',
                condition="<", treshold=params.treshold, 
                key_cols=[0], doc_cols=[0])

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk ,
                "--make-bed"
        ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",
                                    cols = [0,1,3,4,5],
                                    sanityCheck="removal", fullList=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        
        mqc.log(runlog, f'Removed {dropouts["actionTakenCount"]} markers(NSNP_CLUSTERSEP_LOST) out of {dropouts["in"]} (BEFORE_SNPTABLE), leaving {dropouts["out"]} markers. Treshhold {params.treshold}\n')
        # The following has a huge potential for speedup (using round as in mqc.dotplot()
        mqc.plot_point_and_line(dropouts, input.snptable, output.plot,
                                config["cluster_sep_col_name"], separator='\t',
                                ylabel="Separation", invert=False)

        
rule_stem = 'gcscore_removal'
rule remove_markers_gc_score:
    input:
        bedset = rules.remove_markers_cluster_sep.output.bedset,
        snptable=config['snptable']
    output:
        bedset=multiext(str(tmpMod1/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 1 Data preparation",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/rule_stem).with_suffix(".png"),category="Module 1 Data preparation",
                                 caption=(resultPath/rule_stem).with_suffix(".rst")),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal= (tmpMod1/rule_stem).with_suffix(".txt"),
        removal_markers = (tmpMod1/rule_stem).with_suffix(".markers.txt"),
    params:
        treshold = config['10%_GC_score_thr']
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        

        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        # identify markers for removal 
        (removed,total) = mqc.extract_list(input.snptable, 
                output.removal_markers, output.removal, 
                            colName=config["10%_GC_score_col_name"], sep='\t',
                            condition = "<", treshold = params.treshold, 
                            key_cols=[0], doc_cols=[0] )
        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk ,
                "--make-bed"], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",
                                    cols=[0,1,3,4,5], sanityCheck="removal",
                                    fullList=True) 
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

        mqc.log(runlog, f'Removed {dropouts["actionTakenCount"]} markers(NSNP_GC_LOST) out of {dropouts["in"]} (NSNP_BEFORE_GC), leaving {dropouts["out"]} markers. Treshhold {params.treshold}\n')

        mqc.plot_point_and_line(dropouts, input.snptable, output.plot,
                                config["10%_GC_score_col_name"], separator='\t',
                                ylabel="10% GC Score", invert=False)



rule_stem = 'remove_markers_aa_theta_deviation'
rule remove_markers_aa_theta_deviation:
    input:
        bedset = rules.remove_markers_gc_score.output.bedset,
        snptable=config['snptable']
    output:
        bedset=multiext(str(tmpMod1/rule_stem),'.bed','.bim','.fam'),
        results = report((resultPath/rule_stem).with_suffix(".yaml"),
                         category="Module 1 Data preparation",
                         caption=(resultPath/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/rule_stem).with_suffix(".png"),category="Module 1 Data preparation",
                                 caption=(resultPath/rule_stem).with_suffix(".rst")),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal= (tmpMod1/rule_stem).with_suffix(".txt"),
        removal_markers = (tmpMod1/rule_stem).with_suffix(".markers.txt"),
    params:
        treshold = config['aa_theta_dev_thr']
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        # identify markers for removal 
        (removed,total) = mqc.extract_list(input.snptable, 
                output.removal_markers, output.removal, 
                                colName=config["aa_theta_dev_col_name"], sep='\t',
                                condition = ">", treshold=params.treshold, 
                                key_cols=[0], doc_cols=[0])

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk ,
                "--make-bed"
        ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",
                                    cols=[0,1,3,4,5], sanityCheck="removal",
                                    fullList=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule

        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'Removed {dropouts["actionTakenCount"]} markers(NSNP_AATHETADEV_LOST) out of {dropouts["in"]} (NSNP_GC_LOST), leaving {dropouts["out"]} markers. Treshhold {params.treshold}\n')
                     
        mqc.plot_point_and_line(dropouts, input.snptable, output.plot,
                                config["aa_theta_dev_col_name"], separator='\t',
                                ylabel="AA-\u03B8 deviation", invert=False)


# This is a dummy rule which sole intention is to recap and show what happens in Modules 1,
# It permits the module to have some 'public' variables, that other rules can
# refer to.
# It also ensure that snakemake -- is easer to read.
rule_stem = 'm1_output_report'
rule m1_output_report:
    input:
        # Start of pipe
        bedset_first = rules.remove_chr0.input.bedset,
        # Note that this is actually the output of module 1, this rule is just a report rule
        bedset_last = rules.remove_markers_aa_theta_deviation.output.bedset,
    output:
        bedset = multiext(str(tmpMod1/rule_stem),'.bed','.bim','.fam'),
        # category is sorted as written below. We use - as prefix to force
        # final reports to be sorted first ...
        report_markers = report((resultPath/rule_stem).with_suffix(".markers.yaml"),
                        category="- Module 1 Data conversion recap",
                        caption=(resultPath/rule_stem).with_suffix(".markers.rst")),
        report_samples = report((resultPath/rule_stem).with_suffix(".samples.yaml"),
                        category="- Module 1 Data conversion recap",
                        caption=(resultPath/rule_stem).with_suffix(".samples.rst")),
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])        
        firstTrunk =  mqc.plinkBase(input.bedset_first[0])
        lastTrunk =  mqc.plinkBase(input.bedset_last[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        docs = "For more documentation see https://github.com/folkehelseinstituttet/mobaGenetics-qc/wiki/Module1 . In the html file see info on individual module steps through the section for results of Module 1 Data preparation"

        # Create a dummy bedset we can refer to later that clearly show module1 output
        for i in ['.bed','.bim','.fam']:
            copyfile(lastTrunk+i, outTrunk+i)
        # report markers
        dropouts = mqc.checkUpdates(firstTrunk+".bim", outTrunk+".bim",
                                    cols=[0,1,3,4,5],
                                    sanityCheck="removal", fullList=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Documentation details"] = docs

        mqc.saveYamlResults(output.report_markers, dropouts)

        # report samples
        dropouts = mqc.checkUpdates(firstTrunk+".fam",outTrunk+".fam",
                                    cols=[0,1], sanityCheck="update",
                                    fullList=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Documentation details"] = docs

        mqc.saveYamlResults(output.report_samples, dropouts)
# Pilepline continutes in module 2 

