# Rule updates raw bedset with biobank provided pedigree information and gender
# Sample IDs are updated to SentrixIDs
import sys
sys.path.append('../lib')  # in order to find our local packages
import mobaQcTools as mqc  # local moba package
import yaml  # you might be able to remove this ...


rule remove_chr0:
    input:
        bedset=expand(config['raw_bed_stem'] + '{ext}', ext=['.bed','.bim','.fam']),
    output:
        bedset=expand(str(tmpMod1/'chr0_removed')
                          + '{ext}', ext=['.bed','.bim','.fam']),
        resultsChr0 = report(resultPath/"remove_chr0.yaml",category="Module 1 Data Conversion")
    run:
        mqc.log(runlog, "Updating techincal markers (Removing chromosome 0)\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--not-chr", "0", 
                "--out", outTrunk,
                "--make-bed"
        ])

        # Checking how many markers/chromosone 0 we removed  on this step
        # We turn of warning here as we know there might be duplicate markers to check for later
        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim", cols=[0,1,3,4,5], indx=1,
                                    sanityCheck="none", fullList=True, ) 
        dropouts["QC test"] = "Removing chromosone 0"
        dropouts["Description"] = ""
        dropouts["Snakemake rule"] = "remove_chr0"

        mqc.saveYamlResults(output.resultsChr0, dropouts)
        mqc.log(runlog, f'(NSNP_CHR0_LOST) Removed {dropouts["actionTakenCount"]} chromosone 0 out of {dropouts["in"]}, leaving {dropouts["out"]} markers\n')



rule update_sample_ids:
    input:
        bedset=rules.remove_chr0.output.bedset,
        recode=config['recode_ids']
    output:
        bedset=expand(str(base  / 'mod1-data-preparation/tmp/sample_id_updated') + '{ext}', ext=['.bed','.bim','.fam']),
        results = report(resultPath/"sampleIdUpdated.yaml",category="Module 1 Data Conversion")
    run:
        mqc.log(runlog, "*** Module 1 Data Conversion ***\n")
        mqc.log(runlog, "Updating sample ids: \n")
        inTrunk = mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.bedset[0])


        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--update-ids", input.recode,
                "--out", outTrunk ,
                "--make-bed"        ])
        updated = mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",cols=[0,1], indx=1, sanityCheck="updated", fullList=True, mapFile=input.recode, mapIndx=1) 
        updated["QC test"] = "Update sample ids"
        updated["Description"] = "Mapping lab ids to moba ids"
        updated["Snakemake rule"] = "update_sample_ids"
        mqc.saveYamlResults(output.results, updated)
        mqc.log(runlog,f'Sample id: Updated {updated["actionTakenCount"]} samples (NIND_NOTUPDATEDID) out of {updated["in"]} (NIND_TOUPDATEID)\n')

rule update_parents:
    input:
        bedset=rules.update_sample_ids.output.bedset,
        recode=config['recode_parents']
    output:
        bedset=expand(str(tmpMod1/'parents-updated') + '{ext}', ext=['.bed','.bim','.fam']),
        results = report(resultPath/"parentsUpdated.yaml",category="Module 1 Data Conversion")
    run:
        mqc.log(runlog, "Update parents: \n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--update-parents", input.recode,
                "--out", outTrunk ,
                "--make-bed"
        ])
        updated = mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",cols=[1,2,3], sanityCheck = "updated",
                                   fullList = True, mapFile=input.recode) 
        updated["QC test"] = "Update parents"
        updated["Description"] = "Parents updated based on moba information"
        updated["Snakemake rule"] = "update_parents"
        mqc.saveYamlResults(output.results, updated)
        mqc.log(runlog,f'Sample id: Updated {updated["actionTakenCount"]} samples (NIND_NOTUPDATEDPAR) out of {updated["in"]} (NIND_TOUPDATEPAR)\n')


rule update_sex:
    input:
        bedset=rules.update_parents.output.bedset,
        recode = config['recode_sex']
    output:
        bedset = expand(str(tmpMod1/'sex-updated') + '{ext}', ext=['.bed','.bim','.fam']),
        results = report(resultPath/"sexUpdated.yaml",category="Module 1 Data Conversion")
        
    run:
        mqc.log(runlog, "Update sex: \n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--update-sex", input.recode,
                "--out", outTrunk ,
                "--make-bed"
        ])
        # Checking how many of the original samples we still have
        updated = mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",cols = [1,4], indx=1, sanityCheck = "updated",
                                   fullList = True, mapFile=input.recode, mapIndx=1) 
        updated["QC test"] = "Update sex"
        updated["Description"] = "Gender updated using to moba information"
        updated["Snakemake rule"] = "update_sex"
        mqc.saveYamlResults(output.results, updated)
        mqc.log(runlog,f'Sex updated: Updated {updated["actionTakenCount"]} samples (NIND_NOTUPDATEDPAR) out of {updated["in"]} (NIND_TOUPDATEPAR)\n')


# Check for duplicate markers, and remove all but one (keep best callrate)
rule remove_duplicate_markers:
    input:
        bedset = rules.update_sex.output.bedset,
    output:
        bedset=expand(str(tmpMod1/'dup_markers_removed') + '{ext}', ext=['.bed','.bim','.fam']),
        excludeList = tmpMod1/'duplicates_removed.txt',
        resultDetails = resultPath/'duplicates_removed.csv',
        results = report(resultPath/"duplicates_removed.yaml",category="Module 1 Data Conversion"),
    run:
        inTrunk = mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.bedset[0])
        callRateTrunk = mqc.plinkBase(output.excludeList)
        dups = mqc.detect_duplicate_markers(inTrunk+".bim")
        if dups is not None:
            subprocess.run([plinklocal,
                             "--bfile", inTrunk,
                             "--out", callRateTrunk,
                             "--missing"
            ])

            
        mqc.create_exclude_list(dups, callRateTrunk+".lmiss",
                                output.resultDetails, output.excludeList)

        subprocess.run([plinklocal,
                        "--bfile",inTrunk,
                        "--exclude", output.excludeList,
                        "--out", outTrunk,
                        "--make-bed"
        ])
        # We are here checking only the snp-id. It should be unique
        dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",cols = [1], sanityCheck = "removal", fullList = False) 
        dropouts["QC test"] = "Remove duplicate markers"
        dropouts["Description"] = "When duplicate markers are found, only the one with best call rating is kept"
        dropouts["Detailed results"] = output.resultDetails
        dropouts["Snakemake rule"] = "remove_duplicate_markers"
        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'Due to duplicate markers, removed {dropouts["actionTakenCount"]} markers out of {dropouts["in"]}, leaving {dropouts["out"]} markers\n')




# Remove markers on snp table metrics
rule remove_markers_cluster_sep:
    input:
        bedset = rules.update_sex.output.bedset,
        snptable=config['snptable']
    output:
        bedset=expand(str(tmpMod1/'clustersep_removal') + '{ext}', ext=['.bed','.bim','.fam']),
        results = report(resultPath/"clustersep_removal.yaml",category="Module 1 Data Conversion"),
        plot = report(resultPath/"clustersep_removal_hist.png",category="Module 1 Data Conversion"),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal= tmpMod1/'clustersep_removal.txt',
        removal_markers = tmpMod1/'clustersep_removal.samples.txt',
    message: "mod1 Remove markers by cluster metrics" 
    run:
        mqc.log(runlog, "Remove snp table metrics (CLUSTERSEP)\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        treshold = config['cluster_sep_thr']
        # identify markers for removal on cluster separation
        (removed,total) = mqc.extractSampleList(input.snptable, 
                output.removal_markers, output.removal, 
                colName=config['cluster_sep_col_name'], condition = "<", treshold = treshold, 
                cols = {0} )

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk ,
                "--make-bed"
        ])

        dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",cols = [0,1], sanityCheck = "removal", fullList = True) 
        dropouts["QC test"] = "Cluster separation"
        dropouts["Description"] = "(None for now)"
        dropouts["Threshold"] = treshold
        dropouts["Snakemake rule"] = "remove_markers_clustersep"
        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'Removed {dropouts["actionTakenCount"]} markers(NSNP_CLUSTERSEP_LOST) out of {dropouts["in"]} (BEFORE_SNPTABLE), leaving {dropouts["out"]} markers. Treshhold {treshold}\n')
        # Supersimple plot-test. Legend based on diff before/after QC test
        percentDropped = dropouts["actionTakenCount"] / dropouts["in"]
        mqc.plotHist(input.snptable, output.plot, config["cluster_sep_col_name"], 
            title = f'{dropouts["QC test"]}: Histogram of the full snp-table - before any exclusion of samples.\n'
                    f'With treshhold {treshold},  {dropouts["actionTakenCount"]} ({percentDropped:.1%}) out of {dropouts["in"]} were dropped.\n'
                    f'At the current point of the QC, {dropouts["out"]} samples are left'
        )

        
rule remove_markers_gc_score:
    input:
        bedset = rules.remove_markers_cluster_sep.output.bedset,
        snptable=config['snptable']
    output:
        bedset=expand(str(tmpMod1/'gcscore_removal') + '{ext}', ext=['.bed','.bim','.fam']),
        results = report(resultPath/"gcscore10p_removal.yaml" ,category="Module 1 Data Conversion"),
        plot = report(resultPath/"gcscore10p_removal_hist.png",category="Module 1 Data Conversion"),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal= tmpMod1/'gc10_removal.txt',
        removal_markers = tmpMod1/'gc10_removal.samples.txt',
    run:
        mqc.log(runlog, "Removing markers based on 10% GC score\n")

        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        treshold = config['10%_GC_score_thr']
        # identify markers for removal 
        (removed,total) = mqc.extractSampleList(input.snptable, 
                output.removal_markers, output.removal, 
                                                colName=config["10%_GC_score_col_name"], condition = "<", treshold = treshold, 
                cols = {0} )

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk ,
                "--make-bed"])
    

        dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",cols = [0,1], sanityCheck = "removal", fullList = True) 
        dropouts["QC test"] = "GC 10% score"
        dropouts["Description"] = "(None for now)"
        dropouts["Threshold"] = treshold
        dropouts["Snakemake rule"] = "remove_markers_gc_score"
        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'Removed {dropouts["actionTakenCount"]} markers(NSNP_GC_LOST) out of {dropouts["in"]} (NSNP_BEFORE_GC), leaving {dropouts["out"]} markers. Treshhold {treshold}\n')
        # Supersimple plot-test. Legend based on diff before/after QC test
        percentDropped = dropouts["actionTakenCount"] / dropouts["in"]
        mqc.plotHist(input.snptable, output.plot, config["10%_GC_score_col_name"], 
            title = f'{dropouts["QC test"]}: Histogram of the full snp-table - before any exclusion of samples.\n'
                    f'With treshhold {treshold},  {dropouts["actionTakenCount"]} ({percentDropped:.1%}) out of {dropouts["in"]} were dropped.\n'
                    f'At the current point of the QC, {dropouts["out"]} samples are left'
        )


rule remove_markers_aa_theta_dev:
    input:
        bedset = rules.remove_markers_gc_score.output.bedset,
        snptable=config['snptable']
    output:
        bedset=expand(str(tmpMod1/'aa_theta_removal') + '{ext}', ext=['.bed','.bim','.fam']),
        results = report(resultPath/"aa_theta_removal.yaml",category="Module 1 Data Conversion"),
        plot = report(resultPath/"aa_theta_removal_hist.png",category="Module 1 Data Conversion"),
        # in addition to the removal list, a *removal.txt.samples is produced, sporting only the sample-list
        removal= tmpMod1/'aa_theta_removal.txt',
        removal_markers = tmpMod1/'aa_theta_removal.samples.txt',
    run:
        mqc.log(runlog, "Removing markers based on AA theta dev\n")
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        treshold = config['aa_theta_dev_thr']
        # identify markers for removal 
        (removed,total) = mqc.extractSampleList(input.snptable, 
                output.removal_markers, output.removal, 
                colName=config["aa_theta_dev_col_name"], condition = ">", treshold = treshold, 
                cols = {0} )

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--exclude", output.removal_markers,
                "--out", outTrunk ,
                "--make-bed"
        ])


        dropouts = mqc.checkUpdates(inTrunk+".bim",outTrunk+".bim",cols = [0,1], sanityCheck = "removal", fullList = True) 
        dropouts["QC test"] = "AA Theta Dev"
        dropouts["Description"] = "(None for now)"
        dropouts["Threshold"] = treshold
        dropouts["Snakemake rule"] = "remove_markers_clustersep"
        mqc.saveYamlResults(output.results, dropouts)
        mqc.log(runlog, f'Removed {dropouts["actionTakenCount"]} markers(NSNP_AATHETADEV_LOST) out of {dropouts["in"]} (NSNP_GC_LOST), leaving {dropouts["out"]} markers. Treshhold {treshold}\n')
        # Supersimple plot-test. Legend based on diff before/after QC test
        percentDropped = dropouts["actionTakenCount"] / dropouts["in"]
        mqc.plotHist(input.snptable, output.plot, config["aa_theta_dev_col_name"], 
            title = f'{dropouts["QC test"]}: Histogram of the full snp-table - before any exclusion of samples.\n'
                    f'With treshhold {treshold},  {dropouts["actionTakenCount"]} ({percentDropped:.1%}) out of {dropouts["in"]} were dropped.\n'
                    f'At the current point of the QC, {dropouts["out"]} samples are left'
        )
        

