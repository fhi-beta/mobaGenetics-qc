# Generate statistics on raw dataset before anything happens to the data
rule_stem = 'mod3_generate_start_stats'
rule mod3_generate_start_stats:
    input:
        bedset = rules.m2_output.output.bedset
    output:
        het = tmpMod3/"{batch}"/'mod3_start_het.het',
        hwe = tmpMod3/"{batch}"/'mod3_start_hwe.hwe',
        freq = tmpMod3/"{batch}"/'mod3_start_freq.frq',
        lmiss = tmpMod3/"{batch}"/'mod3_start_missing.lmiss',
        imiss = tmpMod3/"{batch}"/'mod3_start_missing.imiss',
    threads: 1
    run:
        try:
            # Plink base paths
            plink_input = mqc.plinkBase(input.bedset[0])
            plink_het_output = mqc.plinkBase(output.het)
            plink_hwe_output = mqc.plinkBase(output.hwe)
            plink_freq_output = mqc.plinkBase(output.freq)
            plink_miss_output = mqc.plinkBase(output.lmiss)

            # Heterozygocity rate
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--het",
                    "--out", plink_het_output
                ],
                check=True
            )

            # HWE
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--hardy",
                    "--out", plink_hwe_output
                ],
                check=True
            )

            # Frequencies
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--freq",
                    "--out", plink_freq_output
                ],
                check=True
            )

            # Missingness
            subprocess.run(
                [
                    plinklocal,
                    "--bfile", plink_input,
                    "--missing",
                    "--out", plink_miss_output
                ],
                check=True
            )

        except Exception as e:
            print(f"An exception occurred in rule {rule}.")
            print(e)

# Reduce 1000 genome markers to the one already pruned and sorted out for moba
rule_stem = 'common_markers_moba_ref'
rule common_markers_moba_ref:
    input:
        bedset_ref = multiext(config["1000_genomes_stem"] ,'.bed','.bim','.fam'),
        bedset_moba = rules.m2_output.output.pruned_bedset
    output:
        bedset_ref = multiext(str(tmpMod3/"{batch}"/"pca_ref") ,'.bed','.bim','.fam'),
        bedset_moba = multiext(str(tmpMod3/"{batch}"/"pca_moba") ,'.bed','.bim','.fam'),
        marker_list = (tmpMod3/"{batch}"/rule_stem).with_suffix(".txt"),
        tri_alleles = report((tmpMod3/"{batch}"/rule_stem).with_suffix(".missnp"),
                              category="Module 3 1000Genomes prep",
                              caption=(resultPath/"{batch}"/"pca_ref").with_suffix(".rst")),
        # result ref takes forever to run, and it is handy to uncomment that part
        # (should maybe have been isolated in a separate rule)
        # If you commented out the code that documents reduction the 1000g set below
        # (see "Begin Code that should"), then comment out the results_ref this rule as well.
        # Or do a dirty hack below by 
        results_ref = report((resultPath/"{batch}"/"pca_ref").with_suffix(".yaml"),
                              category="Module 3 1000Genomes prep",
                              caption=(resultPath/"{batch}"/"pca_ref").with_suffix(".rst")),
        results_moba = report((resultPath/"{batch}"/"pca_moba").with_suffix(".yaml"),
                              category="Module 3 1000Genomes prep",
                              caption=(resultPath/"{batch}"/"pca_moba").with_suffix(".rst")),
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk_ref =  mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba =  mqc.plinkBase(input.bedset_moba[0])
        outTrunk_ref =  mqc.plinkBase(output.bedset_ref[0])
        outTrunk_moba =  mqc.plinkBase(output.bedset_moba[0])
        triallelesTrunk =  mqc.plinkBase(output.tri_alleles)

        # Common markers found in marker_list
        mqc.intersect_rsid(inTrunk_moba+".bim", inTrunk_ref+".bim",  output.marker_list)
        # Reduce both sets to the common markers
        subprocess.run([plinklocal,
                "--bfile", inTrunk_ref,
                "--extract", output.marker_list,
                "--out", outTrunk_ref,
                "--allow-extra-chr",  # such as PAR1 ...
                "--make-bed" ], check=True)
        subprocess.run([plinklocal,
                "--bfile", inTrunk_moba,
                "--extract", output.marker_list,
                "--out", outTrunk_moba,
                "--make-bed" ], check=True)
        # alas these two are not identical enough -
        # discover tri-allele  problems by dummy-merging
        # Note that we don't want to abort on plink-failure (as this will be)
        subprocess.run([plinklocal,
                "--bfile", outTrunk_ref,
                "--bmerge", outTrunk_moba,
                        "--out", triallelesTrunk ], check=False)
        # ... And then remove these markers from both sets
        # fyi: plink will append inputfiles  by ~ ... since input/output have same name
        subprocess.run([plinklocal,
                "--bfile", outTrunk_ref,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_ref,
                "--make-bed" ], check=True)

        subprocess.run([plinklocal,
                "--bfile", outTrunk_moba,
                "--exclude", output.tri_alleles,
                "--out", outTrunk_moba,
                "--make-bed" ], check=True)

        # Document the reduction for ref (1000 genomes) ... but not all the markers
        # Btw, this take forever as inTrunk_ref+".bim" is huge so the code was
        # removed. We have the common markers anyway ... from a 'previous' run.
        # If you (un)comment out this, do the same for results_ref above
        print (f"{inTrunk_ref} -> {outTrunk_ref}")
        # BEGIN Code that should have been in a separate rule
        dropouts = mqc.checkUpdates(inTrunk_ref+".bim", outTrunk_ref+".bim",
                                     cols = [0,1,3,4,5],
                                     sanityCheck = "removal", fullList = False,
                                     allele_flip=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Excluded markers"] = f"Common markers in {output.marker_list}, trialleles removed in {output.tri_alleles}"
        mqc.saveYamlResults(output.results_ref, dropouts)
        # END Code thatshould have been in a separate rule
        print (f"checking {inTrunk_moba} -> {outTrunk_moba}")
        # Document the reduction for moba
        dropouts = mqc.checkUpdates(inTrunk_moba+".bim", outTrunk_moba+".bim",
                                    cols = [0,1,3,4,5],
                                    sanityCheck = "removal",
                                    fullList = False, allele_flip=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        dropouts["Excluded markers"] = f"Common markers in {output.marker_list}, trialleles removed in {output.tri_alleles}"
        mqc.saveYamlResults(output.results_moba, dropouts)

# 7.1.2020 projecting moba data on this did not work. For now we merge the data.
# rule_stem = "pca_1kgp"
# rule pca_1kgp:
#     input:
#         bedset = rules.common_markers_moba_ref.output.bedset_ref,
#     output:
#         ref_pcs=tmpMod3/rule_stem/'pcs_1kgp',
#         ref_eigenvec=tmpMod3/rule_stem/'eigenvec_1kgp',
#         ref_loadings=tmpMod3/rule_stem/'loadings_1kgp',
#         ref_eigenval=tmpMod3/rule_stem/'eigenval_1kgp',
#         ref_var_explained=tmpMod3/rule_stem/'var_explained_1kgp',
#         ref_meansd=tmpMod3/rule_stem/'meansd_1kgp',
#     run:
#         item_type = rule_info[rule]["rule type"]
#         mqc.log(runlog, rule_info[rule]["QC test"])
#         inTrunk =  mqc.plinkBase(input.bedset[0])

#         subprocess.run([flashpca,
#                         "--bfile", inTrunk,
#                         "--outpc", output.ref_pcs,
#                         "--outmeansd", output.ref_meansd,
#                         "--outload", output.ref_loadings,
#                         "--outvec",  output.ref_eigenvec,
#                         "--outval", output.ref_eigenval,
#                         "--outpve", output.ref_var_explained ])

# This projection does not work (7.1.2020). Must look at this laters
# instead we run one single pca on a merged file, see pca_both below
# rule_stem = "pca_moba"
# rule pca_moba:
#     input:
#         bedset = rules.common_markers_moba_ref.output.bedset_moba,
#         ref_meansd = rules.pca_1kgp.output.ref_meansd,    # projected onto pca from ...
#         ref_loadings = rules.pca_1kgp.output.ref_loadings,# ... 1000 genomes pca
#     output:
#         moba_projection=tmpMod3/rule_stem/'projection_moba',
# # plot?        ref_meansd=tresultPath/rule_stem).with_suffix(".yaml"),
# #                         category="Module 2 1000Genomes prep",
# #                         caption=(resultPath/rule_stem).with_suffix(".rst"))

#     run:
#         item_type = rule_info[rule]["rule type"]
#         mqc.log(runlog, rule_info[rule]["QC test"])
#         inTrunk =  mqc.plinkBase(input.bedset[0])

#         # --project moba data onto 1000 genomes loading
#         subprocess.run([flashpca,
#                         "--bfile", inTrunk,
#                         "--project",
#                         "--inmeansd", input.ref_meansd,
#                         "--outproj", output.moba_projection,
#                         "--inload", input.ref_loadings,
#                         check=True])

# plots a projection, does not work well 7.1.2020 Delete or fix later, see plot_pca_both below
# Note that on https://github.com/gabraham/flashpca/blob/master/README.md it says to use
# plink --reference-allele , but that is a plink2 command
# rule_stem = "plot_pca"
# rule plot_pca:
#     input:
#         pop_map = config["1000_genomes_pop"],       # maps samples to population-groups
#         ref_pcs = rules.pca_1kgp.output.ref_pcs,
#         moba_pcs = rules.pca_moba.output.moba_projection,

#     output:
#         plot = report((resultPath/rule_stem).with_suffix(".png"),
#                       category="Module 2 1000Genomes prep")

#     run:
#         # To remove when this goes to mobaQcTools
#         import pandas as pd
#         import plotnine as p9
#         import matplotlib
#         matplotlib.use('Agg')

#         pc = pd.read_csv(input.ref_pcs, usecols=['IID','PC1','PC2'],delim_whitespace=True)
#         moba = pd.read_csv(input.moba_pcs, usecols=['IID','PC1','PC2'],delim_whitespace=True)
#         # All data. We here later assume that moba ID and 1000 genomes ID are different
#         all = pd.concat([pc,moba],ignore_index=True)

#         # Populations for colouring -
#         # see https://www.internationalgenome.org/faq/which-populations-are-part-your-study/ for details
#         pop = pd.read_csv(input.pop_map,usecols=['#IID','SuperPop','Population'],delim_whitespace=True)
#         # Simulate population for Moba
#         popmoba = pd.read_csv(input.moba_pcs,usecols=['IID'],delim_whitespace=True)
#         popmoba.columns = ["#IID"]  # rename to match earlier pop
#         popmoba['SuperPop'] = '->MoBa'
#         popmoba['Population'] = '->MoBa'
#         all_pop = pd.concat([pop,popmoba],ignore_index=True)
#         merged = pd.merge(left=all, right=all_pop, left_on='IID', right_on='#IID')
#         print(merged)


#         # Set up colours
#         # colours = {'EUR': 'red',
#         #            'EAS': 'darkblue',
#         #            'AMR': 'violet',
#         #            'SAS': 'orange',
#         #            'AFR': 'yellow',
#         #            'Moba':'black'}
#         popc = "SuperPop"
#         p = p9.ggplot(data=merged, mapping=p9.aes(x='PC1',y='PC2',color=popc, shape=popc))
#         looks = p9.aes(color=popc, shape=popc)
#         p +=  p9.geom_point()
#         p += p9.scale_colour_brewer(type="qual", palette="Set1")  # better for colourblind
#         p9.ggsave(plot=p, filename=output.plot, dpi=600)

rule_stem = "pca_both"
rule pca_both:
    input:
        bedset_ref = rules.common_markers_moba_ref.output.bedset_ref,
        bedset_moba = rules.common_markers_moba_ref.output.bedset_moba,
    output:
        bedset = multiext(str(tmpMod3/"{batch}"/rule_stem) ,'.bed','.bim','.fam'),
        pcs=tmpMod3/"{batch}"/(rule_stem+".pcs"),
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk_ref =  mqc.plinkBase(input.bedset_ref[0])
        inTrunk_moba =  mqc.plinkBase(input.bedset_moba[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])

        subprocess.run([plinklocal,
                        "--bfile", inTrunk_ref,
                        "--bmerge", inTrunk_moba,
                        "--out", outTrunk,
                        "--make-bed"    ], check=True)

        subprocess.run([flashpca,
                        "--bfile", outTrunk,
                        "--outpc", output.pcs,
                        ], check=True)




rule_stem = "plot_pca_both"
rule plot_pca_both:
    input:
        pop_map = config["1000_genomes_pop"],       # maps samples to population-groups
        pcs = rules.pca_both.output.pcs,            # principal components
        moba = mqc.plinkBase(rules.common_markers_moba_ref.output.bedset_moba[0]) + ".fam"

    output:
        plot = report((resultPath/"{batch}"/rule_stem).with_suffix(".png"),
                      category="Module 3 Good markers",
                      caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    # force this url into the report
    params: "Legend on https://www.internationalgenome.org/faq/which-populations-are-part-your-study/"
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")
    run:
        # To remove when this goes to mobaQcTools
        pc = pd.read_csv(input.pcs, usecols=['IID','PC1','PC2'], delim_whitespace=True)
        # Populations for colouring -
        pop = pd.read_csv(input.pop_map,usecols=['#IID','SuperPop','Population'],delim_whitespace=True)
        # Simulate population for Moba, read 2-column in fam-file
        popmoba = pd.read_csv(input.moba,usecols=[1], header=None,
                              delim_whitespace=True)
        popmoba.columns = ["#IID"]  # rename to match earlier pop
        moba_legend = '->MoBa'
        popmoba['SuperPop'] = moba_legend
        popmoba['Population'] = moba_legend
        all_pop = pd.concat([pop,popmoba],ignore_index=True)
        merged = pd.merge(left=pc, right=all_pop, left_on='IID', right_on='#IID')
        # mqc.find_moba_pca_outlier(merged[merged.Population=='->MoBa'])
        # Explode Europe to Countries in Population
        merged.loc[merged['SuperPop'] == 'EUR', 'SuperPop'] = 'EUR_'+merged['Population']
        legend_info = params[0]
        # Set up colours   - not using this - did not get it right and dont want to spend time on it
        # colours = {'EUR': 'red',
        #            'EAS': 'darkblue',
        #            'AMR': 'violet',
        #            'SAS': 'orange',
        #            'AFR': 'yellow',
        #            'Moba':'black'}
        popc = "SuperPop"
        # Visualize what will be excluded
        print("SUPERDIRTY PCA EXCLUSION!!!! (visualization for now ...)")
        # rename moba-samples above cut-off
        merged.loc[
            (merged["PC1"]>rules.extract_pca_outliers.params.treshold) &
            (merged[popc]==moba_legend), popc]  +=  "(outlier)"
        p = p9.ggplot(data=merged, mapping=p9.aes(x='PC1',y='PC2',color=popc, shape=popc))
        p +=  p9.geom_point()
        p += p9.scale_colour_brewer(type="qual", palette="Set1")  # better for colourblind
        p9.ggsave(plot=p, filename=output.plot, dpi=600)
        # create the caption usually made by saveYamlResults
        with open(str(resultPath/rule)+".rst", 'w') as file:
            file.write(f'Rule {rule_info[rule]["Rule order"]} ({rule_info[rule]["rule action"]})\n')
            file.write(f"{legend_info}\n")

rule_stem = 'extracted_pca_outliers'
rule extract_pca_outliers:
    input:
        bedset = rules.common_markers_moba_ref.output.bedset_moba,
        pcs = rules.pca_both.output.pcs,            # principal components
        moba = rules.plot_pca_both.input.moba,      # moba samples
    output:
        bedset=multiext(str(tmpMod3/"{batch}"/rule_stem)
                          ,'.bed','.bim','.fam'),
        exclude_list = (tmpMod3/"{batch}"/rule_stem).with_suffix(".txt"),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    params:
        treshold = -0.05752391   # Stupid and visual - for now
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        mqc.log(runlog, "PCA exlude {item_type} ({params.treshold})\n")

        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk =  mqc.plinkBase(output.bedset[0])
        pca_treshold = params.treshold
        pc = pd.read_csv(input.pcs, usecols=['IID','PC1','PC2'],delim_whitespace=True)
        # List (only) moba samples that pca-wise are too spread
        mobasamples = pd.read_csv(input.moba,usecols=[0,1], header=None,
                                  delim_whitespace=True)
        mobasamples.columns = ["FID","IID"]
        # keep just moba-samples
        moba_pca = pd.merge(left=pc, right=mobasamples, left_on='IID', right_on='IID')

        # This is a superdirty hack to exclude the same number of samples as
        # was excluded by the hapmap pca. Must be replace by a sensible function
        # Samples to exclude found put in output.excludelist
        print("SUPERDIRTY PCA EXCLUSION!!!!")
        moba_pca.loc[(moba_pca.PC1 > params.treshold)].to_csv(output.exclude_list,
                columns=['FID','IID'],index=False, header=False, sep = ' ')

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--remove", output.exclude_list,
                "--out", outTrunk,
                "--make-bed" ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",
                                    cols = [0,1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)

rule_stem = "tmp_extract_samples"
rule tmp_extract_samples:
    input:
        samples = rules.extract_pca_outliers.output.bedset,
        # rolling back to the sampleset to be fed into mod5
        markers = rules.m2_output.output.bedset,
    output:
        bedset=multiext(str(tmpMod3/"{batch}"/rule_stem)
                          ,'.bed','.bim','.fam'),
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))

    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        mqc.log(runlog, "PCA exlude {item_type} ({params.treshold})\n")

        inTrunk =  mqc.plinkBase(input.markers[0])
        outTrunk = mqc.plinkBase(output.bedset[0])
        sample_list = mqc.plinkBase(input.samples[0]) + ".fam"
        print (f"using {inTrunk} to make {outTrunk} using {sample_list}")
        subprocess.run([plinklocal,
                "--bfile", inTrunk,
                "--keep", sample_list,
                "--out", outTrunk,
                "--make-bed" ], check=True)
        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",
                                    cols = [0,1],
                                    sanityCheck = "removal", fullList = True)

        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)


# This introduces a split of the dataset. Gutorm has not found a smooth way of making
# snakemake understand this, and some of the file names will be hardcoded in some rules.
# And hopefully documented.
# This rules_stem, is reused on ibd_estimate
# The results of the split are picked up in module 4, via the input of ibd_estimate due
# to the way snakemake expands wild-cards. 
rule_stem = "split_start"
rule split_founders_offspring:
    input:
        bedset = rules.tmp_extract_samples.output.bedset
    output:  # bedsets earlier called starting_clean 
             # note that the rule_stem is hardcoded here and in ibd_estimate (first place using the split)
        bedset_founders =multiext(str(tmpMod3/"{batch}"/"founders"/rule_stem) ,'.bed','.bim','.fam'),
        bedset_offspring =multiext(str(tmpMod3/"{batch}"/"offspring"/rule_stem) ,'.bed','.bim','.fam'),
        results_founders = report(str(resultPath/"{batch}"/rule_stem)+"_founders.yaml",
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+"_founders.rst"),
        results_offspring = report(str(resultPath/"{batch}"/rule_stem)+"_offspring.yaml",
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+"_offspring.rst")
    benchmark:
        (tmpMod3/"{batch}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset[0])
        foundersTrunk =  mqc.plinkBase(output.bedset_founders[0])
        offspringTrunk =  mqc.plinkBase(output.bedset_offspring[0])

        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--filter-founders",
                        "--out", foundersTrunk,
                        "--make-bed"  ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam", foundersTrunk+".fam",
                                    cols = [1], sanityCheck = "removal",
                                    fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results_founders, dropouts)

        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--filter-nonfounders",
                        "--make-founders",
                        "--out", offspringTrunk,
                        "--make-bed"  ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam", offspringTrunk+".fam",
                                    cols=[1], sanityCheck="removal", fullList=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results_offspring, dropouts)

rule_stem = "ibd_estimate"
rule ibd_estimate:  # code is more or less copied to core_ibd_estimate
    threads: 2
    input:
        bedset = tmpMod3/"{batch}"/"{role}/split_start.bed",  # will be used by as input to mod4. called starting_clean before
        # Used for IBD estimation earlier as well
        clean_snps = rules.m2_output.output.pruned_snps
    output:
        genome = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".genome"),
        ibd_reduced_genome = tmpMod3/"{batch}"/"{role}"/"ibd_reduced.genome",   #input for R laters, 3 columns of genome file
        preplot = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+".rst"),

    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.genome)

        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--extract", input.clean_snps,
                        "--genome",
                        "--out", outTrunk ], check=True)
        # create a plot for this - corresponds to the old draw-pihat-plots.R
        p = mqc.dotplot(output.genome,prec=3, x='Z0',y='Z1', c='RT')
        p9.ggsave(plot=p, filename=output.preplot, dpi=600)
        df = pd.read_csv(output.genome, delim_whitespace=True,
            usecols=["IID1", "IID2", "PI_HAT"] )
        df.to_csv(output.ibd_reduced_genome, index=False, sep=" ")
        mqc.make_rule_caption(rule, resultPath)

rule_stem = "ibd_accum_exclusion"
rule ibd_accum_exclusion:  # code is more or less copied to core_ibd_accum_exclusion
    threads: 2
    input:
        bed = rules.ibd_estimate.input.bedset,
        ibd_reduced_genome = rules.ibd_estimate.output.ibd_reduced_genome
    output:
        exclusion = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".txt"),
        bedset = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bed"),
        plot = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+".rst"),
        results = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+".rst"),
    params:
        pihat_thr = str(config["ibd_pihat_thr"]),
        hard_thr = str(config["ibd_hard_thr"])
    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bed)  # bed is not a .fam file, we need it
        famFile = inTrunk + ".fam"
        outTrunk =  mqc.plinkBase(output.bedset)
        plotdir = os.path.dirname(output.plot)

        # for now, the below is not ported and lives it's own life
        subprocess.run(["Rscript",
                    f"{libdir}/accumPIHAT.R",
                    input.ibd_reduced_genome,
                    famFile,
                    output.exclusion,
                    plotdir,
                    params.pihat_thr,
                    params.hard_thr,
                    rule], check=True)   # a little dirty, but the R rutine wants a filename that it will add .png, .pdf .txt2
        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--remove", output.exclusion,
                        "--make-bed",
                        "--out", outTrunk ], check=True)
        dropouts = mqc.checkUpdates(inTrunk+".fam", outTrunk+".fam",cols = [1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'ibd_direct_exclusion'
rule ibd_direct_exclusion: # code is more or less copied to core_ibd_direct_exclusion
    threads: 2
    input:
        bedset = rules.ibd_accum_exclusion.output.bedset,
        genome = rules.ibd_estimate.output.genome
    output:
        bedset = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+".rst"),
        # in addition to the removal list, a removal.samples.txt is produced, sporting only the sample-list
        removal= (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".txt"),
        removal_samples = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".samples.txt"),
    params:
        treshold = config['ibd_straight_thr']
    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)
        # identify samples forremoval due to high PI_HAT
        (removed,total) = mqc.extract_list(input.genome,
                output.removal_samples, output.removal,
                colName="PI_HAT", sep=None, condition=">", treshold=params.treshold,
                key_cols=[0,1], doc_cols=[0,1] )

        subprocess.run([plinklocal,
                "--bfile",inTrunk,
                "--remove", output.removal_samples,
                "--out", outTrunk ,
                "--make-bed"], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".fam",outTrunk+".fam",cols = [0,1],
                                    sanityCheck = "removal", fullList = True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Treshold"] = params.treshold
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'geno_rates_mind3' # last iteration - keep <= 9 or fix code below
rule geno_rates_mind3:         # part of earlier markerclean
    # This rule is poorly documented in the html-report, should have made 6 result files
    threads: 2
    input:
        bedset = rules.ibd_direct_exclusion.output.bedset,
    output:
        # Result for every iteration, below is only the last
        bedset = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+".rst"),
        plots = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+".rst"),
    params:
        #3 cycles of mind/geno removal
        geno1 = config["geno_rate.geno1"],
        mind1 = config["geno_rate.mind1"],
        geno2 = config["geno_rate.geno2"],
        mind2 = config["geno_rate.mind2"],
        geno3 = config["geno_rate.geno3"],
        mind3 = config["geno_rate.mind3"]
    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        out_dir = Path(output.bedset).parent    # Directory according to output.bedset
        res_dir = Path(output.results).parent   # and corresponding for results
        lastTrunk = inTrunk
        ruleTrunk = "geno_rates"  # will be appended by the stages
        # Iterate 3 times, greating a chain of geno1->mind1->geno2->mind2 etc files
        # We might have just as well off with cut'n paste here - the code is somewhat
        # hard to read -
        for i in [1,2,3]:      # last number must max must match rule all:
            mqc.log(runlog, f'{rule_info[rule]["QC test"]}: Iteration {i}')
            print(f'{rule_info[rule]["QC test"]}: Iteration {i}')
            file_name= ruleTrunk + "_geno" + str(i)
            outTrunk =  str(out_dir/file_name)
            res_file =  str(res_dir/file_name)+".yaml"
            plot_file =  str(res_dir/file_name)+".png"
            # Plink for both marker and samples, slightly different names for the params
            mqc.missing_genotype_rate(rule, lastTrunk, outTrunk, sample=False,
                                 treshold=getattr(params,f"geno{i}"),
                                      result_file=res_file,
                                      plot_file=plot_file)

            lastTrunk = outTrunk
            file_name= ruleTrunk + "_mind" + str(i)
            outTrunk =  str(out_dir/file_name)
            res_file =  str(res_dir/file_name)+".yaml"
            plot_file =  str(res_dir/file_name)+".png"
            mqc.missing_genotype_rate(rule, lastTrunk, outTrunk, sample=True,
                        treshold=getattr(params,f"mind{i}"),
                        result_file=res_file,
                        plot_file=plot_file)

            lastTrunk = outTrunk
        # create a common caption
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'hwe_autos_geno'
rule hwe_autos_geno:
    threads: 1
    input:
        bedset = rules.geno_rates_mind3.output.bedset,
    output:
        bedset = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bed"),  # called clean_autosomes before
        results = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+".rst"),
        plot = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 3 Good markers",
                         caption=str(resultPath/"{batch}"/rule_stem)+".rst"),
    params:
        #2 cycles hwe/maf + a geno
        hwe1 = config["hwe1"],
        maf1 = config["maf1"],
        sd_het1 = config["sd_het1"],
        hwe2 = config["hwe2"],
        maf2 = config["maf2"],
        sd_het2 = config["sd_het2"],
        geno_rare = config["geno_rare"]
    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        out_dir = Path(output.bedset).parent    # Directory according to output.bedset
        res_dir = Path(output.results).parent   # and corresponding for results
        lastTrunk = inTrunk

        # Iterate 2 times, creating a chain of geno1 -> mind1 -> geno2 -> mind2 etc files
        markers_category = ["common", "rare"]

        for i in [1,2]:    # common_het logic not suited for more than 2 iterations

            file_name= rule + "_hwe" + str(i)
            outTrunk =  str(out_dir/file_name)
            res_file =  str(res_dir/file_name)+".yaml"
            plot_file =  str(res_dir/file_name)+".png"

            # Filters and plot
            mqc.low_hwe_rate(rule, lastTrunk, outTrunk,
                            treshold=getattr(params,f"hwe{i}"),
                            hwe_switches = ["--autosome", "--hardy", "midp"],
                            result_file=res_file,
                            plot_file=plot_file)

            autosomal = markers_category[i]
            lastTrunk = outTrunk
            file_name= rule + "_het" + str(i)
            outTrunk =  str(out_dir/file_name)
            res_file =  str(res_dir/file_name) + ".yaml"
            plot_file =  str(res_dir/file_name) + ".png"
            mqc.excess_het(rule, autosomal, lastTrunk, outTrunk,
                            treshold=getattr(params,f"maf{i}"),
                            sd=getattr(params,f"sd_het{i}"),
                            result_file=res_file,
                            plot_file=plot_file)

            lastTrunk = outTrunk

        # a last round of marker removal
        outTrunk =  mqc.plinkBase(output.bedset)
        mqc.missing_genotype_rate(rule, lastTrunk, outTrunk, sample=False,
                        treshold=params.geno_rare,
                        result_file=output.results,
                        plot_file=output.plot)

        # and set a common caption
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'sex_check'
rule sex_check:
    threads: 2
    input:
        bedset = rules.hwe_autos_geno.output.bedset,
    output:
        bedset = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bed"),  # called removed_failing_sexcheck
        results = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        # File containing the F-statistics for the sex chromosomes
        f_x = os.path.join(tmpMod3, "{batch}", "{role}", "sexcheck_report_x.sexcheck"),
        # f_y = os.path.join(tmpMod3, "{role}", "sexcheck_report_y.sexcheck"),
        # in addition to the removal list, a removal.samples.txt is produced, sporting only the sample-list
        plot = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        # These two files are referred to later
        bim = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bim"),
        hh = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".hh")


    params:
        female_treshold = config['sex_check_female'],
        male_treshold = config['sex_check_male']
    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        mqc.sex_check(rule, input.bedset, output.bedset, f_treshold=0.2, m_treshold=0.8,
                      result_file=output.results, plot_file=output.plot)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'female_xmarkers'
rule female_xmarkers:
    threads: 2
    input:
        bedset = rules.sex_check.output.bedset,
    output:
        bedset = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        exclude_markers = report((tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".exclude"),
                         category="Module 3 Good markers",
                                 caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
    params:
        treshold = config['xmarkers_clean'],
    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
 	# note 1: all samples are now marked as FOUNDERS (no need for "--nonfounders" flag)
 	# note 2: all samples have missing phenotype (no need for "include-nonctrl" flag)

        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        mqc.low_hwe_rate(rule, inTrunk, outTrunk,
                         treshold=params.treshold,
                         hwe_switches = ["--filter-females", "--chr", "23",
                                         "--hardy", "midp"],
                         result_file=output.results, plot_file=output.plot)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'par_regions'
rule par_regions:
    threads: 2
    input:
        bedset = rules.female_xmarkers.output.bedset,  # not same pipe as rot2, but ok since different chr
    output:
        bedset = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bed"),
        results = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        exclude_markers = report((tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".exclude"),
                         category="Module 3 Good markers",
                                 caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        plot = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".png"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
    params:
        treshold = config['xmarkers_clean'],
    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
 	# note 1: all samples are now marked as FOUNDERS (no need for "--nonfounders" flag)
 	# note 2: all samples have missing phenotype (no need for "include-nonctrl" flag)

        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        mqc.low_hwe_rate(rule, inTrunk, outTrunk,
                         treshold=params.treshold,
                         hwe_switches = ["--chr", "25",
                                         "--hardy", "midp"],
                         result_file=output.results, plot_file=output.plot)
        mqc.make_rule_caption(rule, resultPath)

rule_stem = 'clean_male_x'
rule clean_male_x:
    threads: 2
    input:
        bedset = rules.par_regions.output.bedset,
        # heterozygous haploid and nonmale Y chromosome call list from sexcheck
        hh = rules.sex_check.output.hh, 
        bim = rules.sex_check.output.bim, 
    output:
        exclude_markers = report((tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".exclude"),
                                 category="Module 3 Good markers",
                                 caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        chr23 =  (tmpMod3/"{batch}"/"{role}"/"sex_check").with_suffix(".bim23") # chr23 version of input.bim

    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        # outTrunk =  mqc.plinkBase(output.bedset)
        mqc.egrep('^23', input.bim, output.chr23)  # a file with only chr23 rsid in second column
        # the .hh file as multiples, so we pass it as param 1
        mqc.intersect_rsid(input.hh, output.chr23, output.exclude_markers, small_col=2, big_col=1)
        mqc.make_rule_caption(rule, resultPath)

# Note that this rule_stem is hardcoded in m3_output_good_markers
rule_stem = 'sex_clean'
rule sex_clean:
    threads: 2
    input:
        bedset = rules.hwe_autos_geno.output.bedset, # clean_autosomes earlier
        excl_failed_hwe_female_x = rules.female_xmarkers.output.exclude_markers,
        excl_failed_hwe_par_regions = rules.par_regions.output.exclude_markers,
        excl_male_x_markers = rules.clean_male_x.output.exclude_markers,
        # File containing the F-statistics for the sex chromosomes
        f_x = os.path.join(tmpMod3, "{batch}", "{role}", "sexcheck_report_x.sexcheck"),
        # f_y = os.path.join(tmpMod3, "{role}", "sexcheck_report_y.sexcheck")
    output:
        bedset = (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".bed"), # clean_markers earlier
        bedsetbim = os.path.join(tmpMod3, "{batch}", '{role}', rule_stem + '.bim'), # clean_markers earlier
        exclude_markers = report((tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".exclude"),
                        category="Module 3 Good markers",
                        caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        results = report((resultPath/"{batch}"/"{role}"/rule_stem).with_suffix(".yaml"),
                         category="Module 3 Good markers",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst"))
    benchmark:
        (tmpMod3/"{batch}"/"{role}"/rule_stem).with_suffix(".benchmark")
    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])

        inTrunk =  mqc.plinkBase(input.bedset)
        outTrunk =  mqc.plinkBase(output.bedset)

        # Make a list of all earlier fails
        subprocess.call(f'cat {input.excl_failed_hwe_female_x}'
                        f' {input.excl_failed_hwe_par_regions}'
                        f' {input.excl_male_x_markers} > {output.exclude_markers}', shell=True)

        # and remove them
        subprocess.run([plinklocal,
                        "--bfile",inTrunk,
                        "--exclude", output.exclude_markers,
                        "--out", outTrunk,
                        "--make-bed"  ], check=True)

        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",
                                    cols = [0,1,3,4,5],
                                    sanityCheck = "removal", fullList = True,
                                    allele_flip=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        mqc.saveYamlResults(output.results, dropouts)
        mqc.make_rule_caption(rule, resultPath)



rule_stem = 'm3_output_good_markers'
rule m3_output_good_markers:
# Note that this rule creates and reports a non-split bedset. That's good for module 5,
# but not so good for module 4 which wants founders/offspring separated
    threads: 2
    input:
        bedset = rules.m2_output.output.bedset,
        markers = expand(os.path.join(tmpMod3, "{batch}", '{role}', 'sex_clean.bim'), role = ROLES, batch = batches) # Final markerlists
    output:
        good_markers = (tmpMod3/"{batch}"/rule_stem).with_suffix(".txt"),  # called shared_markers.txt before
        # for module 4, input will be rules.ibd_estimate.input.bedset aka output from split_founders_offspring
        mod5_input_bedset = multiext(str(tmpMod2/"{batch}"/rule_stem) ,'.bed','.bim','.fam') ,
        results = report((resultPath/"{batch}"/rule_stem).with_suffix(".yaml"),
                         category="- Module 3 Good markers recap",
                         caption=(resultPath/"{batch}"/rule_stem).with_suffix(".rst")),
        # There is another 'output' that mod4 will use: The founders/offspring bedset just
        # after the split. See rule split_founders_offspring

    run:
        item_type = rule_info[rule]["rule type"]
        mqc.log(runlog, rule_info[rule]["QC test"])
        inTrunk =  mqc.plinkBase(input.bedset[0])
        outTrunk = mqc.plinkBase(output.mod5_input_bedset[0])
        # Module 5: find common markers and extract them from original set
        mqc.intersect_rsid(input.markers[1], input.markers[0],
                           output.good_markers, small_col=1, big_col=1)
        subprocess.run([plinklocal,
                        "--bfile", inTrunk,
                        "--extract", output.good_markers,
                        "--out", outTrunk,
                        "--make-bed" ], check=True)
        dropouts = mqc.checkUpdates(inTrunk+".bim", outTrunk+".bim",
                                    cols = [0,1,3,4,5],
                                    sanityCheck = "removal", fullList = True,
                                    allele_flip=True)
        dropouts.update(rule_info[rule])   # Metainfo and documentation about the rule
        dropouts["Rule"] = rule
        # Let the yaml-file contain info abut last step as well.
        founders = mqc.line_count(input.markers[0])
        offspring = mqc.line_count(input.markers[1])
        common = mqc.line_count(output.good_markers)
        dropouts["Final markers"] = f"founders/offspring/common {founders}/{offspring}/{common}\n"
        mqc.saveYamlResults(output.results, dropouts)
